{"version":3,"file":"index.js","names":["tableCantInsert: Set<string>","n","resultBlots: TypeParchment.Parent[]","blots: Map<string, TypeParchment.Blot>","descendants: InstanceType<T>[]","cur: TypeParchment.Blot | null","targetClass: any","max","min","h: number","bem","hsbValue: HSB","bem","bem","close","bem","errorTip: HTMLElement","errorTip","bem","close","bem","computePosition","platform","flip","placements","sides","side","placement","overflow","offset","shift","min","max","limitShift","getComputedStyle","bem","showTimer: ReturnType<typeof setTimeout> | undefined","closeTimer: ReturnType<typeof setTimeout> | undefined","cleanup: () => void","close","prepare","show","startPosition: Position | undefined","observeEls: Set<ResizeObserveTarget>","options","scrollThresholdX: number","scrollThresholdY: number","maxScrollSpeed: number","inlineStyles: Record<string, string>","styleObject: Record<string, string>","timestamp: ReturnType<typeof setTimeout>","Parchment","Container","Block","BlockEmbed","Parchment","Block","BlockEmbed","currentTableCellInner: TableCellInnerFormat | null","BlockEmbed","Block","BlockEmbed","value: Record<string, any>","target: TypeParchment.Parent","cellRef: TypeParchment.Blot","rowRef: TypeParchment.Blot | null","Parchment","createBlotName: string | undefined","formats: Record<string, any>","Parchment","ArrowUpDown","cur: null | TableCellFormat","skip: SkipRowCount","skip: number[]","cur: TableCellFormat | null","tableBodyBlotNameMap: Record<string, string>","value: Record<string, any>","value","colIds: string[]","cur: null | TableCellFormat","i","insertBefore: TypeParchment.Blot | null","rowId","BlockEmbed","value: Record<string, any>","width: number | string | null","tableColgroup","scroll: TypeScroll","style: Record<string, string | null>","rowGroup: Record<string, TableRowFormat[]>","childs: Record<string, ContainerFormat[]>","cur: TableColFormat | null","Parchment","scroll: any","mainBlotName: Set<string>","child: null | TypeParchment.Blot","mainBlot: Record<string, TypeParchment.Blot>","tableModule: TableUp","quill: Quill","tableModule: TableUp","quill: Quill","icons","Delta","pasteCells","value: CellRecord","updates: CellUpdate[]","positions: { cell: T; rowIndex: number; colIndex: number }[]","cellsToRemove: TableCellInnerFormat[]","Delta","quill: Quill","ops: Record<string, any>[]","cols: Record<string, any>[]","i","tableMenuTools: Record<string, Tool>","Copy","Cut","InsertTop","InsertRight","InsertBottom","InsertLeft","MergeCell","SplitCell","RemoveRow","RemoveColumn","RemoveTable","Background","Border","AutoFull","TableHead","ConvertCell","tableModule: TableUp","quill: Quill","colorMapRow","item","tooltip: MenuTooltipInstance","tableModule: TableUp","quill: Quill","tableModule: TableUp","quill: Quill","offset","tableModule: TableUp","quill: Quill","updateInfo: { index: number; width: number }[]","width","Delta","offset","size","start","end","tableModule: TableUp","quill: Quill","tableRowHeadsSorted: HTMLElement[]","currentBoundary: [Position, Position]","lastX: number","lastY: number","ids: string[]","offset","tableModule: TableUp","quill: Quill","tableRect","rootRect","tableModule: TableUp","quill: Quill","originColWidth: { blot: TableColFormat; width: number }[]","originRowHeight: { blot: TableRowFormat; height: number }[]","quill: Quill","table: HTMLElement","options: { isVertical: boolean }","originDocSelect: typeof document.onselectstart","offset","tableModule: TableUp","tableModule: TableUp","quill: Quill","closestTable","target","closestTableCaption","button","clientX","clientY","Parchment","Delta","tableBlot: TableWrapperFormat","tableMain: TableMainFormat","tableRow: TableRowFormat","tableCell: TableCellFormat","blotName","picker","offset","tds: { td: TableCellFormat; cleanBorder: 'bottom' | 'right' | true }[]","bem","tableMain: TableMainFormat | null","cellColWidth: string[]","lastRowId: string | null","delta: Record<string, any>[]","columnIndex","spanCols: number[]","removeTr: number[]","index","sum","patchTds: Record<string, {\n      rowspan: number;\n      colspan: number;\n      colIndex: number;\n    }>","colspanMap: Record<string, number>","i","firstRowIndex: number | undefined","lastRowIndex: number | undefined"],"sources":["../src/utils/constants.ts","../src/utils/bem.ts","../src/utils/blot-helper.ts","../src/utils/color.ts","../src/utils/is.ts","../src/utils/components/button.ts","../src/utils/components/color-picker.ts","../src/utils/components/dialog.ts","../src/utils/components/input.ts","../src/utils/components/table/creator.ts","../src/utils/components/table/select-box.ts","../node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../node_modules/.pnpm/@floating-ui+core@1.7.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../node_modules/.pnpm/@floating-ui+dom@1.7.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../src/utils/transition-event-helper.ts","../src/utils/components/tooltip.ts","../src/utils/drag-helper.ts","../src/utils/position.ts","../src/utils/resize-observer-helper.ts","../src/utils/scroll.ts","../src/utils/transformer.ts","../src/utils/style-helper.ts","../src/utils/utils.ts","../src/formats/container-format.ts","../src/formats/utils.ts","../src/formats/overrides/block.ts","../src/formats/overrides/block-embed.ts","../src/formats/table-body-format.ts","../src/formats/table-cell-inner-format.ts","../src/formats/overrides/scroll.ts","../src/svg/arrow-up-down.svg","../src/formats/table-caption-format.ts","../src/formats/table-row-format.ts","../src/formats/table-cell-format.ts","../src/formats/table-col-format.ts","../src/formats/table-main-format.ts","../src/formats/table-colgroup-format.ts","../src/formats/table-foot-format.ts","../src/formats/table-head-format.ts","../src/formats/table-wrapper-format.ts","../src/formats/index.ts","../src/modules/table-dom-selector.ts","../src/modules/table-align.ts","../src/modules/table-clipboard/paste-cell-into-cell.ts","../src/modules/table-clipboard/table-clipboard.ts","../src/svg/auto-full.svg","../src/svg/background.svg","../src/svg/border.svg","../src/svg/convert-cell.svg","../src/svg/copy.svg","../src/svg/cut.svg","../src/svg/insert-bottom.svg","../src/svg/insert-left.svg","../src/svg/insert-right.svg","../src/svg/insert-top.svg","../src/svg/merge-cell.svg","../src/svg/remove-column.svg","../src/svg/remove-row.svg","../src/svg/remove-table.svg","../src/svg/split-cell.svg","../src/svg/table-head.svg","../src/modules/table-menu/constants.ts","../src/modules/table-menu/table-menu-common.ts","../src/modules/table-menu/table-menu-contextmenu.ts","../src/modules/table-menu/table-menu-select.ts","../src/modules/table-resize/utils.ts","../src/modules/table-resize/table-resize-common.ts","../src/modules/table-resize/table-resize-drag.ts","../src/modules/table-resize/table-resize-box.ts","../src/modules/table-resize/table-resize-line.ts","../src/modules/table-resize/table-resize-scale.ts","../src/modules/table-scrollbar.ts","../src/modules/table-selection.ts","../src/table-up.ts","../src/index.ts"],"sourcesContent":["import type { Parchment as TypeParchment } from 'quill';\n\nexport const blotName = {\n  container: 'table-up-container',\n  tableCaption: 'table-up-caption',\n  tableWrapper: 'table-up',\n  tableMain: 'table-up-main',\n  tableColgroup: 'table-up-colgroup',\n  tableCol: 'table-up-col',\n  tableHead: 'table-up-head',\n  tableBody: 'table-up-body',\n  tableFoot: 'table-up-foot',\n  tableRow: 'table-up-row',\n  tableCell: 'table-up-cell',\n  tableCellInner: 'table-up-cell-inner',\n} as const;\n\nexport const tableUpSize = {\n  colMinWidthPre: 5,\n  colMinWidthPx: 40,\n  colDefaultWidth: 100,\n  rowMinHeightPx: 36,\n};\n\nexport const tableUpEvent = {\n  AFTER_TABLE_RESIZE: 'after-table-resize',\n  TABLE_SELECTION_DRAG_START: 'table-selection-drag-start',\n  TABLE_SELECTION_DRAG_END: 'table-selection-drag-end',\n  TABLE_SELECTION_CHANGE: 'table-selection-change',\n  TABLE_SELECTION_DISPLAY_CHANGE: 'table-selection-display-change',\n};\n\nexport const tableUpInternal = {\n  moduleName: 'table-up',\n  tableSelectionName: 'table-selection',\n};\n\nexport const defaultColorMap = [\n  [\n    'rgb(255, 255, 255)',\n    'rgb(0, 0, 0)',\n    'rgb(72, 83, 104)',\n    'rgb(41, 114, 244)',\n    'rgb(0, 163, 245)',\n    'rgb(49, 155, 98)',\n    'rgb(222, 60, 54)',\n    'rgb(248, 136, 37)',\n    'rgb(245, 196, 0)',\n    'rgb(153, 56, 215)',\n  ],\n  [\n    'rgb(242, 242, 242)',\n    'rgb(127, 127, 127)',\n    'rgb(243, 245, 247)',\n    'rgb(229, 239, 255)',\n    'rgb(229, 246, 255)',\n    'rgb(234, 250, 241)',\n    'rgb(254, 233, 232)',\n    'rgb(254, 243, 235)',\n    'rgb(254, 249, 227)',\n    'rgb(253, 235, 255)',\n  ],\n  [\n    'rgb(216, 216, 216)',\n    'rgb(89, 89, 89)',\n    'rgb(197, 202, 211)',\n    'rgb(199, 220, 255)',\n    'rgb(199, 236, 255)',\n    'rgb(195, 234, 213)',\n    'rgb(255, 201, 199)',\n    'rgb(255, 220, 196)',\n    'rgb(255, 238, 173)',\n    'rgb(242, 199, 255)',\n  ],\n  [\n    'rgb(191, 191, 191)',\n    'rgb(63, 63, 63)',\n    'rgb(128, 139, 158)',\n    'rgb(153, 190, 255)',\n    'rgb(153, 221, 255)',\n    'rgb(152, 215, 182)',\n    'rgb(255, 156, 153)',\n    'rgb(255, 186, 132)',\n    'rgb(255, 226, 112)',\n    'rgb(213, 142, 255)',\n  ],\n  [\n    'rgb(165, 165, 165)',\n    'rgb(38, 38, 38)',\n    'rgb(53, 59, 69)',\n    'rgb(20, 80, 184)',\n    'rgb(18, 116, 165)',\n    'rgb(39, 124, 79)',\n    'rgb(158, 30, 26)',\n    'rgb(184, 96, 20)',\n    'rgb(163, 130, 0)',\n    'rgb(94, 34, 129)',\n  ],\n  [\n    'rgb(147, 147, 147)',\n    'rgb(13, 13, 13)',\n    'rgb(36, 39, 46)',\n    'rgb(12, 48, 110)',\n    'rgb(10, 65, 92)',\n    'rgb(24, 78, 50)',\n    'rgb(88, 17, 14)',\n    'rgb(92, 48, 10)',\n    'rgb(102, 82, 0)',\n    'rgb(59, 21, 81)',\n  ],\n];\n\nexport const cssNamespace = 'table-up';\n\n// Blots that cannot be inserted into a table\nexport const tableCantInsert: Set<string> = new Set([blotName.tableCellInner]);\n\nexport const isForbidInTableBlot = (blot: TypeParchment.Blot) => tableCantInsert.has(blot.statics.blotName);\nexport function isForbidInTable(current: TypeParchment.Blot): boolean {\n  return current?.parent\n    ? isForbidInTableBlot(current.parent)\n      ? true\n      : isForbidInTable(current.parent)\n    : false;\n}\n","import { cssNamespace } from './constants';\n\nexport function createBEM(b: string, n: string = cssNamespace) {\n  const prefix = n ? `${n}-` : '';\n  return {\n    /** n-b */\n    b: () => `${prefix}${b}`,\n    /** n-b__e */\n    be: (e?: string) => e ? `${prefix}${b}__${e}` : '',\n    /** n-b--m */\n    bm: (m?: string) => m ? `${prefix}${b}--${m}` : '',\n    /** n-b__e--m */\n    bem: (e?: string, m?: string) => e && m ? `${prefix}${b}__${e}--${m}` : '',\n    /** n-s */\n    ns: (s?: string) => s ? `${prefix}${s}` : '',\n    /** n-b-s */\n    bs: (s?: string) => s ? `${prefix}${b}-${s}` : '',\n    /** --n-v */\n    cv: (v?: string) => v ? `--${prefix}${v}` : '',\n    /** is-n */\n    is: (n: string) => `is-${n}`,\n  };\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type { TableBodyFormat, TableCellFormat, TableCellInnerFormat, TableColFormat, TableColgroupFormat, TableMainFormat, TableRowFormat, TableWrapperFormat } from '../formats';\nimport type { blotName } from './constants';\nimport type { Constructor } from './types';\n\ninterface ParentBlotReturnMap {\n  [blotName.tableWrapper]: TableWrapperFormat;\n  [blotName.tableMain]: TableMainFormat;\n  [blotName.tableCol]: TableColFormat;\n  [blotName.tableColgroup]: TableColgroupFormat;\n  [blotName.tableBody]: TableBodyFormat;\n  [blotName.tableRow]: TableRowFormat;\n  [blotName.tableCell]: TableCellFormat;\n  [blotName.tableCellInner]: TableCellInnerFormat;\n}\ntype ParentBlotReturn = {\n  [key: string]: TypeParchment.Parent;\n} & ParentBlotReturnMap;\n\nexport function findParentBlot<T extends TypeParchment.Parent, U extends string = string>(\n  blot: TypeParchment.Blot,\n  targetBlotName: U,\n): U extends keyof ParentBlotReturn ? ParentBlotReturn[U] : T {\n  let target = blot.parent;\n  while (target && target.statics.blotName !== targetBlotName && target !== blot.scroll) {\n    target = target.parent;\n  }\n  if (target === blot.scroll) {\n    throw new Error(`${blot.statics.blotName} must be a child of ${targetBlotName}`);\n  }\n  return target as any;\n}\n\nexport function findParentBlots<T extends (keyof ParentBlotReturnMap | string)[]>(\n  blot: TypeParchment.Blot,\n  targetBlotNames: T,\n): { [K in keyof T]: ParentBlotReturn[T[K]] } {\n  const resultBlots: TypeParchment.Parent[] = new Array(targetBlotNames.length);\n  const blotNameIndexMaps = new Map<string, number>(targetBlotNames.map((name, i) => [name, i]));\n  let target = blot.parent;\n  while (target && target !== blot.scroll) {\n    if (blotNameIndexMaps.size === 0) break;\n    if (blotNameIndexMaps.has(target.statics.blotName)) {\n      const index = blotNameIndexMaps.get(target.statics.blotName)!;\n      resultBlots[index] = target;\n      blotNameIndexMaps.delete(target.statics.blotName);\n    }\n    target = target.parent;\n  }\n  if (blotNameIndexMaps.size > 0) {\n    throw new Error(`${blot.statics.blotName} must be a child of ${Array.from(blotNameIndexMaps.keys()).join(', ')}`);\n  }\n  return resultBlots as any;\n}\n\nexport function findAllParentBlot(Blot: TypeParchment.Blot) {\n  const blots: Map<string, TypeParchment.Blot> = new Map();\n  let target = Blot;\n  while (target && target.statics.blotName !== 'scroll') {\n    blots.set(target.statics.blotName, target);\n    target = target.parent;\n  }\n  return blots;\n}\n\nexport function findChildBlot<T extends TypeParchment.BlotConstructor>(parent: TypeParchment.Parent, blot: T) {\n  const descendants: InstanceType<T>[] = [];\n  const next = parent.children.iterator();\n  let cur: TypeParchment.Blot | null = null;\n  while ((cur = next())) {\n    if (cur instanceof blot) {\n      descendants.push(cur as InstanceType<T>);\n    }\n  }\n  return descendants;\n}\n\nfunction mixinProps<T = any, U = any>(target: T, source: U, excludeReg?: RegExp) {\n  for (const prop of Object.getOwnPropertyNames(source)) {\n    if (excludeReg?.test(prop)) continue;\n    Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop)!);\n  }\n  return target;\n}\nexport function mixinClass<\n  T extends Constructor,\n  U extends Constructor[],\n>(\n  base: T,\n  mixins: U,\n): T & Omit<U[number], 'constructor' | keyof InstanceType<T>> {\n  const targetClass: any = class extends base {};\n  for (const source of mixins) {\n    mixinProps(targetClass.prototype, source.prototype, /^constructor$/);\n  }\n\n  return targetClass;\n}\nexport function isSubclassOf(childClass: any, parentClass: any): boolean {\n  return childClass.prototype && childClass.prototype instanceof parentClass;\n}\n","export interface HSB {\n  h: number;\n  s: number;\n  b: number;\n  a: number;\n}\nexport interface RGB {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\nfunction normalizeValue(value: number | string, max: number | string) {\n  value = Math.min(max as number, Math.max(0, Number.parseFloat(`${value}`)));\n\n  // Handle floating point rounding errors\n  if (Math.abs(value - (max as number)) < 0.000_001) {\n    return 1;\n  }\n\n  // Convert into [0, 1] range if it isn't already\n  return (value % (max as number)) / Number.parseFloat(max as string);\n}\nexport function validateHSB(hsb: HSB): HSB {\n  return {\n    h: Math.min(360, Math.max(0, hsb.h)),\n    s: Math.min(100, Math.max(0, hsb.s)),\n    b: Math.min(100, Math.max(0, hsb.b)),\n    a: Math.min(1, Math.max(0, hsb.a)),\n  };\n}\nexport function HEXtoRGB(hex: string): RGB {\n  hex = hex.startsWith('#') ? hex.slice(1) : hex;\n  const r = Number.parseInt(hex.slice(0, 2), 16);\n  const g = Number.parseInt(hex.slice(2, 4), 16);\n  const b = Number.parseInt(hex.slice(4, 6), 16);\n  const a = Number((Number.parseInt(hex.slice(6, 8) || 'ff', 16) / 255).toFixed(2));\n  return { r, g, b, a };\n}\nexport function RGBtoHSB(rgb: RGB): HSB {\n  let { r, g, b, a } = rgb;\n  r = normalizeValue(r, 255);\n  g = normalizeValue(g, 255);\n  b = normalizeValue(b, 255);\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  let h: number;\n  const v = max;\n\n  const d = max - min;\n  const s = max === 0 ? 0 : d / max;\n\n  if (max === min) {\n    h = 0; // achromatic\n  }\n  else {\n    switch (max) {\n      case r: {\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      }\n      case g: {\n        h = (b - r) / d + 2;\n        break;\n      }\n      case b: {\n        h = (r - g) / d + 4;\n        break;\n      }\n    }\n    h! /= 6;\n  }\n\n  return { h: h! * 360, s: s * 100, b: v * 100, a };\n}\nexport function HSBtoRGB(hsb: HSB): RGB {\n  let { h, s, b, a } = hsb;\n  h = normalizeValue(h, 360) * 6;\n  s = normalizeValue(s, 100);\n  b = normalizeValue(b, 100);\n\n  const i = Math.floor(h);\n  const f = h - i;\n  const p = b * (1 - s);\n  const q = b * (1 - f * s);\n  const t = b * (1 - (1 - f) * s);\n  const mod = i % 6;\n  const r = [b, q, p, p, t, b][mod];\n  const g = [t, b, b, q, p, p][mod];\n  const v = [p, p, t, b, b, q][mod];\n\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(v * 255),\n    a,\n  };\n}\nexport function RGBtoHEX(rgb: RGB): string {\n  const hex = [rgb.r.toString(16), rgb.g.toString(16), rgb.b.toString(16), Math.round(rgb.a * 255).toString(16)];\n  for (const key in hex) {\n    if (hex[key].length === 1) {\n      hex[key] = `0${hex[key]}`;\n    }\n  }\n  return hex.join('');\n}\nexport const HSBtoHEX = (hsb: HSB): string => RGBtoHEX(HSBtoRGB(hsb));\n","export const isFunction = (val: unknown): val is Function => typeof val === 'function';\nexport const isBoolean = (val: unknown): val is boolean => typeof val === 'boolean';\nexport const isArray = Array.isArray;\nexport const isString = (val: unknown): val is string => typeof val === 'string';\nexport const isNumber = (val: unknown): val is number => typeof val === 'number';\nexport const isObject = (val: unknown): val is Record<any, any> => val !== null && typeof val === 'object';\nexport const isUndefined = (val: unknown): val is undefined => val === undefined;\nexport const isValidCellspan = (val: unknown): boolean => !Number.isNaN(val) && Number(val) > 0;\nexport const ensureArray = <T>(val: T | T[]): T[] => isArray(val) ? val : [val];\n","import { createBEM } from '../bem';\nimport { isString } from '../is';\n\ninterface ButtonOptions {\n  type: 'confirm' | 'default';\n  content: HTMLElement | string;\n}\nexport function createButton(options?: Partial<ButtonOptions>) {\n  const { type = 'default', content } = options || {};\n  const bem = createBEM('button');\n  const btn = document.createElement('button');\n  btn.classList.add(bem.b(), type);\n  if (content) {\n    if (isString(content)) {\n      btn.textContent = content;\n    }\n    else {\n      btn.appendChild(content);\n    }\n  }\n  return btn;\n}\n","import type { HSB } from '../color';\nimport { createBEM } from '../bem';\nimport { HEXtoRGB, HSBtoHEX, HSBtoRGB, RGBtoHEX, RGBtoHSB, validateHSB } from '../color';\n\ninterface ColorPickerOptions {\n  color: string;\n  onChange: (color: string) => void;\n}\nexport function createColorPicker(options: Partial<ColorPickerOptions> = {}) {\n  const contentWidth = 230;\n  const contentHeight = 150;\n  const handleSizeSec = 10;\n\n  let hsbValue: HSB = RGBtoHSB(HEXtoRGB(options.color || '#ff0000'));\n  const bem = createBEM('color-picker');\n  const root = document.createElement('div');\n  root.classList.add(bem.b());\n\n  const content = document.createElement('div');\n  content.classList.add(bem.be('content'));\n\n  const colorSelector = document.createElement('div');\n  colorSelector.classList.add(bem.be('selector'));\n\n  const colorBackground = document.createElement('div');\n  colorBackground.classList.add(bem.be('background'));\n  colorSelector.appendChild(colorBackground);\n\n  const colorHandle = document.createElement('div');\n  colorHandle.classList.add(bem.be('background-handle'));\n  colorBackground.appendChild(colorHandle);\n\n  const colorAlpha = document.createElement('div');\n  colorAlpha.classList.add(bem.be('alpha'));\n\n  const alphaBg = document.createElement('div');\n  alphaBg.classList.add(bem.be('alpha-bg'));\n\n  const alphaHandle = document.createElement('div');\n  alphaHandle.classList.add(bem.be('alpha-handle'));\n\n  colorAlpha.appendChild(alphaBg);\n  colorAlpha.appendChild(alphaHandle);\n\n  const colorHue = document.createElement('div');\n  colorHue.classList.add(bem.be('hue'));\n\n  const colorHueHandle = document.createElement('div');\n  colorHueHandle.classList.add(bem.be('hue-handle'));\n  colorHue.appendChild(colorHueHandle);\n\n  const action = document.createElement('div');\n  action.classList.add(bem.be('action'));\n\n  const [colorRInput, colorGInput, colorBInput, colorAInput] = (['r', 'g', 'b', 'a'] as const).map((key) => {\n    const item = document.createElement('div');\n    item.classList.add(bem.be('action-item'), key);\n\n    const label = document.createElement('label');\n    label.textContent = key.toUpperCase();\n\n    const colorInput = document.createElement('input');\n    colorInput.classList.add(bem.be('input'));\n\n    colorInput.addEventListener('input', () => {\n      colorInput.value = colorInput.value.replaceAll(/[^0-9]/g, '');\n    });\n    colorInput.addEventListener('change', () => {\n      let value = Math.round(Number(colorInput.value));\n      if (key === 'a') {\n        value = value / 100;\n      }\n      const result = validateHSB(RGBtoHSB(Object.assign({}, HSBtoRGB(hsbValue), { [key]: value })));\n      updateValue(result);\n      updateUI();\n    });\n\n    item.appendChild(label);\n    item.appendChild(colorInput);\n    action.appendChild(item);\n\n    return colorInput;\n  });\n\n  content.appendChild(colorHue);\n  content.appendChild(colorSelector);\n  content.appendChild(colorAlpha);\n  root.appendChild(content);\n  root.appendChild(action);\n\n  let colorDragging = false;\n  let hueDragging = false;\n  let alphaDragging = false;\n\n  function updateInput() {\n    const hex = HSBtoHEX(hsbValue);\n    for (const [i, input] of [colorRInput, colorGInput, colorBInput].entries()) {\n      input.value = String(Number.parseInt(hex[i * 2] + hex[i * 2 + 1], 16));\n    }\n    colorAInput.value = String((hsbValue.a * 100).toFixed(0));\n  }\n  function updateColorHandle() {\n    Object.assign(colorHandle.style, {\n      left: `${Math.floor((contentWidth * hsbValue.s) / 100)}px`,\n      top: `${Math.floor((contentHeight * (100 - hsbValue.b)) / 100)}px`,\n    });\n  }\n  function updateColorSelector() {\n    colorSelector.style.backgroundColor = `#${RGBtoHEX(HSBtoRGB({\n      h: hsbValue.h,\n      s: 100,\n      b: 100,\n      a: 1,\n    }))}`;\n  }\n  function updateHue() {\n    colorHueHandle.style.top = `${Math.floor(contentHeight - (contentHeight * hsbValue.h) / 360)}px`;\n  }\n  function updateAlphaHandle() {\n    alphaHandle.style.left = `${hsbValue.a * 100}%`;\n  }\n  function updateAlphaBg() {\n    const { r, g, b } = HSBtoRGB(hsbValue);\n    alphaBg.style.background = `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;\n  }\n  function updateUI() {\n    updateColorHandle();\n    updateColorSelector();\n    updateHue();\n    updateAlphaHandle();\n    updateAlphaBg();\n    updateInput();\n  }\n  function updateValue(value: Partial<HSB>) {\n    hsbValue = validateHSB(Object.assign({}, hsbValue, value));\n\n    updateInput();\n\n    if (options.onChange) {\n      options.onChange(`#${HSBtoHEX(hsbValue)}`);\n    }\n  }\n\n  function pickColor(event: MouseEvent) {\n    const rect = colorSelector.getBoundingClientRect();\n    const top = rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);\n    const left = rect.left + document.body.scrollLeft;\n    const saturation = Math.floor((100 * Math.max(0, Math.min(contentWidth, event.pageX - left))) / contentWidth);\n    const brightness = Math.floor((100 * (contentHeight - Math.max(0, Math.min(contentHeight, event.pageY - top)))) / contentHeight);\n\n    updateValue({\n      s: saturation,\n      b: brightness,\n    });\n    updateUI();\n  }\n  function pickHue(event: MouseEvent) {\n    const top = colorHue.getBoundingClientRect().top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);\n\n    updateValue({\n      h: Math.floor((360 * (contentHeight - Math.max(0, Math.min(contentHeight, event.pageY - top)))) / contentHeight),\n    });\n    updateUI();\n  }\n  function pickAlpha(event: MouseEvent) {\n    const { pageX } = event;\n    const rect = colorAlpha.getBoundingClientRect();\n    let left = pageX - rect.left;\n    left = Math.max(handleSizeSec / 2, left);\n    left = Math.min(left, rect.width - handleSizeSec / 2);\n\n    updateValue({\n      a: Math.round(((left - 10 / 2) / (rect.width - 10)) * 100) / 100,\n    });\n    updateUI();\n  }\n\n  function onDrag(event: MouseEvent) {\n    if (colorDragging) {\n      event.preventDefault();\n      pickColor(event);\n    }\n\n    if (hueDragging) {\n      event.preventDefault();\n      pickHue(event);\n    }\n\n    if (alphaDragging) {\n      event.preventDefault();\n      pickAlpha(event);\n    }\n  }\n\n  function onColorSelectorDragEnd() {\n    document.removeEventListener('mousemove', onDrag);\n    document.removeEventListener('mouseup', onColorSelectorDragEnd);\n    colorDragging = false;\n  }\n  function onColorSelectorMousedown(e: MouseEvent) {\n    document.addEventListener('mousemove', onDrag);\n    document.addEventListener('mouseup', onColorSelectorDragEnd);\n    colorDragging = true;\n    pickColor(e);\n  }\n  colorSelector.addEventListener('mousedown', onColorSelectorMousedown);\n\n  function onColorHueDragEnd() {\n    document.removeEventListener('mousemove', onDrag);\n    document.removeEventListener('mouseup', onColorHueDragEnd);\n    hueDragging = false;\n  }\n  function onColorHueMousedown(event: MouseEvent) {\n    document.addEventListener('mousemove', onDrag);\n    document.addEventListener('mouseup', onColorHueDragEnd);\n    hueDragging = true;\n    pickHue(event);\n  }\n  colorHue.addEventListener('mousedown', onColorHueMousedown);\n\n  function onColorAlphaDragEnd() {\n    document.removeEventListener('mousemove', onDrag);\n    document.removeEventListener('mouseup', onColorAlphaDragEnd);\n    alphaDragging = false;\n  }\n  function onColorAlphaMousedown(event: MouseEvent) {\n    document.addEventListener('mousemove', onDrag);\n    document.addEventListener('mouseup', onColorAlphaDragEnd);\n    alphaDragging = true;\n    pickAlpha(event);\n  }\n  colorAlpha.addEventListener('mousedown', onColorAlphaMousedown);\n\n  updateUI();\n  return root;\n}\n","import { createBEM } from '../bem';\nimport { createButton } from './button';\n\ninterface DialogOptions {\n  child?: HTMLElement;\n  target?: HTMLElement;\n  beforeClose?: () => void;\n}\nlet zindex = 8000;\nexport function createDialog({ child, target = document.body, beforeClose = () => {} }: DialogOptions = {}) {\n  const bem = createBEM('dialog');\n  const appendTo = target;\n  const dialog = document.createElement('div');\n  dialog.classList.add(bem.b());\n  dialog.style.zIndex = String(zindex);\n  const overlay = document.createElement('div');\n  overlay.classList.add(bem.be('overlay'));\n  dialog.appendChild(overlay);\n  if (child) {\n    const content = document.createElement('div');\n    content.classList.add(bem.be('content'));\n    content.appendChild(child);\n    overlay.appendChild(content);\n    content.addEventListener('click', (e) => {\n      e.stopPropagation();\n    });\n  }\n\n  const originOverflow = getComputedStyle(appendTo).overflow;\n  appendTo.style.overflow = 'hidden';\n\n  appendTo.appendChild(dialog);\n  const close = () => {\n    beforeClose();\n    dialog.remove();\n    appendTo.style.overflow = originOverflow;\n  };\n  dialog.addEventListener('click', close);\n  zindex += 1;\n\n  return { dialog, close };\n}\n\nexport async function createConfirmDialog({ message, confirm, cancel }: {\n  message: string;\n  confirm: string;\n  cancel: string;\n}) {\n  return new Promise<boolean>((resolve) => {\n    const content = document.createElement('div');\n    Object.assign(content.style, {\n      padding: '8px 12px',\n      fontSize: '14px',\n      lineHeight: '1.5',\n    });\n    const tip = document.createElement('p');\n    tip.textContent = message;\n    const btnWrapper = document.createElement('div');\n    Object.assign(btnWrapper.style, {\n      display: 'flex',\n      justifyContent: 'flex-end',\n      gap: `6px`,\n    });\n    const cancelBtn = createButton({ content: cancel });\n    const confirmBtn = createButton({ type: 'confirm', content: confirm });\n\n    btnWrapper.appendChild(cancelBtn);\n    btnWrapper.appendChild(confirmBtn);\n    content.appendChild(tip);\n    content.appendChild(btnWrapper);\n\n    const { close } = createDialog({ child: content });\n\n    cancelBtn.addEventListener('click', () => {\n      resolve(false);\n      close();\n    });\n    confirmBtn.addEventListener('click', () => {\n      resolve(true);\n      close();\n    });\n  });\n}\n","import { createBEM } from '../bem';\n\ninterface InputOptions {\n  type?: string;\n  value?: string;\n  max?: number;\n  min?: number;\n  [key: string]: any;\n}\nexport function createInputItem(label: string, options: InputOptions) {\n  const bem = createBEM('input');\n  options.type || (options.type = 'text');\n  options.value || (options.value = '');\n\n  const inputItem = document.createElement('div');\n  inputItem.classList.add(bem.be('item'));\n\n  if (label) {\n    const inputLabel = document.createElement('span');\n    inputLabel.classList.add(bem.be('label'));\n    inputLabel.textContent = label;\n    inputItem.appendChild(inputLabel);\n  }\n\n  const inputInput = document.createElement('div');\n  inputInput.classList.add(bem.be('input'));\n  const input = document.createElement('input');\n  for (const key in options) {\n    input.setAttribute(key, options[key]);\n  }\n  if (options.max || options.min) {\n    input.addEventListener('blur', () => {\n      if (options.max && options.max <= Number(input.value)) {\n        input.value = String(options.max);\n      }\n      if (options.min && options.min >= Number(input.value)) {\n        input.value = String(options.min);\n      }\n    });\n  }\n\n  inputInput.appendChild(input);\n  inputItem.appendChild(inputInput);\n\n  input.addEventListener('focus', () => {\n    inputInput.classList.add('focus');\n  });\n  input.addEventListener('blur', () => {\n    inputInput.classList.remove('focus');\n  });\n\n  const errorTip = (msg: string) => {\n    let errorTip: HTMLElement;\n    if (inputInput.classList.contains('error')) {\n      errorTip = inputInput.querySelector(`.${bem.be('error-tip')}`)!;\n    }\n    else {\n      errorTip = document.createElement('span');\n      errorTip.classList.add(bem.be('error-tip'));\n      inputInput.appendChild(errorTip);\n    }\n\n    errorTip.textContent = msg;\n    inputInput.classList.add('error');\n\n    const removeError = () => {\n      inputInput.classList.remove('error');\n      errorTip.remove();\n    };\n    return { removeError };\n  };\n\n  return { item: inputItem, input, errorTip };\n}\n","import type { TableCreatorTextOptions } from '../../types';\nimport { createBEM } from '../../bem';\nimport { createButton } from '../button';\nimport { createDialog } from '../dialog';\nimport { createInputItem } from '../input';\n\ninterface TableCreatorOptions extends Omit<TableCreatorTextOptions, 'customBtnText'> {\n  row: number;\n  col: number;\n}\nexport async function showTableCreator(options: Partial<TableCreatorOptions> = {}) {\n  const bem = createBEM('creator');\n  const box = document.createElement('div');\n  box.classList.add(bem.b());\n  const inputContent = document.createElement('div');\n  inputContent.classList.add(bem.be('input'));\n\n  const {\n    item: rowItem,\n    input: rowInput,\n    errorTip: rowErrorTip,\n  } = createInputItem(options.rowText || 'Row', { type: 'number', value: String(options.row || ''), max: 99 });\n  const {\n    item: colItem,\n    input: colInput,\n    errorTip: colErrorTip,\n  } = createInputItem(options.colText || 'Column', { type: 'number', value: String(options.col || ''), max: 99 });\n\n  inputContent.appendChild(rowItem);\n  inputContent.appendChild(colItem);\n  box.appendChild(inputContent);\n\n  const control = document.createElement('div');\n  control.classList.add(bem.be('control'));\n\n  const confirmBtn = createButton({ type: 'confirm', content: options.confirmText || 'Confirm' });\n  const cancelBtn = createButton({ type: 'default', content: options.cancelText || 'Cancel' });\n\n  control.appendChild(confirmBtn);\n  control.appendChild(cancelBtn);\n  box.appendChild(control);\n\n  const validateInput = (row: number = Number(rowInput.value), col: number = Number(colInput.value)) => {\n    if (Number.isNaN(row) || row <= 0) {\n      rowErrorTip(options.notPositiveNumberError || 'Please enter a positive integer');\n      return;\n    }\n    if (Number.isNaN(col) || col <= 0) {\n      colErrorTip(options.notPositiveNumberError || 'Please enter a positive integer');\n      return;\n    }\n    return { row, col };\n  };\n  const keyboardClose = (e: KeyboardEvent) => {\n    if (e.key === 'Escape') {\n      close();\n      document.removeEventListener('keydown', keyboardClose);\n    }\n  };\n\n  return new Promise<{ row: number; col: number }>((resolve, reject) => {\n    const { close } = createDialog({ child: box, beforeClose: reject });\n    rowInput.focus();\n\n    for (const input of [rowInput, colInput]) {\n      input.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          const result = validateInput();\n          if (result) {\n            resolve(result);\n            close();\n          }\n        }\n      });\n    }\n    confirmBtn.addEventListener('click', () => {\n      const result = validateInput();\n      if (result) {\n        resolve(result);\n        close();\n      }\n    });\n    document.addEventListener('keydown', keyboardClose);\n    cancelBtn.addEventListener('click', close);\n  })\n    .finally(() => {\n      document.removeEventListener('keydown', keyboardClose);\n    });\n}\n","import type { TableCreatorTextOptions } from '../../types';\nimport { createBEM } from '../../bem';\nimport { showTableCreator } from './creator';\n\ninterface TableSelectOptions {\n  row: number;\n  col: number;\n  onSelect: (row: number, col: number) => void;\n  customBtn: boolean;\n  texts: Partial<TableCreatorTextOptions>;\n}\nexport function createSelectBox(options: Partial<TableSelectOptions> = {}) {\n  const bem = createBEM('select-box');\n  const selectDom = document.createElement('div');\n  selectDom.classList.add(bem.b());\n\n  const selectBlock = document.createElement('div');\n  selectBlock.classList.add(bem.be('block'));\n  for (let r = 0; r < (options.row || 8); r++) {\n    for (let c = 0; c < (options.col || 8); c++) {\n      const selectItem = document.createElement('div');\n      selectItem.classList.add(bem.be('item'));\n      selectItem.dataset.row = String(r + 1);\n      selectItem.dataset.col = String(c + 1);\n      selectBlock.appendChild(selectItem);\n    }\n  }\n  const updateSelectBlockItems = () => {\n    const { row, col } = selectDom.dataset;\n    for (const item of Array.from(selectBlock.querySelectorAll('.active'))) {\n      item.classList.remove('active');\n    }\n    if (!row || !col) return;\n    const childs = Array.from(selectBlock.children) as HTMLElement[];\n    for (const child of childs) {\n      const { row: childRow, col: childCol } = child.dataset;\n      if (childRow! > row && childCol! > col) {\n        return;\n      }\n      child.classList.toggle('active', childRow! <= row && childCol! <= col);\n    }\n  };\n  selectBlock.addEventListener('mousemove', (e) => {\n    if (!e.target) return;\n    const { row, col } = (e.target as HTMLElement).dataset;\n    if (!row || !col) return;\n    selectDom.dataset.row = row;\n    selectDom.dataset.col = col;\n    updateSelectBlockItems();\n  });\n  selectBlock.addEventListener('mouseleave', () => {\n    selectDom.removeAttribute('data-row');\n    selectDom.removeAttribute('data-col');\n    updateSelectBlockItems();\n  });\n  selectBlock.addEventListener('click', () => {\n    const { row, col } = selectDom.dataset;\n    if (!row || !col) return;\n    options.onSelect?.(Number(row), Number(col));\n  });\n  selectDom.appendChild(selectBlock);\n\n  if (options.customBtn) {\n    const texts = options.texts || {};\n    const selectCustom = document.createElement('div');\n    selectCustom.classList.add(bem.be('custom'));\n    selectCustom.textContent = texts.customBtnText || 'Custom';\n    selectCustom.addEventListener('click', async () => {\n      const res = await showTableCreator(texts);\n      if (res) {\n        options.onSelect?.(res.row, res.col);\n      }\n    });\n    selectDom.appendChild(selectCustom);\n  }\n\n  return selectDom;\n}\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle as getComputedStyle$1, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle$1(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll) {\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Safety check: ensure the scrollbar space is reasonable in case this\n// calculation is affected by unusual styles.\n// Most scrollbars leave 15-18px of space.\nconst SCROLLBAR_MAX = 25;\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  const windowScrollbarX = getWindowScrollBarX(html);\n  // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the\n  // visual width of the <html> but this is not considered in the size\n  // of `html.clientWidth`.\n  if (windowScrollbarX <= 0) {\n    const doc = html.ownerDocument;\n    const body = doc.body;\n    const bodyStyles = getComputedStyle(body);\n    const bodyMarginInline = doc.compatMode === 'CSS1Compat' ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;\n    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);\n    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {\n      width -= clippingStableScrollbarWidth;\n    }\n  } else if (windowScrollbarX <= SCROLLBAR_MAX) {\n    // If the <body> scrollbar is on the left, the width needs to be extended\n    // by the scrollbar amount so there isn't extra space on the right.\n    width += windowScrollbarX;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle$1(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle$1(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","export function handleIfTransitionend(domNode: HTMLElement, duration: number, handler: () => void, options?: boolean | AddEventListenerOptions, lastTimer?: ReturnType<typeof setTimeout>): ReturnType<typeof setTimeout> {\n  if (lastTimer) clearTimeout(lastTimer);\n  domNode.addEventListener('transitionend', handler, options);\n  // handle remove when transition set none\n  return setTimeout(() => {\n    handler();\n  }, duration);\n}\n","import {\n  autoUpdate,\n  computePosition,\n  flip,\n  limitShift,\n  offset,\n  shift,\n} from '@floating-ui/dom';\nimport { createBEM } from '../bem';\nimport { handleIfTransitionend } from '../transition-event-helper';\n\nexport interface ToolTipOptions {\n  direction?:\n    | 'top'\n    | 'top-start'\n    | 'top-end'\n    | 'bottom'\n    | 'bottom-start'\n    | 'bottom-end'\n    | 'right'\n    | 'right-start'\n    | 'right-end'\n    | 'left'\n    | 'left-start'\n    | 'left-end';\n  msg?: string;\n  delay?: number;\n  content?: HTMLElement;\n  container?: HTMLElement;\n  type?: 'hover' | 'click';\n  onOpen?: (force?: boolean) => boolean;\n  onClose?: (force?: boolean) => boolean;\n  closed?: () => void;\n  onDestroy?: () => void;\n}\nconst DISTANCE = 4;\nexport interface TooltipInstance {\n  destroy: () => void;\n  show: (force?: boolean) => void;\n  hide: (force?: boolean) => void;\n}\nexport function createTooltip(target: HTMLElement, options: ToolTipOptions = {}): TooltipInstance | null {\n  const { msg = '', delay = 150, content, direction = 'bottom', type = 'hover', container, onOpen, onClose, closed, onDestroy } = options;\n  const bem = createBEM('tooltip');\n  if (msg || content) {\n    const appendTo = container || document.body;\n    const tooltip = document.createElement('div');\n    tooltip.classList.add(bem.b(), 'hidden', 'transparent');\n    if (content) {\n      tooltip.appendChild(content);\n    }\n    else if (msg) {\n      tooltip.textContent = msg;\n    }\n    let showTimer: ReturnType<typeof setTimeout> | undefined;\n    let closeTimer: ReturnType<typeof setTimeout> | undefined;\n    let cleanup: () => void;\n    const update = () => {\n      if (cleanup) cleanup();\n      computePosition(target, tooltip, {\n        placement: direction,\n        middleware: [flip(), shift({ limiter: limitShift() }), offset(DISTANCE)],\n      }).then(({ x, y }) => {\n        Object.assign(tooltip.style, {\n          left: `${x}px`,\n          top: `${y}px`,\n        });\n      });\n    };\n    const transitionendHandler = () => {\n      tooltip.classList.add('hidden');\n      if (appendTo.contains(tooltip)) {\n        appendTo.removeChild(tooltip);\n      }\n      if (cleanup) cleanup();\n      if (closed) closed();\n    };\n\n    const openTooltip = (force: boolean = false) => {\n      if (closeTimer) clearTimeout(closeTimer);\n\n      showTimer = setTimeout(() => {\n        if (onOpen) {\n          const allow = onOpen(force);\n          if (!force && allow) return;\n        }\n        appendTo.appendChild(tooltip);\n        tooltip.removeEventListener('transitionend', transitionendHandler);\n        tooltip.classList.remove('hidden');\n\n        cleanup = autoUpdate(target, tooltip, update);\n\n        tooltip.classList.remove('transparent');\n      }, delay);\n    };\n    const closeTooltip = (force: boolean = false) => {\n      if (showTimer) clearTimeout(showTimer);\n      closeTimer = setTimeout(() => {\n        if (onClose) {\n          const allow = onClose(force);\n          if (!force && allow) return;\n        }\n        handleIfTransitionend(tooltip, 150, transitionendHandler, { once: true });\n        tooltip.classList.add('transparent');\n      }, delay);\n    };\n\n    const hoverDisplay = () => {\n      const eventListeners = [target, tooltip];\n      const close = closeTooltip.bind(undefined, false);\n      const open = openTooltip.bind(undefined, false);\n      const prepare = () => {\n        for (const listener of eventListeners) {\n          listener.addEventListener('mouseenter', open);\n          listener.addEventListener('mouseleave', close);\n        }\n      };\n      return {\n        prepare,\n        show: openTooltip,\n        hide: closeTooltip,\n        destroy: () => {\n          for (const listener of eventListeners) {\n            listener.removeEventListener('mouseenter', open);\n            listener.removeEventListener('mouseleave', close);\n          }\n        },\n      };\n    };\n    const clickDisplay = () => {\n      const close = (e: MouseEvent) => {\n        e.stopPropagation();\n        closeTooltip(false);\n      };\n      const show = (e: MouseEvent) => {\n        e.stopPropagation();\n        openTooltip();\n        document.removeEventListener('click', close);\n        document.addEventListener('click', close, { once: true });\n      };\n      return {\n        prepare: () => {\n          tooltip.addEventListener('click', (e: Event) => e.stopPropagation());\n          target.addEventListener('click', show);\n        },\n        show: openTooltip,\n        hide: (force: boolean = false) => {\n          closeTooltip(force);\n          document.removeEventListener('click', close);\n        },\n        destroy: () => {\n          target.removeEventListener('click', show);\n          document.removeEventListener('click', close);\n        },\n      };\n    };\n    const displayMethods = {\n      hover: hoverDisplay,\n      click: clickDisplay,\n    };\n\n    const { prepare, show, hide, destroy: destroyDisplay } = displayMethods[type]();\n    prepare();\n\n    const destroy = () => {\n      hide(true);\n      if (onDestroy) onDestroy();\n      destroyDisplay();\n      if (cleanup) cleanup();\n      tooltip.remove();\n    };\n    return {\n      show,\n      hide,\n      destroy,\n    };\n  }\n  return null;\n}\n","import type { Position } from './types';\n\nexport interface DragPosition {\n  startPosition: Position;\n  position: Position;\n  movePosition: Position;\n}\nexport interface DragElementOptions {\n  axis: 'x' | 'y' | 'both';\n  onStart: (position: DragPosition, e: PointerEvent) => void | boolean;\n  onMove: (position: DragPosition, e: PointerEvent) => void;\n  onEnd: (position: DragPosition, e: PointerEvent) => void;\n  buttons: number[];\n  container: HTMLElement;\n  draggingElement: HTMLElement | Window | Document;\n  exact: boolean;\n}\n\nexport function dragElement(target: HTMLElement, options: Partial<DragElementOptions> = {}) {\n  const {\n    axis = 'both',\n    onMove = () => {},\n    onStart = () => {},\n    onEnd = () => {},\n    buttons = [0],\n    container,\n    draggingElement = document,\n    exact = true,\n  } = options;\n\n  let position = { x: 0, y: 0 };\n  let startPosition: Position | undefined;\n  let startPoint = { x: 0, y: 0 };\n\n  function updatePositionByEvent(e: PointerEvent) {\n    if (!startPosition) return;\n    const targetRect = target.getBoundingClientRect();\n    let { x, y } = position;\n    if (axis === 'x' || axis === 'both') {\n      x = e.clientX - startPosition.x;\n      if (container) {\n        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect!.width);\n      }\n    }\n    if (axis === 'y' || axis === 'both') {\n      y = e.clientY - startPosition.y;\n      if (container) {\n        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect!.height);\n      }\n    }\n    position = {\n      x,\n      y,\n    };\n  }\n  function handlePointerDown(e: PointerEvent) {\n    if (!buttons.includes(e.button)) return;\n    if (exact && e.target !== target) return;\n\n    (draggingElement as HTMLElement).addEventListener('pointerup', handlePointerUp);\n    (draggingElement as HTMLElement).addEventListener('pointermove', handlePointerMove);\n\n    const containerRect = container?.getBoundingClientRect?.();\n    const targetRect = target.getBoundingClientRect();\n    const pos = {\n      x: e.clientX - (container ? targetRect.left - containerRect!.left + container.scrollLeft : targetRect.left),\n      y: e.clientY - (container ? targetRect.top - containerRect!.top + container.scrollTop : targetRect.top),\n    };\n    startPoint = { x: e.clientX, y: e.clientY };\n    if (onStart({\n      position,\n      startPosition: pos,\n      movePosition: { x: e.clientX - startPoint.x, y: e.clientY - startPoint.y },\n    }, e) === false) {\n      return;\n    }\n\n    startPosition = pos;\n    position = pos;\n  }\n  function handlePointerMove(e: PointerEvent) {\n    if (!startPosition) return;\n    updatePositionByEvent(e);\n    onMove({\n      position,\n      startPosition,\n      movePosition: { x: e.clientX - startPoint.x, y: e.clientY - startPoint.y },\n    }, e);\n  }\n  function handlePointerUp(e: PointerEvent) {\n    (draggingElement as HTMLElement).removeEventListener('pointermove', handlePointerMove);\n    (draggingElement as HTMLElement).removeEventListener('pointerup', handlePointerUp);\n    updatePositionByEvent(e);\n    onEnd({\n      position,\n      startPosition: startPosition!,\n      movePosition: { x: e.clientX - startPoint.x, y: e.clientY - startPoint.y },\n    }, e);\n    startPosition = undefined;\n    startPoint = { x: 0, y: 0 };\n    position = { x: 0, y: 0 };\n  }\n\n  (draggingElement as HTMLElement).addEventListener('pointerdown', handlePointerDown);\n\n  const stop = () => {\n    (draggingElement as HTMLElement).removeEventListener('pointerdown', handlePointerDown);\n  };\n  return {\n    stop,\n  };\n}\n","import type { RelactiveRect } from './types';\n\nexport function isRectanglesIntersect<T extends Omit<RelactiveRect, 'width' | 'height'>>(a: T, b: T, tolerance = 0, edgeJudge: boolean = true) {\n  const { x: minAx, y: minAy, x1: maxAx, y1: maxAy } = a;\n  const { x: minBx, y: minBy, x1: maxBx, y1: maxBy } = b;\n\n  let notOverlapX;\n  let notOverlapY;\n  if (edgeJudge) {\n    notOverlapX = maxAx < minBx + tolerance || minAx - tolerance > maxBx;\n    notOverlapY = maxAy < minBy + tolerance || minAy - tolerance > maxBy;\n  }\n  else {\n    notOverlapX = maxAx <= minBx + tolerance || minAx - tolerance >= maxBx;\n    notOverlapY = maxAy <= minBy + tolerance || minAy - tolerance >= maxBy;\n  }\n  return !(notOverlapX || notOverlapY);\n}\n\nexport function getRelativeRect(targetRect: Omit<RelactiveRect, 'x1' | 'y1'>, container: HTMLElement): RelactiveRect {\n  const containerRect = container.getBoundingClientRect();\n  return {\n    x: targetRect.x - containerRect.x - container.scrollLeft,\n    y: targetRect.y - containerRect.y - container.scrollTop,\n    x1: targetRect.x - containerRect.x - container.scrollLeft + targetRect.width,\n    y1: targetRect.y - containerRect.y - container.scrollTop + targetRect.height,\n    width: targetRect.width,\n    height: targetRect.height,\n  };\n}\n\nconst viewportPadding = 8;\nexport function limitDomInViewPort(rect: { left: number; top: number; width: number; height: number }) {\n  let { left, top, width, height } = rect;\n  const { clientWidth, clientHeight } = document.documentElement;\n  let leftLimited = false;\n  let topLimited = false;\n  if (left + width > clientWidth) {\n    left = clientWidth - width - viewportPadding;\n    leftLimited = true;\n  }\n  else if (left < 0) {\n    left = viewportPadding;\n    leftLimited = true;\n  }\n  if (top + height > clientHeight) {\n    top = clientHeight - height - viewportPadding;\n    topLimited = true;\n  }\n  else if (top < 0) {\n    top = viewportPadding;\n    topLimited = true;\n  }\n  return {\n    left,\n    top,\n    leftLimited,\n    topLimited,\n  };\n}\n","export interface CreateResizeObserverOptions {\n  ignoreFirstBind: boolean;\n}\nexport function createResizeObserver(callback: (entries: ResizeObserverEntry[]) => void, options: Partial<CreateResizeObserverOptions> = {}) {\n  const ignoreFirstBindSymbol = Symbol('ignoreFirstBind');\n  type ResizeObserveTarget = Element & { [ignoreFirstBindSymbol]?: boolean };\n  const observeEls: Set<ResizeObserveTarget> = new Set();\n  const observer = new ResizeObserver((entries) => {\n    // prevent when element first bind\n    if (\n      options.ignoreFirstBind\n      && entries.some((entry) => {\n        const target = entry.target as ResizeObserveTarget;\n        const originVal = target[ignoreFirstBindSymbol];\n        target[ignoreFirstBindSymbol] = true;\n        return !originVal;\n      })\n    ) {\n      return;\n    }\n    callback(entries);\n  });\n  const originObserve = observer.observe.bind(observer);\n  observer.observe = (target: ResizeObserveTarget, options?: ResizeObserverOptions) => {\n    observeEls.add(target);\n    originObserve(target, options);\n  };\n\n  const originUnobserve = observer.unobserve;\n  observer.unobserve = (target: ResizeObserveTarget) => {\n    if (observeEls.has(target)) {\n      observeEls.delete(target);\n      target[ignoreFirstBindSymbol] = undefined;\n    }\n    originUnobserve.call(observer, target);\n  };\n\n  const originDisconnect = observer.disconnect;\n  observer.disconnect = () => {\n    for (const target of observeEls.values()) {\n      target[ignoreFirstBindSymbol] = undefined;\n    }\n    originDisconnect.call(observer);\n  };\n\n  return observer;\n}\n","export interface ScrollHandle {\n  scrollHandler: [HTMLElement, (e: Event) => void][];\n}\nexport function addScrollEvent(this: ScrollHandle, dom: HTMLElement, handle: (e: Event) => void) {\n  dom.addEventListener('scroll', handle);\n  this.scrollHandler.push([dom, handle]);\n}\n\nexport function removeScrollEvent(this: ScrollHandle, dom: HTMLElement, handle: (e: Event) => void) {\n  for (let i = 0; i < this.scrollHandler.length; i++) {\n    const [_dom, _handle] = this.scrollHandler[i];\n    if (_dom === dom && _handle === handle) {\n      this.scrollHandler.splice(i, 1);\n      break;\n    }\n  }\n}\n\nexport function clearScrollEvent(this: ScrollHandle) {\n  for (const [dom, handle] of this.scrollHandler) {\n    dom.removeEventListener('scroll', handle);\n  }\n  this.scrollHandler = [];\n}\n\nexport function getElementScrollPosition(el: HTMLElement) {\n  return {\n    y: el.scrollTop,\n    x: el.scrollLeft,\n  };\n}\n\nexport function getScrollBarWidth({ target = document.body } = {}): number {\n  const outer = document.createElement('div');\n  Object.assign(outer.style, {\n    visibility: 'hidden',\n    width: '100px',\n    height: '100%',\n    overflow: 'auto',\n    position: 'absolute',\n    top: '-9999px',\n  });\n  target.appendChild(outer);\n\n  const widthNoScroll = outer.offsetWidth;\n  outer.style.overflow = 'scroll';\n\n  const inner = document.createElement('div');\n  inner.style.width = '100%';\n  outer.appendChild(inner);\n\n  const widthWithScroll = inner.offsetWidth;\n  outer.parentNode?.removeChild(outer);\n\n  return widthNoScroll - widthWithScroll;\n}\n\nexport class AutoScroller {\n  mouseY = 0;\n  mouseX = 0;\n  private animationId: number | null = null;\n\n  constructor(\n    public scrollThresholdX: number = 50,\n    public scrollThresholdY: number = 20,\n    public maxScrollSpeed: number = 20,\n  ) {}\n\n  checkMinY(containerRect: DOMRect) {\n    return this.mouseY < containerRect.top + this.scrollThresholdY;\n  }\n\n  checkMaxY(containerRect: DOMRect) {\n    return this.mouseY > containerRect.bottom - this.scrollThresholdY;\n  }\n\n  checkMinX(containerRect: DOMRect) {\n    return this.mouseX < containerRect.left + this.scrollThresholdX;\n  }\n\n  checkMaxX(containerRect: DOMRect) {\n    return this.mouseX > containerRect.right - this.scrollThresholdX;\n  }\n\n  start(container: HTMLElement, onScroll?: (speedX: number, speedY: number) => void) {\n    // before call `start` also need call `updateMousePosition`\n    // consider if needed put `getBoundingClientRect` in `scroll`\n    const rect = container.getBoundingClientRect();\n    const scroll = () => {\n      let scrolled = false;\n      let speedX = 0;\n      let speedY = 0;\n      if (this.checkMinY(rect)) {\n        const distance = rect.top + this.scrollThresholdY - this.mouseY;\n        const speed = Math.min(distance / this.scrollThresholdY * this.maxScrollSpeed, this.maxScrollSpeed);\n        container.scrollTop -= speed;\n        speedY = -1 * speed;\n        scrolled = true;\n      }\n      else if (this.checkMaxY(rect)) {\n        const distance = this.mouseY - (rect.bottom - this.scrollThresholdY);\n        const speed = Math.min(distance / this.scrollThresholdY * this.maxScrollSpeed, this.maxScrollSpeed);\n        container.scrollTop += speed;\n        speedY = speed;\n        scrolled = true;\n      }\n\n      if (this.checkMinX(rect)) {\n        const distance = rect.left + this.scrollThresholdX - this.mouseX;\n        const speed = Math.min(distance / this.scrollThresholdX * this.maxScrollSpeed, this.maxScrollSpeed);\n        container.scrollLeft -= speed;\n        speedX = -1 * speed;\n        scrolled = true;\n      }\n      else if (this.checkMaxX(rect)) {\n        const distance = this.mouseX - (rect.right - this.scrollThresholdX);\n        const speed = Math.min(distance / this.scrollThresholdX * this.maxScrollSpeed, this.maxScrollSpeed);\n        container.scrollLeft += speed;\n        speedX = speed;\n        scrolled = true;\n      }\n\n      if (scrolled && onScroll) {\n        onScroll(speedX, speedY);\n      }\n      this.animationId = requestAnimationFrame(scroll);\n    };\n\n    this.animationId = requestAnimationFrame(scroll);\n  }\n\n  // update mouse position when `mousemove` event triggered\n  updateMousePosition(x: number, y: number) {\n    this.mouseX = x;\n    this.mouseY = y;\n  }\n\n  // stop listening scroll event when `mouseup` event triggered\n  stop() {\n    if (this.animationId !== null) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n  }\n}\n","export function toKebabCase(key: string) {\n  const result = key.replaceAll(/([A-Z])/g, ' $1').trim();\n  return result.split(' ').join('-').toLowerCase();\n}\n\nexport function toCamelCase(key: string) {\n  return key.replaceAll(/-(\\w)/g, (all, letter) => {\n    return letter.toUpperCase();\n  });\n}\n","import { toCamelCase, toKebabCase } from './transformer';\n\nexport function getInlineStyles(domNode: HTMLElement): Record<string, string> {\n  const inlineStyles: Record<string, string> = {};\n  if (!domNode.style.cssText) {\n    return inlineStyles;\n  }\n\n  const cssText = domNode.style.cssText;\n  const declarations = cssText.split(';').filter(decl => decl.trim());\n  for (const declaration of declarations) {\n    const colonIndex = declaration.indexOf(':');\n    if (colonIndex === -1) continue;\n\n    const property = declaration.slice(0, colonIndex).trim();\n    const value = declaration.slice(colonIndex + 1).trim();\n    inlineStyles[property] = value;\n  }\n\n  return inlineStyles;\n}\n\nexport function cssTextToObject(cssText: string): Record<string, string> {\n  const styleObject: Record<string, string> = {};\n\n  const styles = cssText.trim().split(';');\n\n  for (const item of styles) {\n    const style = item.trim();\n    if (!style) continue;\n\n    const colonPosition = style.indexOf(':');\n    if (colonPosition === -1) continue;\n\n    const property = style.slice(0, Math.max(0, colonPosition)).trim();\n    const value = style.slice(Math.max(0, colonPosition + 1)).trim();\n    styleObject[toCamelCase(property)] = value;\n  }\n\n  return styleObject;\n}\n\nexport function objectToCssText(obj: Record<string, any>): string {\n  return Object.entries(obj)\n    .map(([key, value]) => `${toKebabCase(key)}: ${value};`)\n    .join(' ');\n}\n","export const randomId = () => Math.random().toString(36).slice(2);\nexport function debounce<T extends (...args: any[]) => any>(fn: T, delay: number) {\n  let timestamp: ReturnType<typeof setTimeout>;\n  return function (this: any, ...args: Parameters<T>) {\n    if (timestamp) {\n      clearTimeout(timestamp);\n    }\n    timestamp = setTimeout(() => {\n      fn.apply(this, args);\n    }, delay);\n  };\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport Quill from 'quill';\nimport { blotName, isFunction } from '../utils';\n\nconst Parchment = Quill.import('parchment');\nconst Container = Quill.import('blots/container') as typeof TypeParchment.ContainerBlot;\nconst Block = Quill.import('blots/block') as TypeParchment.BlotConstructor;\nconst BlockEmbed = Quill.import('blots/block/embed') as TypeParchment.BlotConstructor;\n\nexport class ContainerFormat extends Container {\n  static tagName: string;\n  static blotName: string = blotName.container;\n  static scope = Parchment.Scope.BLOCK_BLOT;\n  static allowedChildren?: TypeParchment.BlotConstructor[] = [Block, BlockEmbed, Container];\n  static requiredContainer: TypeParchment.BlotConstructor;\n  static defaultChild?: TypeParchment.BlotConstructor;\n\n  static allowAttrs = new Set<string>([]);\n  static allowDataAttrs = new Set<string>([]);\n  // handle the attribute change when use `setFormatValue`\n  static allowDataAttrsChangeHandler: Record<string, string> = {};\n\n  static create(_value?: unknown) {\n    const node = document.createElement(this.tagName);\n    if (this.className) {\n      node.classList.add(this.className);\n    }\n    return node;\n  }\n\n  setFormatValue(name: string, value?: any) {\n    if (this.statics.allowAttrs.has(name) || this.statics.allowDataAttrs.has(name)) {\n      let attrName = name;\n      if (this.statics.allowDataAttrs.has(name)) {\n        attrName = `data-${name}`;\n      }\n      if (value) {\n        this.domNode.setAttribute(attrName, value);\n      }\n      else {\n        this.domNode.removeAttribute(attrName);\n      }\n      const methodName = this.statics.allowDataAttrsChangeHandler[name] as keyof this;\n      if (methodName && isFunction(this[methodName])) {\n        (this[methodName] as Function)(value);\n      }\n    }\n  }\n\n  public optimize(_context: Record<string, any>) {\n    if (this.children.length === 0) {\n      if (this.statics.defaultChild != null) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n      }\n      else {\n        this.remove();\n      }\n    }\n\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n  }\n\n  public enforceAllowedChildren(): void {\n    // the origin `enforceAllowedChildren` only unwrap the first block\n    // remove flag `done`. all block format in table container need be unwrap\n\n    // eslint-disable-next-line unicorn/no-array-for-each\n    this.children.forEach((child: TypeParchment.Blot) => {\n      const allowed = this.statics.allowedChildren.some(\n        (def: TypeParchment.BlotConstructor) => child instanceof def,\n      );\n      if (allowed) {\n        return;\n      }\n      if (child.statics.scope === Parchment.Scope.BLOCK_BLOT) {\n        // only child is in table format need keep split blot. else use the origin method\n        if (child.parent instanceof ContainerFormat) {\n          if (child.next != null) {\n            child.parent.splitAfter(child);\n          }\n          if (child.prev != null) {\n            child.parent.splitAfter(child.prev);\n          }\n        }\n        else {\n          if (child.next != null) {\n            this.splitAfter(child);\n          }\n          if (child.prev != null) {\n            this.splitAfter(child.prev);\n          }\n        }\n        child.parent.unwrap();\n      }\n      else if (child instanceof Parchment.ParentBlot) {\n        child.unwrap();\n      }\n      else {\n        child.remove();\n      }\n    });\n  }\n}\n","import { isValidCellspan } from '../utils';\n\nexport const getValidCellspan = (value: unknown) => isValidCellspan(value) ? value : 1;\nexport function isSameCellValue(value1: Record<string, any>, value2: Record<string, any>) {\n  return Object.keys(value1).every(key => JSON.stringify(value1[key]) === JSON.stringify(value2[key]));\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type TypeBlock from 'quill/blots/block';\nimport type { BlockEmbed as TypeBlockEmbed } from 'quill/blots/block';\nimport type TypeContainer from 'quill/blots/container';\nimport type { TableCellInnerFormat } from '../table-cell-inner-format';\nimport Quill from 'quill';\nimport { blotName, findParentBlot, isString } from '../../utils';\nimport { isSameCellValue } from '../utils';\n\nconst Parchment = Quill.import('parchment');\nconst Block = Quill.import('blots/block') as typeof TypeBlock;\nconst BlockEmbed = Quill.import('blots/block/embed') as typeof TypeBlockEmbed;\nconst Container = Quill.import('blots/container') as typeof TypeContainer;\n\nexport class BlockOverride extends Block {\n  replaceWith(name: string | TypeParchment.Blot, value?: any): TypeParchment.Blot {\n    const replacement = isString(name) ? this.scroll.create(name, value) : name;\n    if (replacement instanceof Parchment.ParentBlot) {\n      // replace block to TableCellInner length is 0 when setContents\n      // that will set text direct in TableCellInner but not in block\n      // so we need to set text in block and block in TableCellInner\n      // wrap with TableCellInner.formatAt when length is 0 will create a new block\n      // that can make sure TableCellInner struct correctly\n      if (replacement.statics.blotName === blotName.tableCellInner) {\n        // skip if current block already in same TableCellInner\n        let currentTableCellInner: TableCellInnerFormat | null = null;\n        try {\n          currentTableCellInner = findParentBlot(this, blotName.tableCellInner);\n          const cellValue = currentTableCellInner.formats();\n          const replacementValue = (replacement as TableCellInnerFormat).formats();\n          if (isSameCellValue(cellValue, replacementValue)) {\n            return currentTableCellInner;\n          }\n        }\n        catch {}\n\n        if (currentTableCellInner) {\n          // use TableCellInner insertBefore to find the correct position\n          currentTableCellInner.insertBefore(replacement, this);\n          replacement.appendChild(this);\n          if (currentTableCellInner.children.length === 0) {\n            currentTableCellInner.remove();\n          }\n        }\n        else {\n          // find the first parent not container\n          let currentParent = this as TypeParchment.Parent;\n          let lastParent = currentParent;\n          while (currentParent.parent !== this.scroll && currentParent.parent instanceof Container) {\n            lastParent = currentParent;\n            currentParent = currentParent.parent;\n          }\n          // if parent all container until scroll. use the last container\n          if (currentParent === this.scroll) {\n            currentParent = lastParent;\n          }\n          // split current block as a separate \"line\" and wrap tableCellInner\n          const index = this.offset(currentParent);\n          const length = this.length();\n          const selfParent = currentParent.isolate(index, length);\n          if (selfParent?.parent) {\n            selfParent.parent.insertBefore(replacement, selfParent.next);\n          }\n          replacement.appendChild(this);\n        }\n        return replacement;\n      }\n      else {\n        this.moveChildren(replacement);\n      }\n    }\n    if (this.parent !== null) {\n      this.parent.insertBefore(replacement, this.next);\n      this.remove();\n    }\n    this.attributes.copy(replacement as TypeParchment.BlockBlot);\n    return replacement;\n  }\n\n  format(name: string, value: any): void {\n    if (name === blotName.tableCellInner && this.parent.statics.blotName === name && !value) {\n      if (this.prev && this.prev instanceof BlockEmbed) return;\n      try {\n        const cellInner = findParentBlot(this, blotName.tableCellInner);\n        cellInner.unwrap();\n      }\n      catch {\n        console.error('unwrap TableCellInner error');\n      }\n    }\n    else {\n      super.format(name, value);\n    }\n  }\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type { BlockEmbed as TypeBlockEmbed } from 'quill/blots/block';\nimport type { TableCellInnerFormat } from '../table-cell-inner-format';\nimport Quill from 'quill';\nimport { blotName, findParentBlot } from '../../utils';\n\nconst BlockEmbed = Quill.import('blots/block/embed') as typeof TypeBlockEmbed;\n\nexport class BlockEmbedOverride extends BlockEmbed {\n  delta() {\n    // if BlockEmbed is the last line of the tableCellInner. need to add value in delta\n    const delta = super.delta();\n    const formats = bubbleFormats(this);\n    if (formats[blotName.tableCellInner]) {\n      delta.insert('\\n', { [blotName.tableCellInner]: formats[blotName.tableCellInner] });\n    }\n    return delta;\n  }\n\n  length() {\n    const formats = bubbleFormats(this);\n    if (formats[blotName.tableCellInner]) {\n      return super.length() + 1;\n    }\n    return super.length();\n  }\n\n  formatAt(index: number, length: number, name: string, value: unknown) {\n    if (name === blotName.tableCellInner) {\n      try {\n        const currentCellInner = findParentBlot(this, blotName.tableCellInner);\n        const newCellInner = this.scroll.create(blotName.tableCellInner, value) as TableCellInnerFormat;\n        currentCellInner.insertBefore(newCellInner, this);\n        newCellInner.appendChild(this);\n        if (currentCellInner.length() === 0) {\n          currentCellInner.remove();\n        }\n      }\n      catch {}\n    }\n    else {\n      this.format(name, value);\n    }\n  }\n}\n\n// copy from `quill/blots/block`\nfunction bubbleFormats(\n  blot: TypeParchment.Blot | null,\n  formats: Record<string, unknown> = {},\n  filter = true,\n): Record<string, unknown> {\n  if (blot == null) return formats;\n  if ('formats' in blot && typeof blot.formats === 'function') {\n    formats = {\n      ...formats,\n      ...blot.formats(),\n    };\n    if (filter) {\n      // exclude syntax highlighting from deltas and getFormat()\n      delete formats['code-token'];\n    }\n  }\n  if (\n    blot.parent == null\n    || blot.parent.statics.blotName === 'scroll'\n    || blot.parent.statics.scope !== blot.statics.scope\n  ) {\n    return formats;\n  }\n  return bubbleFormats(blot.parent, formats, filter);\n}\n","import type { TableBodyTag } from '../utils';\nimport type { TableRowFormat } from './table-row-format';\nimport { blotName } from '../utils';\nimport { ContainerFormat } from './container-format';\nimport { TableCellInnerFormat } from './table-cell-inner-format';\n\nexport class TableBodyFormat extends ContainerFormat {\n  static blotName: string = blotName.tableBody;\n  static tagName = 'tbody';\n\n  static create(value: string) {\n    const node = super.create() as HTMLElement;\n    node.dataset.tableId = value;\n    return node;\n  }\n\n  get tableId() {\n    return this.domNode.dataset.tableId!;\n  }\n\n  checkMerge(): boolean {\n    const next = this.next as TableBodyFormat;\n    return (\n      next !== null\n      && next.statics.blotName === this.statics.blotName\n      && next.tableId === this.tableId\n    );\n  }\n\n  optimize(context: Record<string, any>) {\n    const parent = this.parent;\n    if (parent !== null && parent.statics.blotName !== blotName.tableMain) {\n      const { tableId } = this;\n      this.wrap(blotName.tableMain, { tableId });\n    }\n\n    super.optimize(context);\n  }\n\n  convertBody(tag: TableBodyTag) {\n    const blots = this.descendants(TableCellInnerFormat);\n    for (const blot of blots) {\n      (blot as any).wrapTag = tag;\n    }\n  }\n\n  getRows() {\n    return Array.from(this.domNode.querySelectorAll('tr'))\n      .map(el => this.scroll.find(el) as TableRowFormat)\n      .filter(Boolean);\n  }\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type TypeBlock from 'quill/blots/block';\nimport type { BlockEmbed as TypeBlockEmbed } from 'quill/blots/block';\nimport type TypeScroll from 'quill/blots/scroll';\nimport type { TableBodyTag, TableCellValue } from '../utils';\nimport type { TableCellFormat } from './table-cell-format';\nimport Quill from 'quill';\nimport { blotName, cssTextToObject, findParentBlot, findParentBlots, toCamelCase } from '../utils';\nimport { ContainerFormat } from './container-format';\nimport { TableBodyFormat } from './table-body-format';\nimport { getValidCellspan, isSameCellValue } from './utils';\n\nconst Block = Quill.import('blots/block') as TypeParchment.BlotConstructor;\nconst BlockEmbed = Quill.import('blots/block/embed') as typeof TypeBlockEmbed;\n\nexport class TableCellInnerFormat extends ContainerFormat {\n  static blotName = blotName.tableCellInner;\n  static tagName = 'div';\n  static className = 'ql-table-cell-inner';\n  static allowDataAttrs: Set<string> = new Set(['table-id', 'row-id', 'col-id', 'rowspan', 'colspan', 'empty-row', 'wrap-tag']);\n  static defaultChild: TypeParchment.BlotConstructor = Block;\n  declare parent: TableCellFormat;\n  // keep `isAllowStyle` and `allowStyle` same with TableCellFormat\n  static allowStyle = new Set(['background-color', 'border', 'height']);\n  static isAllowStyle(str: string): boolean {\n    const cssAttrName = toCamelCase(str);\n    for (const style of this.allowStyle) {\n      // cause `cssTextToObject` will transform css string to camel case style name\n      if (cssAttrName.startsWith(toCamelCase(style))) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static create(value: TableCellValue) {\n    const {\n      tableId,\n      rowId,\n      colId,\n      rowspan,\n      colspan,\n      style,\n      emptyRow,\n      tag = 'td',\n      wrapTag = 'tbody',\n    } = value;\n    const node = super.create() as HTMLElement;\n    node.dataset.tableId = tableId;\n    node.dataset.rowId = rowId;\n    node.dataset.colId = colId;\n    node.dataset.rowspan = String(getValidCellspan(rowspan));\n    node.dataset.colspan = String(getValidCellspan(colspan));\n    node.dataset.tag = tag;\n    node.dataset.wrapTag = wrapTag;\n    style && (node.dataset.style = style);\n    try {\n      emptyRow && (node.dataset.emptyRow = JSON.stringify(emptyRow));\n    }\n    catch {}\n    return node;\n  }\n\n  static formats(domNode: HTMLElement) {\n    const {\n      tableId,\n      rowId,\n      colId,\n      rowspan,\n      colspan,\n      style,\n      emptyRow,\n      tag = 'td',\n      wrapTag = 'tbody',\n    } = domNode.dataset;\n    const value: Record<string, any> = {\n      tableId: String(tableId),\n      rowId: String(rowId),\n      colId: String(colId),\n      rowspan: Number(getValidCellspan(rowspan)),\n      colspan: Number(getValidCellspan(colspan)),\n      tag,\n      wrapTag,\n    };\n\n    style && (value.style = style);\n\n    try {\n      emptyRow && (value.emptyRow = JSON.parse(emptyRow));\n    }\n    catch {}\n\n    return value;\n  }\n\n  constructor(scroll: TypeScroll, domNode: HTMLElement, _value: TableCellValue) {\n    super(scroll, domNode);\n    domNode.setAttribute('contenteditable', String(scroll.isEnabled()));\n  }\n\n  setFormatValue(name: string, value?: any, isStyle: boolean = false) {\n    if (isStyle) {\n      if (!this.statics.isAllowStyle(name)) return;\n    }\n    else {\n      super.setFormatValue(name, value);\n    }\n    if (this.parent && this.parent.statics.blotName === blotName.tableCell) {\n      this.parent.setFormatValue(name, value);\n    }\n\n    this.clearCache();\n  }\n\n  clearCache() {\n    const blocks = this.descendants(Block, 0);\n    for (const child of blocks) {\n      (child as TypeBlock).cache = {};\n    }\n  }\n\n  get tableId() {\n    return this.domNode.dataset.tableId!;\n  }\n\n  get rowId() {\n    return this.domNode.dataset.rowId!;\n  }\n\n  set rowId(value) {\n    this.setFormatValue('row-id', value);\n  }\n\n  get colId() {\n    return this.domNode.dataset.colId!;\n  }\n\n  set colId(value) {\n    this.setFormatValue('col-id', value);\n  }\n\n  get rowspan() {\n    return Number(this.domNode.dataset.rowspan);\n  }\n\n  set rowspan(value: number) {\n    this.setFormatValue('rowspan', value);\n  }\n\n  get colspan() {\n    return Number(this.domNode.dataset.colspan);\n  }\n\n  set colspan(value: number) {\n    this.setFormatValue('colspan', value);\n  }\n\n  get emptyRow(): string[] {\n    try {\n      return JSON.parse(this.domNode.dataset.emptyRow!);\n    }\n    catch {\n      return [];\n    }\n  }\n\n  set emptyRow(value: string[]) {\n    // if value same as currentEmptyRow, do nothing\n    if (this.emptyRow.toString() === value.toString()) return;\n\n    try {\n      if (value.length > 0) {\n        this.setFormatValue('empty-row', JSON.stringify(value), false);\n      }\n      else {\n        this.setFormatValue('empty-row', null, false);\n      }\n    }\n    catch {\n      this.setFormatValue('empty-row', null, false);\n    }\n  }\n\n  set wrapTag(value: TableBodyTag) {\n    this.setFormatValue('wrap-tag', value);\n  }\n\n  get wrapTag() {\n    return this.domNode.dataset.wrapTag as TableBodyTag || 'tbody';\n  }\n\n  getColumnIndex() {\n    const tableBlot = findParentBlot(this, blotName.tableMain);\n    return tableBlot.getColIds().indexOf(this.colId);\n  }\n\n  getRowIndex() {\n    const tableBlot = findParentBlot(this, blotName.tableMain);\n    return tableBlot.getRowIds().indexOf(this.rowId);\n  }\n\n  getTableBody() {\n    let target: TypeParchment.Parent = this.parent;\n    while (target && !(target instanceof TableBodyFormat) && target !== this.scroll) {\n      target = target.parent;\n    }\n    if (target === this.scroll) {\n      return null;\n    }\n    return target as TableBodyFormat;\n  }\n\n  getTableRow() {\n    try {\n      return findParentBlot(this, blotName.tableRow);\n    }\n    catch {\n      return null;\n    }\n  }\n\n  setStyleByString(styleStr: string) {\n    const style = cssTextToObject(styleStr);\n    for (const [name, value] of Object.entries(style)) {\n      this.setFormatValue(name, value, true);\n    }\n  }\n\n  convertTableCell() {\n    if (this.parent.statics.blotName !== blotName.tableCell) return;\n    this.parent.convertTableCell();\n    this.clearCache();\n  }\n\n  formatAt(index: number, length: number, name: string, value: any) {\n    if (this.children.length === 0) {\n      const defaultChild = this.scroll.create(this.statics.defaultChild.blotName);\n      this.appendChild(defaultChild);\n      // block min length is 1\n      length += defaultChild.length();\n    }\n    super.formatAt(index, length, name, value);\n    // set style for `td`\n    if (value?.style) {\n      this.setStyleByString(value.style);\n    }\n  }\n\n  insertAt(index: number, value: string, def?: any): void {\n    const [child] = this.children.find(index);\n    // always keep TableCellInner not empty\n    if (!child && this.statics.defaultChild) {\n      const defaultChild = this.scroll.create(this.statics.defaultChild.blotName || 'block');\n      this.appendChild(defaultChild);\n    }\n    super.insertAt(index, value, def);\n    // BlockEmbed will have a \\n in delta, this will effect history stack\n    // so when insert a BlockEmbed, if current child length <= 1 then remove it\n    const blot = def == null\n      ? this.scroll.create('text', value)\n      : this.scroll.create(value, def);\n    if (blot instanceof BlockEmbed && child && child.length() <= 1) {\n      child.remove();\n    }\n  }\n\n  formats(): Record<string, any> {\n    const value = this.statics.formats(this.domNode);\n    return {\n      [this.statics.blotName]: value,\n    };\n  }\n\n  checkMerge(): boolean {\n    const { colId, rowId, colspan, rowspan } = this;\n    const next = this.next as TableCellInnerFormat;\n    return (\n      next !== null\n      && next.statics.blotName === this.statics.blotName\n      && next.rowId === rowId\n      && next.colId === colId\n      && next.colspan === colspan\n      && next.rowspan === rowspan\n    );\n  }\n\n  optimize() {\n    const parent = this.parent;\n    const blotValue = this.statics.formats(this.domNode);\n    // handle BlockEmbed to insert tableCellInner when setContents\n    if (this.prev && this.prev instanceof BlockEmbed) {\n      const prev = this.prev;\n      this.insertBefore(prev, this.children.head);\n      if (this.length() <= 1) {\n        const afterBlock = this.scroll.create('block');\n        this.insertBefore(afterBlock, prev.next);\n      }\n    }\n    const parentNotTableCell = parent !== null && parent.statics.blotName !== blotName.tableCell;\n    if (parentNotTableCell) {\n      this.wrap(blotName.tableCell, blotValue);\n      // when insert delta like: [ { attributes: { 'table-up-cell-inner': { ... } }, insert: '\\n' }, { attributes: { 'table-up-cell-inner': { ... } }, insert: '\\n' }, ...]\n      // that delta will create dom like: <td><div></div></td>... . that means TableCellInner will be an empty cell without 'block'\n      // in this case, a 'block' should to inserted to makesure that the cell will not be remove\n      if (this.children.length === 0) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n      }\n    }\n\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n    // TODO: uiNode not test, maybe have bug\n    if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n      this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    // this is necessary when redo or undo. else will delete or insert wrong index\n    if (this.children.length === 0) {\n      // if cellInner doesn't have child then remove it. not insert a block\n      this.remove();\n    }\n    else {\n      // update delta data\n      if (\n        this.domNode.dataset.style\n        && parentNotTableCell\n        && parent.domNode.style.cssText !== this.domNode.dataset.style\n      ) {\n        this.setStyleByString(this.domNode.dataset.style);\n      }\n    }\n  }\n\n  insertBefore(blot: TypeParchment.Blot, ref?: TypeParchment.Blot | null) {\n    if (blot.statics.blotName === this.statics.blotName) {\n      const cellInnerBlot = blot as TableCellInnerFormat;\n      const cellInnerBlotValue = this.statics.formats(cellInnerBlot.domNode);\n      const selfValue = this.statics.formats(this.domNode);\n      const isSame = isSameCellValue(selfValue, cellInnerBlotValue);\n\n      if (!isSame) {\n        const [selfRow, selfCell] = findParentBlots(this, [blotName.tableRow, blotName.tableCell] as const);\n        let cellRef: TypeParchment.Blot = selfCell;\n        // split current cellInner\n        if (ref) {\n          const index = ref.offset();\n          const length = this.length();\n          if (index !== 0 && index < length) {\n            const newCellInner = this.split(index)!;\n            const newCell = newCellInner.wrap(blotName.tableCell, selfValue);\n            selfRow.insertBefore(newCell, selfCell.next);\n            cellRef = newCell;\n          }\n        }\n        if (this.tableId !== cellInnerBlot.tableId) {\n          const selfTableWrapper = findParentBlot(this, blotName.tableWrapper);\n          const index = this.offset(selfTableWrapper);\n          const afterSelfTableWrapper = selfTableWrapper.split(index);\n          return selfTableWrapper.parent.insertBefore(cellInnerBlot, afterSelfTableWrapper);\n        }\n        // different rowId. split current row\n        if (this.rowId !== cellInnerBlot.rowId) {\n          let rowRef: TypeParchment.Blot | null = selfRow;\n          const splitRef = ref;\n          if (splitRef) {\n            const index = splitRef.offset(selfRow);\n            rowRef = selfRow.split(index);\n          }\n          const row = this.scroll.create(blotName.tableRow, cellInnerBlotValue) as TypeParchment.Parent;\n          const cell = this.scroll.create(blotName.tableCell, cellInnerBlotValue) as TypeParchment.Parent;\n          cell.appendChild(cellInnerBlot);\n          row.appendChild(cell);\n          return selfRow.parent.insertBefore(row, rowRef);\n        }\n        return selfRow.insertBefore(\n          cellInnerBlot.wrap(blotName.tableCell, cellInnerBlotValue),\n          cellRef,\n        );\n      }\n      else {\n        const next = this.split(ref ? ref.offset() : 0);\n        return this.parent.insertBefore(cellInnerBlot, next);\n      }\n    }\n    else if (blot.statics.blotName === blotName.tableCol) {\n      try {\n        const bodyBlot = findParentBlot(this, blotName.tableBody);\n        const index = this.offset(bodyBlot);\n        const next = bodyBlot.split(index);\n        bodyBlot.parent.insertBefore(blot, next);\n        blot.optimize({});\n      }\n      catch {\n        // here should not trigger\n        console.warn('TableCellInner not in TableBody');\n      }\n      return;\n    }\n    super.insertBefore(blot, ref);\n  }\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type { TableCaptionFormat } from '../table-caption-format';\nimport Quill from 'quill';\nimport { blotName } from '../../utils';\nimport { TableCellInnerFormat } from '../table-cell-inner-format';\n\nconst Parchment = Quill.import('parchment');\n// createBlock is private. can't use type `Scroll`\nconst ScrollBlot = Quill.import('blots/scroll') as any;\n\nexport class ScrollOverride extends ScrollBlot {\n  declare domNode: HTMLElement;\n  enable(enabled = true) {\n    // `TableWrapper` is not editable. Beacuse we don't want the cursor to be at the end or beginning of the same line as the table\n    // This hack is to make the table cell should not editable when quill is diabled\n    const tableCellInnerFormat = Quill.import(`formats/${blotName.tableCellInner}`) as typeof TableCellInnerFormat;\n    const inners = this.domNode.querySelectorAll(`.${tableCellInnerFormat.className}`);\n    for (const inner of Array.from(inners)) {\n      inner.setAttribute('contenteditable', String(!!enabled));\n    }\n    const tableCaptionFormat = Quill.import(`formats/${blotName.tableCaption}`) as typeof TableCaptionFormat;\n    const tableCaption = this.domNode.querySelectorAll(`.${tableCaptionFormat.className}`);\n    for (const caption of Array.from(tableCaption)) {\n      caption.setAttribute('contenteditable', String(!!enabled));\n    }\n    super.enable(enabled);\n  }\n\n  createBlock(attributes: Record<string, any>, refBlot?: TypeParchment.Blot) {\n    let createBlotName: string | undefined;\n    let formats: Record<string, any> = {};\n    if (attributes[blotName.tableCellInner]) {\n      createBlotName = blotName.tableCellInner;\n    }\n    else {\n      // if attributes have not only one block blot. will save last. that will conflict with list/header in tableCellInner\n      for (const [key, value] of Object.entries(attributes)) {\n        const isBlockBlot = this.query(key, Parchment.Scope.BLOCK & Parchment.Scope.BLOT) != null;\n        if (isBlockBlot) {\n          createBlotName = key;\n        }\n        else {\n          formats[key] = value;\n        }\n      }\n    }\n    // only add this judgement to merge block blot at table cell\n    if (createBlotName === blotName.tableCellInner) {\n      formats = { ...attributes };\n      delete formats[createBlotName];\n    }\n\n    const block = this.create(\n      createBlotName || this.statics.defaultChild.blotName,\n      createBlotName ? attributes[createBlotName] : undefined,\n    ) as TypeParchment.ParentBlot;\n\n    this.insertBefore(block, refBlot || undefined);\n\n    let length = block.length();\n    if (block instanceof TableCellInnerFormat && length === 0) {\n      length += 1;\n    }\n    for (const [key, value] of Object.entries(formats)) {\n      block.formatAt(0, length, key, value);\n    }\n\n    return block;\n  }\n}\n","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <!-- Icon from Tabler Icons by Pawe Kuna - https://github.com/tabler/tabler-icons/blob/master/LICENSE -->\\n  <path\\n    fill=\\\"none\\\"\\n    stroke=\\\"currentColor\\\"\\n    stroke-linecap=\\\"round\\\"\\n    stroke-linejoin=\\\"round\\\"\\n    stroke-width=\\\"2\\\"\\n    d=\\\"M7 3v18m3-15L7 3L4 6m16 12l-3 3l-3-3m3 3V3\\\"\\n  />\\n</svg>\\n\"","import type { Parchment as TypeParchment } from 'quill';\nimport type TypeInline from 'quill/blots/inline';\nimport type TypeScroll from 'quill/blots/scroll';\nimport type TypeText from 'quill/blots/text';\nimport type { TableCaptionValue } from '../utils';\nimport Quill from 'quill';\nimport ArrowUpDown from '../svg/arrow-up-down.svg';\nimport { blotName } from '../utils';\nimport { BlockOverride } from './overrides';\n\nconst Parchment = Quill.import('parchment');\nconst Inline = Quill.import('blots/inline') as typeof TypeInline;\nconst Text = Quill.import('blots/text') as typeof TypeText;\n\nexport class TableCaptionFormat extends BlockOverride {\n  static blotName = blotName.tableCaption;\n  static tagName = 'caption';\n  static className = 'ql-table-caption';\n  static allowedChildren = [Inline, Text];\n\n  static create(value: TableCaptionValue) {\n    const { tableId } = value;\n    const node = super.create() as HTMLElement;\n    node.dataset.tableId = tableId;\n    if (value.side === 'bottom') {\n      node.style.captionSide = 'bottom';\n    }\n    return node;\n  }\n\n  static formats(domNode: HTMLElement) {\n    const { tableId } = domNode.dataset;\n    const value: TableCaptionValue = {\n      tableId: String(tableId),\n      side: domNode.style.captionSide === 'bottom' ? 'bottom' : 'top',\n    };\n    return value;\n  }\n\n  declare scroll: TypeScroll;\n  declare uiNode: HTMLElement;\n  constructor(scroll: TypeScroll, domNode: HTMLElement, _value: TableCaptionValue) {\n    super(scroll, domNode);\n    domNode.setAttribute('contenteditable', String(scroll.isEnabled()));\n\n    this.attachUI(this.createUI());\n    this.domNode.addEventListener('mouseenter', () => {\n      if (!this.scroll.isEnabled()) return;\n      this.uiNode.style.display = 'flex';\n    });\n    this.domNode.addEventListener('mouseleave', () => {\n      if (!this.scroll.isEnabled()) return;\n      this.uiNode.style.display = 'none';\n    });\n    this.uiNode.style.display = 'none';\n  }\n\n  createUI(): HTMLElement {\n    const node = document.createElement('i');\n    node.classList.add('ql-table-caption--switch');\n    node.innerHTML = ArrowUpDown;\n    node.addEventListener('click', () => {\n      if (!this.scroll.isEnabled()) return;\n      this.side = this.side === 'top' ? 'bottom' : 'top';\n    });\n    return node;\n  }\n\n  get tableId() {\n    return this.domNode.dataset.tableId!;\n  }\n\n  set side(value: TableCaptionValue['side']) {\n    this.domNode.style.captionSide = value === 'bottom' ? 'bottom' : 'top';\n  }\n\n  get side() {\n    return this.domNode.style.captionSide === 'bottom' ? 'bottom' : 'top';\n  }\n\n  format(name: string, value: any): void {\n    const isBlock = this.scroll.query(name, Parchment.Scope.BLOCK_BLOT);\n    if (!isBlock || name === this.statics.blotName) {\n      super.format(name, value);\n    }\n  }\n\n  checkMerge(): boolean {\n    const next = this.next as TableCaptionFormat;\n\n    return (\n      next !== null\n      && next.statics.blotName === this.statics.blotName\n      && next.tableId === this.tableId\n    );\n  }\n\n  optimize(context: Record<string, any>) {\n    const parent = this.parent;\n    if (parent !== null && parent.statics.blotName !== blotName.tableMain) {\n      const { tableId } = this;\n      this.wrap(blotName.tableMain, { tableId });\n    }\n\n    if (this.children.length === 0) {\n      this.remove();\n    }\n    else {\n      super.optimize(context);\n      if (this.next != null && this.checkMerge()) {\n        (this.next as TypeParchment.ParentBlot).moveChildren(this);\n        this.next.remove();\n      }\n    }\n  }\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type { TableBodyTag, TableCellValue, TableRowValue } from '../utils';\nimport type { TableCellFormat } from './table-cell-format';\nimport { blotName, findParentBlot } from '../utils';\nimport { ContainerFormat } from './container-format';\nimport { TableCellInnerFormat } from './table-cell-inner-format';\n\nexport type SkipRowCount = number[] & { skipRowNum?: number };\nexport class TableRowFormat extends ContainerFormat {\n  static blotName = blotName.tableRow;\n  static tagName = 'tr';\n  static className = 'ql-table-row';\n  static allowDataAttrs = new Set(['table-id', 'row-id', 'wrap-tag']);\n  static allowDataAttrsChangeHandler: Record<string, keyof TableRowFormat> = {\n    'wrap-tag': 'wrapParentTag',\n  };\n\n  static create(value: TableRowValue) {\n    const {\n      tableId,\n      rowId,\n      wrapTag = 'tbody',\n    } = value;\n    const node = super.create() as HTMLElement;\n    node.dataset.tableId = tableId;\n    node.dataset.rowId = rowId;\n    node.dataset.wrapTag = wrapTag;\n    return node;\n  }\n\n  declare children: TypeParchment.LinkedList<TableCellFormat>;\n\n  get rowId() {\n    return this.domNode.dataset.rowId!;\n  }\n\n  get tableId() {\n    return this.domNode.dataset.tableId!;\n  }\n\n  get wrapTag() {\n    return this.domNode.dataset.wrapTag as TableBodyTag || 'tbody';\n  }\n\n  setHeight(value: string) {\n    this.foreachCellInner((cellInner) => {\n      cellInner.setFormatValue('height', value, true);\n    });\n  }\n\n  getCellByColId(colId: string, direction: 'next' | 'prev'): TableCellFormat | null {\n    const tableMain = findParentBlot(this, blotName.tableMain);\n    const colIds = tableMain.getColIds();\n    const targetIndex = colIds.indexOf(colId);\n    const next = this.children.iterator();\n    let cur: null | TableCellFormat = null;\n    while ((cur = next())) {\n      if (cur.colId === colId) {\n        return cur;\n      }\n      const curIndex = colIds.indexOf(cur.colId);\n      if (curIndex < targetIndex && curIndex + cur.colspan > targetIndex) {\n        return cur;\n      }\n    }\n    // Not found in current row. Means cell is rowspan. Find in prev or next row.\n    if (this[direction] && this[direction]!.statics.blotName === blotName.tableRow) {\n      return (this[direction] as TableRowFormat).getCellByColId(colId, direction);\n    }\n    return null;\n  }\n\n  // insert cell at index\n  // return the minus skip column number\n  // [2, 3]. means next line should skip 2 columns. next next line skip 3 columns\n  insertCell(targetIndex: number, value: TableCellValue) {\n    const skip: SkipRowCount = [];\n    const next = this.children.iterator();\n    let index = 0;\n    let cur;\n    while ((cur = next())) {\n      index += cur.colspan;\n      if (index > targetIndex) break;\n      if (cur.rowspan !== 1) {\n        for (let i = 0; i < cur.rowspan - 1; i++) {\n          skip[i] = (skip[i] || 0) + cur.colspan;\n        }\n      }\n    }\n\n    if (cur && index - cur.colspan < targetIndex) {\n      const tableCell = cur.getCellInner();\n      tableCell.colspan += 1;\n      if (cur.rowspan !== 1) {\n        skip.skipRowNum = cur.rowspan - 1;\n      }\n    }\n    else {\n      const tableCell = this.scroll.create(blotName.tableCell, value) as ContainerFormat;\n      const tableCellInner = this.scroll.create(blotName.tableCellInner, value) as ContainerFormat;\n      const block = this.scroll.create('block') as TypeParchment.BlockBlot;\n      block.appendChild(this.scroll.create('break'));\n      tableCellInner.appendChild(block);\n      tableCell.appendChild(tableCellInner);\n      this.insertBefore(tableCell, cur);\n    }\n    return skip;\n  }\n\n  getCellByColumIndex(stopIndex: number): [null | TableCellFormat, number, number[]] {\n    const skip: number[] = [];\n    let cur: null | TableCellFormat = null;\n    let cellEndIndex = 0;\n    if (stopIndex < 0) return [cur, cellEndIndex, skip];\n    const next = this.children.iterator();\n    while ((cur = next())) {\n      cellEndIndex += cur.colspan;\n      if (cur.rowspan !== 1) {\n        for (let i = 0; i < cur.rowspan - 1; i++) {\n          skip[i] = (skip[i] || 0) + cur.colspan;\n        }\n      }\n      if (cellEndIndex > stopIndex) break;\n    }\n    return [cur, cellEndIndex, skip];\n  }\n\n  removeCell(targetIndex: number): SkipRowCount {\n    if (targetIndex < 0) return [];\n    const columnIndexData = this.getCellByColumIndex(targetIndex);\n    const [cur, index] = columnIndexData;\n    const skip: SkipRowCount = columnIndexData[2];\n    if (!cur) return skip;\n    if (index - cur.colspan < targetIndex || cur.colspan > 1) {\n      const [tableCell] = cur.descendants(TableCellInnerFormat);\n\n      if (cur.colspan !== 1 && targetIndex === index - cur.colspan) {\n        // if delete index is cell start index. update cell colId to next colId\n        const tableBlot = findParentBlot(this, blotName.tableMain);\n        const colIds = tableBlot.getColIds();\n        tableCell.colId = colIds[colIds.indexOf(tableCell.colId) + 1];\n      }\n      if (cur.rowspan !== 1) {\n        skip.skipRowNum = cur.rowspan - 1;\n      }\n\n      tableCell.colspan -= 1;\n    }\n    else {\n      cur.remove();\n    }\n    return skip;\n  }\n\n  foreachCellInner(func: (tableCell: TableCellInnerFormat, index: number) => boolean | void) {\n    const next = this.children.iterator();\n    let i = 0;\n    let cur: TableCellFormat | null;\n    while ((cur = next())) {\n      const [tableCell] = cur.descendants(TableCellInnerFormat);\n      if (tableCell && func(tableCell, i++)) break;\n    }\n  }\n\n  checkMerge(): boolean {\n    const next = this.next as TableRowFormat;\n    return (\n      next !== null\n      && next.statics.blotName === this.statics.blotName\n      && next.rowId === this.rowId\n    );\n  }\n\n  wrapParentTag() {\n    const tableBodyBlotNameMap: Record<string, string> = {\n      thead: blotName.tableHead,\n      tbody: blotName.tableBody,\n      tfoot: blotName.tableFoot,\n    };\n\n    const parent = this.parent;\n    if (parent !== null && parent.statics.blotName !== tableBodyBlotNameMap[this.wrapTag]) {\n      if (Object.values(tableBodyBlotNameMap).includes(parent.statics.blotName)) {\n        const index = this.offset(this.parent);\n        const newParent = this.parent.split(index);\n        if (newParent && newParent.length() <= 0) {\n          newParent.remove();\n        }\n        const afterParent = (this.parent as TypeParchment.ParentBlot).splitAfter(this);\n        if (afterParent && afterParent.length() <= 0) {\n          afterParent.remove();\n        }\n        this.parent.replaceWith(tableBodyBlotNameMap[this.wrapTag], this.tableId);\n      }\n      else {\n        this.wrap(tableBodyBlotNameMap[this.wrapTag], this.tableId);\n      }\n    }\n  }\n\n  optimize(_context: Record<string, any>) {\n    this.wrapParentTag();\n\n    this.enforceAllowedChildren();\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n  }\n\n  remove() {\n    super.remove();\n    // remove next empty row\n    if (this.next && this.next instanceof TableRowFormat && this.next.length() <= 0) {\n      this.next.remove();\n    }\n  }\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type { TableBodyTag, TableCellValue } from '../utils';\nimport { blotName, ensureArray, findParentBlot, getInlineStyles, toCamelCase } from '../utils';\nimport { ContainerFormat } from './container-format';\nimport { TableBodyFormat } from './table-body-format';\nimport { TableCellInnerFormat } from './table-cell-inner-format';\nimport { TableRowFormat } from './table-row-format';\nimport { getValidCellspan } from './utils';\n\nexport class TableCellFormat extends ContainerFormat {\n  static blotName = blotName.tableCell;\n  static tagName = 'td';\n  static className = 'ql-table-cell';\n  static allowAttrs = new Set(['rowspan', 'colspan']);\n  static allowDataAttrs = new Set(['table-id', 'row-id', 'col-id', 'empty-row', 'wrap-tag']);\n\n  // keep `isAllowStyle` and `allowStyle` same with TableCellInnerFormat\n  static allowStyle = new Set(['background-color', 'border', 'height']);\n  static isAllowStyle(str: string): boolean {\n    const cssAttrName = toCamelCase(str);\n    for (const style of this.allowStyle) {\n      // cause `cssTextToObject` will transform css string to camel case style name\n      if (cssAttrName.startsWith(toCamelCase(style))) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static create(value: TableCellValue) {\n    const {\n      tableId,\n      rowId,\n      colId,\n      rowspan,\n      colspan,\n      style,\n      emptyRow,\n      tag = 'td',\n      wrapTag = 'tbody',\n    } = value;\n    const node = document.createElement(tag);\n    node.classList.add(...ensureArray(this.className));\n    node.dataset.tableId = tableId;\n    node.dataset.rowId = rowId;\n    node.dataset.colId = colId;\n    node.dataset.wrapTag = wrapTag;\n    node.setAttribute('rowspan', String(getValidCellspan(rowspan)));\n    node.setAttribute('colspan', String(getValidCellspan(colspan)));\n    style && (node.style.cssText = style);\n    try {\n      emptyRow && (node.dataset.emptyRow = JSON.stringify(emptyRow));\n    }\n    catch {}\n    return node;\n  }\n\n  static formats(domNode: HTMLElement) {\n    const { tableId, rowId, colId, emptyRow, wrapTag = 'tbody' } = domNode.dataset;\n    const rowspan = Number(domNode.getAttribute('rowspan'));\n    const colspan = Number(domNode.getAttribute('colspan'));\n    const value: Record<string, any> = {\n      tableId,\n      rowId,\n      colId,\n      rowspan: getValidCellspan(rowspan),\n      colspan: getValidCellspan(colspan),\n      tag: domNode.tagName.toLowerCase(),\n      wrapTag,\n    };\n\n    const inlineStyles = getInlineStyles(domNode);\n    const entries = Object.entries(inlineStyles).filter(([, value]) => {\n      return !['initial', 'inherit'].includes(value);\n    });\n    if (entries.length > 0) {\n      value.style = entries.map(([key, value]) => `${key}: ${value}`).join(';');\n    }\n\n    try {\n      emptyRow && (value.emptyRow = JSON.parse(emptyRow));\n    }\n    catch {}\n\n    return value;\n  }\n\n  isChildHeadTableCellInner() {\n    const headChild = this.children.head;\n    return headChild && headChild.statics.blotName === blotName.tableCellInner;\n  }\n\n  setFormatValue(name: string, value?: any) {\n    if (this.statics.allowAttrs.has(name) || this.statics.allowDataAttrs.has(name)) {\n      let attrName = name;\n      if (this.statics.allowDataAttrs.has(name)) {\n        attrName = `data-${name}`;\n      }\n      if (value) {\n        this.domNode.setAttribute(attrName, value);\n      }\n      else {\n        this.domNode.removeAttribute(attrName);\n      }\n    }\n    else if (this.statics.isAllowStyle(name)) {\n      Object.assign(this.domNode.style, {\n        [name]: value,\n      });\n      if (name.startsWith('border')) {\n        this.setStyleBoder(name, value);\n      }\n    }\n\n    const headChild = this.children.head!;\n    if (\n      this.isChildHeadTableCellInner()\n      && this.domNode.style.cssText\n      // only update if data not match. avoid optimize circular updates\n      && this.domNode.style.cssText !== (headChild.domNode as HTMLElement).dataset.style\n    ) {\n      (headChild.domNode as HTMLElement).dataset.style = this.domNode.style.cssText;\n    }\n\n    if (this.parent && this.parent.statics.blotName === blotName.tableRow) {\n      (this.parent as TableRowFormat).setFormatValue(name, value);\n    }\n  }\n\n  setStyleBoder(name: string, value?: any) {\n    // eslint-disable-next-line no-extra-boolean-cast\n    const setValue = Boolean(value) ? value : null;\n    const isMergeBorder = !['left', 'right', 'top', 'bottom'].some(direction => name.includes(direction)) && name.startsWith('border-');\n    if (!isMergeBorder) return;\n\n    const leftCellInners = this.getNearByCell('left').map(td => td.descendant(TableCellInnerFormat, 0)[0]).filter(Boolean) as TableCellInnerFormat[];\n    for (const cell of leftCellInners) {\n      cell.setFormatValue(name.replace('border-', 'border-right-'), setValue, true);\n    }\n    const topCellInners = this.getNearByCell('top').map(td => td.descendant(TableCellInnerFormat, 0)[0]).filter(Boolean) as TableCellInnerFormat[];\n    for (const cell of topCellInners) {\n      cell.setFormatValue(name.replace('border-', 'border-bottom-'), setValue, true);\n    }\n  }\n\n  getNearByCell(direction: 'left' | 'top'): TableCellFormat[] {\n    const colIds: string[] = [];\n    try {\n      const tableMain = findParentBlot(this, blotName.tableMain);\n      colIds.push(...tableMain.getColIds());\n    }\n    catch (error) {\n      console.error(`Cell is not in table! ${error}`);\n    }\n    if (colIds.length === 0) return [];\n\n    if (direction === 'left') {\n      const nearByCell = new Set<TableCellFormat>();\n      let row = this.parent;\n      for (let i = 0; i < this.rowspan; i++) {\n        if (!(row instanceof TableRowFormat)) break;\n        const next = row.children.iterator();\n        let cur: null | TableCellFormat = null;\n        while ((cur = next())) {\n          const i = colIds.indexOf(cur.colId) + cur.colspan;\n          if (this.colId === colIds[i]) {\n            nearByCell.add(cur);\n          }\n        }\n        row = row.next as TableRowFormat;\n      }\n      return Array.from(nearByCell);\n    }\n    else if (direction === 'top') {\n      if (!(this.parent instanceof TableRowFormat) || !this.parent.prev) return [];\n      const nearByCell = new Set<TableCellFormat>();\n\n      const startColIndex = this.getColumnIndex();\n      const endColIndex = startColIndex + this.colspan;\n      const borderColIds = new Set(colIds.filter((_, i) => i >= startColIndex && i < endColIndex));\n\n      let rowspan = 1;\n      let row = this.parent.prev as TableRowFormat;\n      while (row) {\n        let trReachCurrent = false;\n        const next = row.children.iterator();\n        let cur: null | TableCellFormat = null;\n        let colspan = 0;\n        while ((cur = next())) {\n          if (borderColIds.has(cur.colId) && cur.rowspan >= rowspan) {\n            nearByCell.add(cur);\n            borderColIds.delete(cur.colId);\n          }\n          colspan += cur.colspan;\n          cur.rowspan >= rowspan && (trReachCurrent = true);\n        }\n        if (!trReachCurrent && colspan === colIds.length) break;\n        row = row.prev as TableRowFormat;\n        rowspan += 1;\n      }\n      return Array.from(nearByCell);\n    }\n    return [];\n  }\n\n  get tableId() {\n    return this.domNode.dataset.tableId!;\n  }\n\n  get rowId() {\n    return this.domNode.dataset.rowId!;\n  }\n\n  get colId() {\n    return this.domNode.dataset.colId!;\n  }\n\n  get rowspan() {\n    return Number(this.domNode.getAttribute('rowspan'));\n  }\n\n  get colspan() {\n    return Number(this.domNode.getAttribute('colspan'));\n  }\n\n  get emptyRow(): string[] {\n    try {\n      return JSON.parse(this.domNode.dataset.emptyRow!);\n    }\n    catch {\n      return [];\n    }\n  }\n\n  get wrapTag() {\n    return this.domNode.dataset.wrapTag as TableBodyTag || 'tbody';\n  }\n\n  getColumnIndex() {\n    const table = findParentBlot(this, blotName.tableMain);\n    return table.getColIds().indexOf(this.colId);\n  }\n\n  getCellInner() {\n    return this.children.head as TableCellInnerFormat;\n  }\n\n  convertTableCell() {\n    const value = this.statics.formats(this.domNode);\n    const tag = value.tag === 'td' ? 'th' : 'td';\n\n    const headChild = this.children.head!;\n    if (\n      this.isChildHeadTableCellInner()\n      // only update if data not match. avoid optimize circular updates\n      && (headChild.domNode as HTMLElement).dataset.tag !== tag\n    ) {\n      (headChild.domNode as HTMLElement).dataset.tag = tag;\n    }\n\n    this.replaceWith(blotName.tableCell, {\n      ...value,\n      tag,\n    });\n  }\n\n  checkMerge(): boolean {\n    const { colId, rowId, colspan, rowspan } = this;\n    const next = this.next as TableCellFormat;\n    return (\n      next !== null\n      && next.statics.blotName === this.statics.blotName\n      && next.rowId === rowId\n      && next.colId === colId\n      && next.colspan === colspan\n      && next.rowspan === rowspan\n    );\n  }\n\n  optimize(context: Record<string, any>) {\n    const { tableId, rowId, wrapTag } = this;\n    if (this.parent !== null && this.parent.statics.blotName !== blotName.tableRow) {\n      this.wrap(blotName.tableRow, { tableId, rowId, wrapTag });\n    }\n    // when `replaceWith` called to replace cell. wrapTag may change. so row wrapTag also need to update\n    if (this.parent.statics.blotName === blotName.tableRow && (this.parent as TableRowFormat).wrapTag !== wrapTag) {\n      (this.parent as TableRowFormat).setFormatValue('wrap-tag', wrapTag);\n    }\n\n    if (this.emptyRow.length > 0) {\n      const tableBody = this.parent.parent;\n      if (tableBody instanceof TableBodyFormat) {\n        let insertBefore: TypeParchment.Blot | null = this.parent.next;\n        for (const rowId of this.emptyRow) {\n          const row = this.scroll.create(blotName.tableRow, { tableId, rowId, wrapTag }) as TableRowFormat;\n          tableBody.insertBefore(row, insertBefore);\n          insertBefore = row.next;\n        }\n      }\n    }\n\n    super.optimize(context);\n  }\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type { BlockEmbed as TypeBlockEmbed } from 'quill/blots/block';\nimport type { TableColValue } from '../utils';\nimport Quill from 'quill';\nimport { blotName, findParentBlot, tableUpSize } from '../utils';\n\nconst BlockEmbed = Quill.import('blots/block/embed') as typeof TypeBlockEmbed;\n\nexport class TableColFormat extends BlockEmbed {\n  static blotName = blotName.tableCol;\n  static tagName = 'col';\n\n  static validWidth(width: string | number, full: boolean) {\n    let widthNumber = Number.parseFloat(String(width));\n    if (Number.isNaN(widthNumber)) {\n      widthNumber = tableUpSize[full ? 'colMinWidthPre' : 'colMinWidthPx'];\n    }\n    return `${widthNumber}${full ? '%' : 'px'}`;\n  }\n\n  static create(value: TableColValue) {\n    const { width, tableId, colId, full, align } = value;\n    const node = super.create() as HTMLElement;\n    node.setAttribute('width', this.validWidth(width, !!full));\n    full && (node.dataset.full = String(full));\n    if (align && align !== 'left') {\n      node.dataset.align = align;\n    }\n    node.dataset.tableId = tableId;\n    node.dataset.colId = colId;\n    return node;\n  }\n\n  static value(domNode: HTMLElement) {\n    const { tableId, colId } = domNode.dataset;\n    const width = domNode.getAttribute('width') || String(tableUpSize.colDefaultWidth);\n    const align = domNode.dataset.align;\n    const full = Object.hasOwn(domNode.dataset, 'full');\n    const value: Record<string, any> = {\n      tableId: String(tableId),\n      colId: String(colId),\n      full,\n      width: Number.parseFloat(width),\n    };\n    align && (value.align = align);\n    return value;\n  }\n\n  get width(): number {\n    let width: number | string | null = this.domNode.getAttribute('width');\n    if (!width) {\n      width = this.domNode.getBoundingClientRect().width;\n      if (this.full) {\n        const table = this.domNode.closest('table');\n        if (!table) return tableUpSize[this.full ? 'colMinWidthPre' : 'colMinWidthPx'];\n        return width / 100 * table.getBoundingClientRect().width;\n      }\n      return width;\n    }\n    return Number.parseFloat(String(width));\n  }\n\n  set width(value: string | number) {\n    let width = Number.parseFloat(String(value));\n    if (Number.isNaN(width)) {\n      width = tableUpSize[this.full ? 'colMinWidthPre' : 'colMinWidthPx'];\n    }\n    this.domNode.setAttribute('width', this.statics.validWidth(width, !!this.full));\n  }\n\n  get tableId() {\n    return this.domNode.dataset.tableId!;\n  }\n\n  get colId() {\n    return this.domNode.dataset.colId!;\n  }\n\n  get full() {\n    return Object.hasOwn(this.domNode.dataset, 'full');\n  }\n\n  set full(value: boolean) {\n    if (value) {\n      this.domNode.dataset.full = String(true);\n    }\n    else {\n      this.domNode.removeAttribute('data-full');\n    }\n  }\n\n  get align() {\n    return this.domNode.dataset.align || '';\n  }\n\n  set align(value: string) {\n    if (value === 'right' || value === 'center') {\n      this.domNode.dataset.align = value;\n    }\n    else {\n      this.domNode.removeAttribute('data-align');\n    }\n  }\n\n  checkMerge(): boolean {\n    const next = this.next as TableColFormat;\n    const { tableId, colId } = this;\n    return (\n      next !== null\n      && next.statics.blotName === this.statics.blotName\n      && next.tableId === tableId\n      && next.colId === colId\n    );\n  }\n\n  optimize(context: Record<string, any>) {\n    const parent = this.parent;\n    if (parent != null && parent.statics.blotName !== blotName.tableColgroup) {\n      const value = this.statics.value(this.domNode);\n      this.wrap(blotName.tableColgroup, value);\n    }\n\n    const tableColgroup = findParentBlot(this, blotName.tableColgroup);\n    tableColgroup.align = this.align;\n\n    if (this.next != null && this.checkMerge()) {\n      this.next.remove();\n    }\n\n    super.optimize(context);\n\n    try {\n      const tableColgroup = findParentBlot(this, blotName.tableColgroup);\n      let isAllFull = true;\n      // eslint-disable-next-line unicorn/no-array-for-each\n      tableColgroup.children.forEach((col) => {\n        isAllFull &&= col.full;\n      });\n      tableColgroup.full = isAllFull;\n    }\n    catch {}\n  }\n\n  insertAt(index: number, value: string, def?: any): void {\n    if (def != null) {\n      if (value === this.statics.blotName && def.tableId !== this.tableId) {\n        try {\n          const tableWrapperBlot = findParentBlot(this, blotName.tableWrapper);\n          const parentBlot = tableWrapperBlot.split(this.offset(tableWrapperBlot)) as TypeParchment.Parent;\n\n          const blot = this.scroll.create(value, def);\n          parentBlot.parent.insertBefore(blot, parentBlot);\n        }\n        catch {\n          // here should not trigger\n          console.warn('TableCol not in TableColgroup');\n        }\n      }\n      else {\n        super.insertAt(index, value, def);\n      }\n      return;\n    }\n    try {\n      const tableWrapperBlot = findParentBlot(this, blotName.tableWrapper);\n      const parentBlot = tableWrapperBlot.split(this.offset(tableWrapperBlot)) as TypeParchment.Parent;\n\n      const lines = value.split('\\n');\n      const text = lines.pop();\n      const blocks = lines.map((line) => {\n        const block = this.scroll.create('block') as TypeParchment.ParentBlot;\n        block.insertAt(0, line);\n        return block;\n      });\n      for (const block of blocks) {\n        parentBlot.parent.insertBefore(block, parentBlot);\n      }\n      if (text) {\n        parentBlot.parent.insertBefore(this.scroll.create('text', text), parentBlot);\n      }\n    }\n    catch {\n      // here should not trigger\n      console.warn('TableCol not in TableColgroup');\n    }\n  }\n}\n","import type TypeScroll from 'quill/blots/scroll';\nimport type { TableValue } from '../utils';\nimport type { TableBodyFormat } from './table-body-format';\nimport { blotName, randomId, tableUpSize } from '../utils';\nimport { ContainerFormat } from './container-format';\nimport { TableCellInnerFormat } from './table-cell-inner-format';\nimport { TableColFormat } from './table-col-format';\nimport { TableRowFormat } from './table-row-format';\n\nexport class TableMainFormat extends ContainerFormat {\n  static blotName = blotName.tableMain;\n  static tagName = 'table';\n  static className = 'ql-table';\n\n  static create(value: TableValue) {\n    const node = super.create() as HTMLElement;\n    const { tableId, full, align } = value;\n    node.dataset.tableId = tableId;\n    if (align === 'right' || align === 'center') {\n      node.dataset.align = align;\n    }\n    else {\n      node.removeAttribute('date-align');\n    }\n    full && (node.dataset.full = String(full));\n    node.setAttribute('cellpadding', '0');\n    node.setAttribute('cellspacing', '0');\n    return node;\n  }\n\n  constructor(public scroll: TypeScroll, domNode: HTMLElement, _value: unknown) {\n    super(scroll, domNode);\n    this.updateAlign();\n  }\n\n  colWidthFillTable() {\n    if (this.full) {\n      Object.assign(this.domNode.style, { width: null });\n      return;\n    }\n    const cols = this.getCols();\n    if (!cols) return;\n    const colsWidth = cols.reduce((sum, col) => col.width + sum, 0);\n    if (colsWidth === 0 || Number.isNaN(colsWidth)) return;\n    this.domNode.style.width = `${colsWidth}px`;\n    return colsWidth;\n  }\n\n  get tableId() {\n    return this.domNode.dataset.tableId!;\n  }\n\n  get full() {\n    return Object.hasOwn(this.domNode.dataset, 'full');\n  }\n\n  set full(value: boolean) {\n    if (value) {\n      this.domNode.dataset.full = String(true);\n    }\n    else {\n      this.domNode.removeAttribute('data-full');\n    }\n    this.colWidthFillTable();\n  }\n\n  get align() {\n    return this.domNode.dataset.align || '';\n  }\n\n  set align(value: string) {\n    if (value === 'right' || value === 'center') {\n      this.domNode.dataset.align = value;\n    }\n    else {\n      this.domNode.removeAttribute('data-align');\n    }\n    this.updateAlign();\n  }\n\n  setFull() {\n    if (this.full) return;\n    const cols = this.getCols();\n    if (cols.length === 0) return;\n    const tableWidth = Math.floor(this.domNode.getBoundingClientRect().width);\n    for (const col of cols) {\n      const value = col.width / tableWidth * 100;\n      col.full = true;\n      col.width = value;\n    }\n  }\n\n  cancelFull() {\n    if (!this.full) return;\n    const cols = this.getCols();\n    if (cols.length === 0) return;\n    const tableWidth = Math.floor(this.domNode.getBoundingClientRect().width);\n    for (const col of cols) {\n      col.full = false;\n      col.width = Math.max(col.width / 100 * tableWidth, tableUpSize.colMinWidthPx);\n    }\n  }\n\n  updateAlign() {\n    const value = this.align;\n    const style: Record<string, string | null> = {\n      marginLeft: null,\n      marginRight: null,\n    };\n    switch (value) {\n      case 'center': {\n        style.marginLeft = 'auto';\n        style.marginRight = 'auto';\n        break;\n      }\n      case '':\n      case 'left': {\n        style.marginRight = 'auto';\n        break;\n      }\n      case 'right': {\n        style.marginLeft = 'auto';\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n    Object.assign(this.domNode.style, style);\n  }\n\n  getBodys() {\n    return Array.from(this.domNode.querySelectorAll('thead, tbody, tfoot'))\n      .map(el => this.scroll.find(el) as TableBodyFormat)\n      .filter(Boolean);\n  }\n\n  getRows() {\n    return Array.from(this.domNode.querySelectorAll('tr'))\n      .map(el => this.scroll.find(el) as TableRowFormat)\n      .filter(Boolean);\n  }\n\n  getRowIds() {\n    return this.getRows().map(d => d.rowId);\n  }\n\n  getCols() {\n    return this.descendants(TableColFormat);\n  }\n\n  getColIds() {\n    return this.getCols().map(d => d.colId);\n  }\n\n  checkMerge(): boolean {\n    const next = this.next;\n    return (\n      next !== null\n      && next.statics.blotName === this.statics.blotName\n      && next.domNode.dataset.tableId === this.tableId\n    );\n  }\n\n  optimize(context: Record<string, any>) {\n    const parent = this.parent;\n    if (parent !== null && parent.statics.blotName !== blotName.tableWrapper) {\n      this.wrap(blotName.tableWrapper, this.tableId);\n    }\n\n    super.optimize(context);\n    this.mergeRow();\n  }\n\n  // ensure row id unique in same table\n  mergeRow() {\n    if (!this.parent) return;\n    const rows = this.getRows();\n    const rowGroup: Record<string, TableRowFormat[]> = {};\n    for (const row of rows) {\n      if (!rowGroup[row.rowId]) rowGroup[row.rowId] = [];\n      rowGroup[row.rowId].push(row);\n    }\n\n    for (const rowList of Object.values(rowGroup)) {\n      for (let i = 1; i < rowList.length; i++) {\n        const row = rowList[i];\n        row.moveChildren(rowList[0]);\n        row.remove();\n      }\n    }\n  }\n\n  checkEmptyCol(autoMerge: boolean) {\n    if (autoMerge) {\n      const rowCount = this.getRows().length;\n      const cols = this.getCols();\n      const cells = this.descendants(TableCellInnerFormat);\n      for (const cell of cells) {\n        if (cell.colspan > 1 && cell.rowspan >= rowCount) {\n          const index = cols.findIndex(col => col.colId === cell.colId);\n          const currentCol = cols[index];\n          for (let i = index + 1; i < index + cell.colspan; i++) {\n            cols[i].remove();\n            currentCol.width += cols[i].width;\n          }\n          cell.colspan = 1;\n        }\n      }\n    }\n  }\n\n  checkEmptyRow(autoMerge: boolean) {\n    const rows = this.getRows();\n    const rowIds = new Set(rows.map(row => row.rowId));\n    for (let i = rows.length - 1; i >= 0; i--) {\n      const row = rows[i];\n      if (autoMerge) {\n        // reduce rowspan previou row\n        if (row.children.length === 0) {\n          for (let gap = 1, j = i - 1; j >= 0; j--, gap++) {\n            const prev = rows[j];\n            prev.foreachCellInner((cell) => {\n              if (cell.rowspan > gap) {\n                cell.rowspan -= 1;\n                const emptyRow = new Set(cell.emptyRow);\n                emptyRow.delete(row.rowId);\n                cell.emptyRow = Array.from(emptyRow);\n              }\n            });\n          }\n          row.remove();\n        }\n      }\n      else {\n        if (row.children.length === 0 && row.prev) {\n          // find the not empty row\n          let prev = row.prev as TableRowFormat;\n          while (prev?.children.length === 0) {\n            prev = prev.prev as TableRowFormat;\n          }\n          prev.foreachCellInner((cell) => {\n            const emptyRowIds = new Set(cell.emptyRow);\n            // prevent order change. like currnet emptyRow ['1', '2'] add rowId '2' will be ['2', '1']\n            if (!emptyRowIds.has(row.rowId)) {\n              // the loop is from back to front, and the rowId should be added to the head\n              cell.emptyRow = [row.rowId, ...emptyRowIds];\n            }\n          });\n        }\n        row.foreachCellInner((cell) => {\n          for (const emptyRow of cell.emptyRow) {\n            if (!rowIds.has(emptyRow)) {\n              row.parent.insertBefore(this.scroll.create(blotName.tableRow, { tableId: this.tableId, rowId: emptyRow }), row.next);\n            }\n          }\n        });\n      }\n    }\n  }\n\n  sortMergeChildren() {\n    // move same type children to the first child\n    const childs: Record<string, ContainerFormat[]> = {\n      [blotName.tableCaption]: [],\n      [blotName.tableColgroup]: [],\n      [blotName.tableHead]: [],\n      [blotName.tableBody]: [],\n      [blotName.tableFoot]: [],\n    };\n    // eslint-disable-next-line unicorn/no-array-for-each\n    this.children.forEach((child) => {\n      if (childs[child.statics.blotName]) {\n        childs[child.statics.blotName].push(child as ContainerFormat);\n      }\n    });\n    for (const formats of Object.values(childs)) {\n      for (let i = 1; i < formats.length; i++) {\n        formats[i].moveChildren(formats[0]);\n      }\n    }\n\n    // check sort child\n    const tableCaption = childs[blotName.tableCaption][0];\n    const tableColgroup = childs[blotName.tableColgroup][0];\n    const tableHead = childs[blotName.tableHead][0];\n    const tableBody = childs[blotName.tableBody][0];\n    const tableFoot = childs[blotName.tableFoot][0];\n\n    const isCaptionFirst = tableCaption && this.children.head !== tableCaption;\n    const isColgroupSecond = tableColgroup && tableCaption && tableCaption.next !== tableColgroup;\n    const isColgroupFirst = tableColgroup && !tableCaption && this.children.head !== tableColgroup;\n    const isHeadLast = tableHead && !tableBody && !tableFoot && this.children.tail !== tableHead;\n    const isBodyAfterHead = tableBody && tableHead && tableBody.prev !== tableHead;\n    const isBodyLast = tableBody && !tableFoot && this.children.tail !== tableBody;\n    const isBodyBeforeFoot = tableBody && tableFoot && tableBody.next !== tableFoot;\n    const isFootLast = tableFoot && this.children.tail !== tableFoot;\n\n    // sort child\n    if (isCaptionFirst || isColgroupSecond || isColgroupFirst || isHeadLast || isBodyAfterHead || isBodyLast || isBodyBeforeFoot || isFootLast) {\n      const tableMain = this.clone() as TableMainFormat;\n      tableCaption && tableMain.appendChild(tableCaption);\n      tableColgroup && tableMain.appendChild(tableColgroup);\n      tableHead && tableMain.appendChild(tableHead);\n      tableBody && tableMain.appendChild(tableBody);\n      tableFoot && tableMain.appendChild(tableFoot);\n\n      // eslint-disable-next-line unicorn/no-array-for-each\n      this.children.forEach(child => child.remove());\n      tableMain.moveChildren(this);\n    }\n  }\n\n  // insert row at index\n  insertRow(targetIndex: number) {\n    // get all column id. exclude the columns of the target index row with rowspan\n    const colIds = this.getColIds();\n    const rows = this.descendants(TableRowFormat);\n    const insertColIds = new Set(colIds);\n    let index = 0;\n    for (const row of rows) {\n      if (index === targetIndex) break;\n      row.foreachCellInner((cell) => {\n        if (index + cell.rowspan > targetIndex) {\n          cell.rowspan += 1;\n          insertColIds.delete(cell.colId);\n          // colspan cell need remove all includes colId\n          if (cell.colspan !== 1) {\n            const colIndex = colIds.indexOf(cell.colId);\n            for (let i = 0; i < cell.colspan - 1; i++) {\n              insertColIds.delete(colIds[colIndex + i + 1]);\n            }\n          }\n        }\n      });\n      index += 1;\n    }\n    // append new row\n    const tableId = this.tableId;\n    const rowId = randomId();\n    const tableRow = this.scroll.create(blotName.tableRow, {\n      tableId,\n      rowId,\n    }) as ContainerFormat;\n    for (const colId of insertColIds) {\n      const breakBlot = this.scroll.create('break');\n      const block = breakBlot.wrap('block');\n      const tableCellInner = block.wrap(blotName.tableCellInner, {\n        tableId,\n        rowId,\n        colId,\n        rowspan: 1,\n        colspan: 1,\n      });\n      const tableCell = tableCellInner.wrap(blotName.tableCell, {\n        tableId,\n        rowId,\n        colId,\n        rowspan: 1,\n        colspan: 1,\n      });\n      tableRow.appendChild(tableCell);\n    }\n\n    // insert the new row at the target index\n    // if you insert a row at the thead, then the new row will be inserted in thead. Similarly for tbody and tfoot\n    const refRow = rows[targetIndex] || null;\n    if (!refRow) {\n      rows[rows.length - 1].parent.appendChild(tableRow);\n    }\n    else {\n      refRow.parent.insertBefore(tableRow, refRow);\n    }\n  }\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type { TableColValue, TableValue } from '../utils';\nimport type { TableColFormat } from './table-col-format';\nimport { blotName, findParentBlot, tableUpSize } from '../utils';\nimport { ContainerFormat } from './container-format';\nimport { TableMainFormat } from './table-main-format';\n\nexport class TableColgroupFormat extends ContainerFormat {\n  static blotName = blotName.tableColgroup;\n  static tagName = 'colgroup';\n  declare children: TypeParchment.LinkedList<TableColFormat>;\n\n  static create(value: TableValue) {\n    const node = super.create() as HTMLElement;\n    node.dataset.tableId = value.tableId;\n    value.full && (node.dataset.full = String(value.full));\n    if (value.align && value.align !== 'left') {\n      node.dataset.align = value.align;\n    }\n    node.setAttribute('contenteditable', 'false');\n    return node;\n  }\n\n  get tableId() {\n    return this.domNode.dataset.tableId!;\n  }\n\n  get full() {\n    return Object.hasOwn(this.domNode.dataset, 'full');\n  }\n\n  set full(value: boolean) {\n    if (value) {\n      this.domNode.dataset.full = String(true);\n    }\n    else {\n      this.domNode.removeAttribute('data-full');\n    }\n    if (this.parent && this.parent instanceof TableMainFormat) {\n      this.parent.full = value;\n    }\n  }\n\n  get align() {\n    return this.domNode.dataset.align || '';\n  }\n\n  set align(value: string) {\n    if (value === 'right' || value === 'center') {\n      this.domNode.dataset.align = value;\n    }\n    else {\n      this.domNode.removeAttribute('data-align');\n    }\n  }\n\n  findCol(index: number) {\n    const next = this.children.iterator();\n    let i = 0;\n    let cur: TableColFormat | null;\n    while ((cur = next())) {\n      if (i === index) {\n        break;\n      }\n      i++;\n    }\n    return cur;\n  }\n\n  insertColByIndex(index: number, value: TableColValue) {\n    const table = this.parent;\n    if (!(table instanceof TableMainFormat)) {\n      throw new TypeError('TableColgroupFormat should be child of TableFormat');\n    }\n    const col = this.findCol(index);\n    const tableCellInner = this.scroll.create(blotName.tableCol, value) as TableColFormat;\n    if (table.full) {\n      // TODO: first minus column should be near by\n      const next = this.children.iterator();\n      let cur: TableColFormat | null;\n      while ((cur = next())) {\n        if (cur.width - tableCellInner.width >= tableUpSize.colMinWidthPre) {\n          cur.width -= tableCellInner.width;\n          break;\n        }\n      }\n    }\n    this.insertBefore(tableCellInner, col);\n  }\n\n  removeColByIndex(index: number) {\n    const table = this.parent;\n    if (!(table instanceof TableMainFormat)) {\n      throw new TypeError('TableColgroupFormat should be child of TableMainFormat');\n    }\n    const col = this.findCol(index);\n    if (col) {\n      if (table.full) {\n        if (col.next) {\n          (col.next as TableColFormat).width += col.width;\n        }\n        else if (col.prev) {\n          (col.prev as TableColFormat).width += col.width;\n        }\n      }\n      col.remove();\n      table.colWidthFillTable();\n    }\n  }\n\n  checkMerge(): boolean {\n    const next = this.next as TableColgroupFormat;\n    const tableMain = this.parent;\n    if ((tableMain instanceof TableMainFormat) && !tableMain.full) {\n      tableMain.colWidthFillTable();\n    }\n    return (\n      next !== null\n      && next.statics.blotName === this.statics.blotName\n      && next.tableId === this.tableId\n    );\n  }\n\n  optimize(context: Record<string, any>) {\n    const parent = this.parent;\n    const { tableId, full, align } = this;\n    if (parent != null && parent.statics.blotName !== blotName.tableMain) {\n      this.wrap(blotName.tableMain, { tableId, full, align });\n    }\n\n    const tableMain = findParentBlot(this, blotName.tableMain);\n    tableMain.align = align;\n\n    super.optimize(context);\n  }\n}\n","import { blotName } from '../utils';\nimport { TableBodyFormat } from './table-body-format';\n\nexport class TableFootFormat extends TableBodyFormat {\n  static blotName = blotName.tableFoot;\n  static tagName = 'tfoot';\n}\n","import { blotName } from '../utils';\nimport { TableBodyFormat } from './table-body-format';\n\nexport class TableHeadFormat extends TableBodyFormat {\n  static blotName = blotName.tableHead;\n  static tagName = 'thead';\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport Quill from 'quill';\nimport { blotName } from '../utils';\nimport { ContainerFormat } from './container-format';\nimport { TableBodyFormat } from './table-body-format';\nimport { TableColgroupFormat } from './table-colgroup-format';\n\nconst Parchment = Quill.import('parchment');\n\nexport class TableWrapperFormat extends ContainerFormat {\n  static blotName = blotName.tableWrapper;\n  static tagName = 'div';\n  static className = 'ql-table-wrapper';\n\n  static create(value: string) {\n    const node = super.create() as HTMLElement;\n\n    node.dataset.tableId = value;\n    node.addEventListener(\n      'dragstart',\n      (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n      },\n      true,\n    );\n    // not allow drop content into table\n    node.addEventListener('drop', (e) => {\n      e.preventDefault();\n    });\n    node.addEventListener('dragover', (e) => {\n      e.preventDefault();\n      e.dataTransfer!.dropEffect = 'none';\n    });\n    node.setAttribute('contenteditable', 'false');\n    return node;\n  }\n\n  // quill scroll doesn't extends EventEmitter ts type. `on` and `off` will have dts error\n  constructor(public scroll: any, node: Node, _value: string) {\n    super(scroll, node);\n    this.scroll.emitter.on(Quill.events.TEXT_CHANGE, this.insertLineAround);\n  }\n\n  get tableId() {\n    return this.domNode.dataset.tableId!;\n  }\n\n  checkMerge(): boolean {\n    const next = this.next as TableWrapperFormat;\n    return (\n      next !== null\n      && next.statics.blotName === this.statics.blotName\n      && next.tableId === this.tableId\n    );\n  }\n\n  optimize(context: Record<string, any>) {\n    if (this.length() === 0) {\n      this.remove();\n      return;\n    }\n    super.optimize(context);\n  }\n\n  deleteAt(index: number, length: number) {\n    super.deleteAt(index, length);\n    const tableBodys = this.descendants(TableBodyFormat);\n    const tableColgroups = this.descendants(TableColgroupFormat);\n    if (tableBodys.length === 0 && tableColgroups.length === 0) {\n      this.remove();\n    }\n  }\n\n  remove() {\n    super.remove();\n    this.scroll.emitter.off(Quill.events.TEXT_CHANGE, this.insertLineAround);\n  }\n\n  isBlockLine(blot: TypeParchment.Blot) {\n    return blot instanceof Parchment.BlockBlot || new Set(['list-container', 'code-block-container']).has(blot.statics.blotName);\n  }\n\n  insertLineAround = () => {\n    if (!this.prev || !this.isBlockLine(this.prev)) {\n      this.parent.insertBefore(this.scroll.create('block'), this);\n    }\n    if (!this.next || !this.isBlockLine(this.next)) {\n      this.parent.insertBefore(this.scroll.create('block'), this.next);\n    }\n  };\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type { TableBodyFormat } from './table-body-format';\nimport type { TableFootFormat } from './table-foot-format';\nimport type { TableHeadFormat } from './table-head-format';\nimport type { TableMainFormat } from './table-main-format';\nimport { blotName } from '../utils';\n\nexport * from './container-format';\nexport * from './overrides';\nexport * from './table-body-format';\nexport * from './table-caption-format';\nexport * from './table-cell-format';\nexport * from './table-cell-inner-format';\nexport * from './table-col-format';\nexport * from './table-colgroup-format';\nexport * from './table-foot-format';\nexport * from './table-head-format';\nexport * from './table-main-format';\nexport * from './table-row-format';\nexport * from './table-wrapper-format';\n\nexport function getTableMainRect(tableMainBlot: TableMainFormat): {\n  rect: DOMRect | null;\n  head: TableHeadFormat | null;\n  body: TableBodyFormat | null;\n  foot: TableFootFormat | null;\n} {\n  const mainBlotName: Set<string> = new Set([blotName.tableHead, blotName.tableBody, blotName.tableFoot]);\n  const childIterator = tableMainBlot.children.iterator();\n  let child: null | TypeParchment.Blot = null;\n  const mainBlot: Record<string, TypeParchment.Blot> = {};\n  while ((child = childIterator())) {\n    if (mainBlotName.has(child.statics.blotName)) {\n      mainBlot[child.statics.blotName] = child;\n    }\n  }\n  if (Object.values(mainBlot).length <= 0) {\n    return {\n      rect: null,\n      head: null,\n      body: null,\n      foot: null,\n    };\n  }\n  const mainBlotRect = Object.values(mainBlot).reduce((rect, blot) => {\n    const blotRect = (blot.domNode as HTMLElement).getBoundingClientRect();\n    return {\n      ...rect,\n      top: Math.min(rect.top, blotRect.top),\n      bottom: Math.max(rect.bottom, blotRect.bottom),\n      left: Math.min(rect.left, blotRect.left),\n      right: Math.max(rect.right, blotRect.right),\n    };\n  }, {\n    top: Infinity,\n    bottom: 0,\n    left: Infinity,\n    right: 0,\n    width: 0,\n    height: 0,\n    x: Infinity,\n    y: Infinity,\n  } as DOMRect);\n  mainBlotRect.width = mainBlotRect.right - mainBlotRect.left;\n  mainBlotRect.height = mainBlotRect.bottom - mainBlotRect.top;\n  mainBlotRect.x = mainBlotRect.left;\n  mainBlotRect.y = mainBlotRect.top;\n\n  return {\n    rect: mainBlotRect,\n    head: mainBlot[blotName.tableHead] as TableHeadFormat || null,\n    body: mainBlot[blotName.tableBody] as TableBodyFormat || null,\n    foot: mainBlot[blotName.tableFoot] as TableFootFormat || null,\n  };\n}\n","import type Quill from 'quill';\nimport type { TableUp } from '../table-up';\n\nexport class TableDomSelector {\n  table?: HTMLTableElement;\n\n  constructor(public tableModule: TableUp, public quill: Quill) {\n    this.quill.root.addEventListener('mousedown', this.tableSelectHandler.bind(this));\n  }\n\n  tableSelectHandler(event: MouseEvent) {\n    const path = event.composedPath() as HTMLElement[];\n    if (event.button !== 0 || !path || path.length <= 0) return;\n    const tableNode = path.find(node => node.tagName && node.tagName.toUpperCase() === 'TABLE');\n    this.setSelectionTable(tableNode as HTMLTableElement);\n  }\n\n  setSelectionTable(table: HTMLTableElement | undefined) {\n    if (this.table === table) return;\n    this.hide();\n    this.table = table;\n    if (this.table) {\n      this.show();\n    }\n    this.update();\n  }\n\n  hide() {}\n\n  show() {}\n\n  update() {}\n}\n","import type { TableMainFormat, TableWrapperFormat } from '../formats';\nimport type { TableUp } from '../table-up';\nimport { autoUpdate, computePosition, flip, limitShift, offset, shift } from '@floating-ui/dom';\nimport Quill from 'quill';\nimport { createBEM, createResizeObserver } from '../utils';\nimport { TableDomSelector } from './table-dom-selector';\n\nexport class TableAlign extends TableDomSelector {\n  static moduleName: string = 'table-align';\n\n  tableBlot?: TableMainFormat;\n  tableWrapperBlot?: TableWrapperFormat;\n  alignBox: HTMLElement | null;\n  cleanup?: () => void;\n  bem = createBEM('align');\n  resizeObserver?: ResizeObserver;\n\n  constructor(public tableModule: TableUp, public quill: Quill, _options: any) {\n    super(tableModule, quill);\n\n    this.alignBox = this.buildTools();\n    this.hide();\n    this.quill.on(Quill.events.EDITOR_CHANGE, this.updateWhenTextChange);\n  }\n\n  updateWhenTextChange = (eventName: string) => {\n    if (eventName === Quill.events.TEXT_CHANGE) {\n      if (this.table && !this.quill.root.contains(this.table)) {\n        this.setSelectionTable(undefined);\n      }\n      else {\n        this.update();\n      }\n    }\n  };\n\n  buildTools() {\n    const alignBox = this.tableModule.addContainer(this.bem.b());\n    const icons = Quill.import('ui/icons') as Record<string, any>;\n    const alignIcons = {\n      left: icons.align[''],\n      center: icons.align.center,\n      right: icons.align.right,\n    };\n    for (const [align, iconStr] of Object.entries(alignIcons)) {\n      const item = document.createElement('span');\n      item.dataset.align = align;\n      item.classList.add(this.bem.be('item'));\n      item.innerHTML = `<i class=\"icon\">${iconStr}</i>`;\n      item.addEventListener('click', this.handleAlignItemClick.bind(this));\n      alignBox.appendChild(item);\n    }\n    return alignBox;\n  }\n\n  handleAlignItemClick(e: MouseEvent) {\n    const item = e.currentTarget;\n    if (!item) return;\n    const value = (item as HTMLElement).dataset.align;\n    if (value && this.tableBlot) {\n      this.setTableAlign(this.tableBlot, value);\n    }\n  }\n\n  setTableAlign(tableBlot: TableMainFormat, align: string) {\n    const cols = tableBlot.getCols();\n    for (const col of cols) {\n      col.align = align;\n    }\n  }\n\n  show() {\n    if (!this.table || !this.alignBox) return;\n    this.tableBlot = Quill.find(this.table) as TableMainFormat;\n    this.tableWrapperBlot = this.tableBlot.parent as TableWrapperFormat;\n    this.alignBox.classList.remove(this.bem.is('hidden'));\n    this.resizeObserver = createResizeObserver(() => this.update(), { ignoreFirstBind: true });\n    this.resizeObserver.observe(this.table);\n    if (this.cleanup) {\n      this.cleanup();\n    }\n    this.cleanup = autoUpdate(\n      this.tableWrapperBlot.domNode,\n      this.alignBox,\n      () => this.update(),\n    );\n  }\n\n  hide() {\n    this.tableBlot = undefined;\n    this.tableWrapperBlot = undefined;\n    if (this.alignBox) {\n      this.alignBox.classList.add(this.bem.is('hidden'));\n    }\n    if (this.cleanup) {\n      this.cleanup();\n      this.cleanup = undefined;\n    }\n  }\n\n  update() {\n    if (!this.alignBox || !this.tableBlot || !this.tableWrapperBlot) return;\n    if (!this.table || this.tableBlot.full || this.tableBlot.domNode.offsetWidth >= this.quill.root.offsetWidth) {\n      this.hide();\n      return;\n    }\n\n    computePosition(this.tableWrapperBlot.domNode, this.alignBox, {\n      placement: 'top',\n      middleware: [flip(), shift({ limiter: limitShift() }), offset(16)],\n    }).then(({ x, y }) => {\n      Object.assign(this.alignBox!.style, {\n        left: `${x}px`,\n        top: `${y}px`,\n      });\n    });\n  }\n\n  destroy() {\n    this.hide();\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = undefined;\n    }\n    this.quill.off(Quill.events.TEXT_CHANGE, this.updateWhenTextChange);\n    if (this.alignBox) {\n      this.alignBox.remove();\n      this.alignBox = null;\n    }\n  }\n}\n","import type { Op, Delta as TypeDelta } from 'quill';\nimport type { TableUp } from '../../table-up';\nimport type { TableCellValue } from '../../utils';\nimport Quill from 'quill';\nimport { TableCellInnerFormat } from '../../formats';\nimport { blotName, findParentBlot } from '../../utils';\n\nconst Delta = Quill.import('delta');\n\ninterface ArgumentsModule {\n  quill: Quill;\n  talbeModule: TableUp;\n}\n\ninterface CellUpdate {\n  offset: number;\n  length: number;\n  insertDelta: TypeDelta;\n  cell: TableCellInnerFormat;\n  rowspan?: number;\n  colspan?: number;\n  emptyRow?: string[];\n}\ninterface TableCellValueLike {\n  rowId: string;\n  colId: string;\n  colspan: number;\n  rowspan: number;\n  emptyRow?: string[];\n}\ninterface CellRecord extends TableCellValueLike {\n  deltaOps: Op[];\n}\n\nexport function pasteCells(modules: ArgumentsModule, selectedTds: TableCellInnerFormat[], pasteDelta: Op[]) {\n  const { rows: selectedRows, cols: selectedCols } = getTableCellStructure(selectedTds);\n  const { rows: pasteRows, cols: pasteCols, cells: pasteCells } = parsePasteDelta(pasteDelta);\n\n  if (selectedRows === pasteRows && selectedCols === pasteCols) {\n    // if paste cells have same rows and cols count. then paste with structure\n    pasteWithStructure(selectedTds, pasteCells, modules);\n  }\n  else {\n    // else paste with loop\n    pasteWithLoop(modules, selectedTds, pasteCells);\n  }\n}\n\nexport function getTableCellStructure(cells: TableCellInnerFormat[]) {\n  if (cells.length === 0) return { rows: 0, cols: 0 };\n\n  const cellPositions = getCellPositions(cells);\n  const counts = getCountByPosition(cellPositions);\n  return counts;\n}\n\nexport function parsePasteDelta(delta: Op[]) {\n  const cellMap = new Map<string, CellRecord>();\n\n  for (const op of delta) {\n    const attributes = op.attributes;\n    if (!attributes) continue;\n    const cellValue = attributes[blotName.tableCellInner] as TableCellValue;\n    if (!cellValue) continue;\n\n    const cellKey = `${cellValue.rowId}-${cellValue.colId}`;\n    if (!cellMap.has(cellKey)) {\n      const value: CellRecord = {\n        rowId: cellValue.rowId,\n        colId: cellValue.colId,\n        rowspan: cellValue.rowspan || 1,\n        colspan: cellValue.colspan || 1,\n        deltaOps: [],\n      };\n      if (cellValue.emptyRow && cellValue.emptyRow.length > 0) {\n        value.emptyRow = cellValue.emptyRow;\n      }\n      cellMap.set(cellKey, value);\n    }\n\n    const cell = cellMap.get(cellKey)!;\n    const { [blotName.tableCellInner]: cellInnerValue, ...attrs } = attributes;\n    cell.deltaOps.push({\n      insert: op.insert,\n      attributes: { ...attrs },\n    });\n  }\n\n  const cells = Array.from(cellMap.values());\n  const cellPositions = getCellPositions(cells);\n  const counts = getCountByPosition(cellPositions);\n\n  return {\n    ...counts,\n    cells,\n  };\n}\n\nexport function getCountByPosition(infos: ReturnType<typeof getCellPositions>) {\n  let minRowIndex = Infinity;\n  let maxRowIndex = -Infinity;\n  let minColIndex = Infinity;\n  let maxColIndex = -Infinity;\n  for (const info of infos) {\n    const { cell, rowIndex, colIndex } = info;\n\n    const colspan = cell.colspan || 1;\n    const rowspan = cell.rowspan || 1;\n    minRowIndex = Math.min(minRowIndex, rowIndex);\n    maxRowIndex = Math.max(maxRowIndex, rowIndex + rowspan - 1);\n    minColIndex = Math.min(minColIndex, colIndex);\n    maxColIndex = Math.max(maxColIndex, colIndex + colspan - 1);\n  }\n\n  return {\n    rows: Math.max(maxRowIndex - minRowIndex + 1, 0),\n    cols: Math.max(maxColIndex - minColIndex + 1, 0),\n  };\n}\n\nexport function pasteWithStructure(selectedTds: TableCellInnerFormat[], pasteCells: CellRecord[], modules: ArgumentsModule) {\n  const targetPositions = getCellPositions(selectedTds);\n  const pastePositions = getCellPositions(pasteCells);\n\n  const positionMap = new Map<string, CellRecord>();\n  for (const pos of pastePositions) {\n    positionMap.set(`${pos.rowIndex}-${pos.colIndex}`, pos.cell);\n  }\n\n  const updates: CellUpdate[] = [];\n  const processedCells = new Set<TableCellInnerFormat>();\n  for (const targetPos of targetPositions) {\n    const targetCell = targetPos.cell;\n\n    // skip updated cells\n    if (!targetCell.domNode.isConnected || processedCells.has(targetCell)) continue;\n\n    const pasteCell = positionMap.get(`${targetPos.rowIndex}-${targetPos.colIndex}`);\n    if (pasteCell) {\n      const update = prepareCellUpdate(modules, targetCell, pasteCell.deltaOps, {\n        rowspan: pasteCell.rowspan,\n        colspan: pasteCell.colspan,\n        emptyRow: pasteCell.emptyRow,\n      });\n      updates.push(update);\n      processedCells.add(targetCell);\n    }\n  }\n  applyCellUpdates(modules, updates);\n}\n\nexport function getCellPositions<T extends TableCellValueLike>(cells: T[]) {\n  const positions: { cell: T; rowIndex: number; colIndex: number }[] = [];\n\n  // calculate the cell position(rowIndex, colIndex)\n  const rowMap = groupCellByRow(cells);\n  let targetRowIndex = -1;\n  const rowPositions = new Map<string, number>();\n  for (const [rowId, rowCells] of rowMap.entries()) {\n    if (!rowPositions.has(rowId)) {\n      targetRowIndex += 1;\n      rowPositions.set(rowId, targetRowIndex);\n    }\n\n    let currentColIndex = 0;\n    for (const cell of rowCells) {\n      positions.push({\n        cell,\n        rowIndex: rowPositions.get(rowId)!,\n        colIndex: currentColIndex,\n      });\n\n      currentColIndex += cell.colspan || 1;\n      // record rowId by emptyRow to increase rowIndex\n      const emptyRow = cell.emptyRow || [];\n      for (const emptyRowId of emptyRow) {\n        if (!rowPositions.has(emptyRowId)) {\n          targetRowIndex += 1;\n          rowPositions.set(emptyRowId, targetRowIndex);\n        }\n      }\n    }\n  }\n\n  return positions;\n}\n\nexport function groupCellByRow<T extends TableCellValueLike>(cells: T[]) {\n  const rowMap = new Map<string, T[]>();\n  for (const cell of cells) {\n    if (!rowMap.has(cell.rowId)) {\n      rowMap.set(cell.rowId, []);\n    }\n    rowMap.get(cell.rowId)!.push(cell);\n  }\n  return rowMap;\n}\n\nexport function pasteWithLoop(modules: ArgumentsModule, selectedTds: TableCellInnerFormat[], pasteCells: CellRecord[]) {\n  const rowMap = groupCellByRow(pasteCells);\n  const pasteRows = Array.from(rowMap.values());\n\n  const targetCols = getTableCellStructure(selectedTds).cols;\n  const updates: CellUpdate[] = [];\n\n  // loop cell in row to fill content\n  for (let i = 0; i < selectedTds.length; i++) {\n    const targetCell = selectedTds[i];\n    // find the correct cell delta\n    const targetRow = Math.floor(i / targetCols);\n    const targetCol = i % targetCols;\n    const pasteRowIndex = targetRow % pasteRows.length;\n    const pasteRow = pasteRows[pasteRowIndex];\n    const pasteColIndex = targetCol % pasteRow.length;\n    const pasteCell = pasteRow[pasteColIndex];\n\n    const update = prepareCellUpdate(modules, targetCell, pasteCell.deltaOps);\n    updates.push(update);\n  }\n  applyCellUpdates(modules, updates);\n}\n\nexport function prepareCellUpdate(\n  modules: ArgumentsModule,\n  cell: TableCellInnerFormat,\n  deltaOps: Op[],\n  attrs?: Pick<TableCellValue, 'rowspan' | 'colspan' | 'emptyRow'>,\n): CellUpdate {\n  const { rowspan = 1, colspan = 1, emptyRow } = attrs || {};\n  if (attrs) {\n    cell.rowspan = rowspan;\n    cell.colspan = colspan;\n    if (emptyRow && emptyRow.length > 0) {\n      cell.emptyRow = emptyRow;\n    }\n  }\n\n  const cellValue = cell.formats();\n  const insertDelta = new Delta();\n  for (const op of deltaOps) {\n    insertDelta.insert(op.insert!, { ...op.attributes, ...cellValue });\n  }\n\n  const offset = cell.offset(modules.quill.scroll);\n  const length = cell.length();\n\n  return {\n    offset,\n    length,\n    insertDelta,\n    cell,\n    rowspan,\n    colspan,\n    emptyRow,\n  };\n}\n\nexport function applyCellUpdates(modules: ArgumentsModule, updates: CellUpdate[]) {\n  if (updates.length === 0) return;\n\n  // sort updates by offset to ensure proper deletion order\n  updates.sort((a, b) => a.offset - b.offset);\n  let combinedDelta = new Delta();\n  for (let i = 0; i < updates.length; i++) {\n    const update = updates[i];\n\n    let retain = update.offset;\n    if (i !== 0) {\n      // for subsequent updates, adjust offsets based on previous operations\n      const prev = updates[i - 1];\n      retain = update.offset - prev.offset - prev.length;\n    }\n    combinedDelta = combinedDelta\n      .retain(retain)\n      .concat(update.insertDelta)\n      .delete(update.length);\n  }\n  // remove cells covered by colspan/rowspan\n  for (const update of updates) {\n    removeOverlappingCells(modules, update);\n  }\n\n  modules.quill.updateContents(combinedDelta, Quill.sources.USER);\n}\n\nexport function removeOverlappingCells(modules: ArgumentsModule, updateCell: CellUpdate) {\n  const { cell, rowspan = 1, colspan = 1 } = updateCell;\n  if (rowspan === 1 && colspan === 1) return;\n  const table = findParentBlot(cell, blotName.tableMain);\n  if (!table) return;\n  const tableRow = cell.getTableRow();\n  if (!tableRow) return;\n\n  const allCells = table.descendants(TableCellInnerFormat);\n  const tableRows = table.getRows();\n  const cellRowIndex = tableRows.indexOf(tableRow);\n  const cellColumnIndex = cell.getColumnIndex();\n\n  const cellsToRemove: TableCellInnerFormat[] = [];\n  for (const otherCell of allCells) {\n    if (otherCell === cell) continue;\n\n    const otherRow = otherCell.getTableRow();\n    if (!otherRow) continue;\n\n    const otherRowIndex = tableRows.indexOf(otherRow);\n    const otherColumnIndex = otherCell.getColumnIndex();\n\n    // check if the other cell is within the rowspan/colspan range of the current cell\n    const isInRowspanRange = otherRowIndex >= cellRowIndex && otherRowIndex < cellRowIndex + rowspan;\n    const isInColspanRange = otherColumnIndex >= cellColumnIndex && otherColumnIndex < cellColumnIndex + colspan;\n\n    if (isInRowspanRange && isInColspanRange) {\n      cellsToRemove.push(otherCell);\n    }\n  }\n\n  // remove cells covered by the current cell(colspan/rowspan)\n  const isAutoMerge = modules.talbeModule.options.autoMergeCell;\n  for (const cellToRemove of cellsToRemove) {\n    if (cellToRemove.domNode.isConnected) {\n      const cellRow = cellToRemove.getTableRow();\n      cellToRemove.remove();\n      if (!isAutoMerge && cellRow && cellRow.length() <= 0) {\n        cellRow.remove();\n      }\n    }\n  }\n}\n","import type { Parchment as TypeParchment } from 'quill';\nimport type { Delta as TypeDelta } from 'quill/core';\nimport type TypeClipboard from 'quill/modules/clipboard';\nimport type { TableCaptionValue, TableCellValue } from '../../utils';\nimport Quill from 'quill';\nimport { TableCellFormat, TableColFormat } from '../../formats';\nimport { blotName, cssTextToObject, isObject, isString, objectToCssText, randomId, tableUpSize } from '../../utils';\n\nconst Delta = Quill.import('delta');\nconst Clipboard = Quill.import('modules/clipboard') as typeof TypeClipboard;\nexport type Selector = string | Node['TEXT_NODE'] | Node['ELEMENT_NODE'];\nexport type Matcher = (node: Node, delta: TypeDelta, scroll: TypeParchment.ScrollBlot) => TypeDelta;\nexport interface ClipboardOptions {\n  matchers: [Selector, Matcher][];\n}\n\nfunction getCellWidth(cell: HTMLElement): number {\n  let width = Number.parseFloat(cell.getAttribute('width')!);\n  if (Number.isNaN(width)) {\n    const styleWidth = cell.style.width;\n    width = styleWidth ? Number.parseFloat(styleWidth) : cell.offsetWidth;\n  }\n  return width || tableUpSize.colDefaultWidth;\n}\nfunction calculateCols(tableNode: HTMLElement, colNums: number): number[] {\n  const colWidths = new Array(colNums).fill(tableUpSize.colDefaultWidth);\n  // no need consider colspan\n  // word table will have a row at last <!--[if !supportMisalignedColumns]-->\n  // that tr doesn't have colspan and every td have width attribute. but set style \"border:none\"\n  const rows = Array.from(tableNode.querySelectorAll('tr'));\n  for (const row of rows) {\n    const cells = Array.from(row.querySelectorAll('td'));\n    let index = 0;\n    for (const cell of cells) {\n      const colspan = cell.colSpan || 1;\n      if (index < colNums) {\n        const cellWidth = getCellWidth(cell);\n        for (let i = 0; i < colspan; i++) {\n          colWidths[index + i] = cellWidth / colspan;\n        }\n      }\n      else {\n        break;\n      }\n      index += colspan;\n    }\n  }\n  return colWidths;\n}\n\nexport class TableClipboard extends Clipboard {\n  tableId = randomId();\n  rowId = randomId();\n  colIds: string[] = [];\n  rowspanCount: { rowspan: number; colspan: number }[] = [];\n  cellCount = 0;\n  colCount = 0;\n  constructor(public quill: Quill, options: Partial<ClipboardOptions>) {\n    super(quill, options);\n    this.addMatcher('table', this.matchTable.bind(this));\n    this.addMatcher('thead', this.matchThead.bind(this));\n    this.addMatcher('tbody', this.matchTbody.bind(this));\n    this.addMatcher('tfoot', this.matchTfoot.bind(this));\n    this.addMatcher('colgroup', this.matchColgroup.bind(this));\n    this.addMatcher('col', this.matchCol.bind(this));\n    this.addMatcher('tr', this.matchTr.bind(this));\n    this.addMatcher('td', this.matchTd.bind(this));\n    this.addMatcher('th', this.matchTd.bind(this));\n    this.addMatcher('caption', this.matchCaption.bind(this));\n\n    this.addMatcher(Node.ELEMENT_NODE, this.matchTdAttributor.bind(this));\n  }\n\n  getStyleBackgroundColor(node: Node, delta: TypeDelta) {\n    const backgroundColor = (node as HTMLElement).style.backgroundColor;\n    if (backgroundColor) {\n      for (const op of delta.ops) {\n        if (op.attributes?.[blotName.tableCellInner]) {\n          const { style, ...value } = op.attributes[blotName.tableCellInner] as TableCellValue;\n          const styleObj = cssTextToObject(style || '');\n          if (!styleObj.backgroundColor) {\n            styleObj.backgroundColor = backgroundColor;\n            op.attributes[blotName.tableCellInner] = { ...value, style: objectToCssText(styleObj) };\n          }\n        }\n      }\n    }\n  }\n\n  matchTable(node: Node, delta: TypeDelta) {\n    if (delta.ops.length === 0) return delta;\n\n    const ops: Record<string, any>[] = [];\n    const cols: Record<string, any>[] = [];\n    let bodyStartIndex = -1;\n    for (let i = 0; i < delta.ops.length; i++) {\n      const { attributes, insert } = delta.ops[i];\n      // if attribute doesn't have tableCellInner, treat it as a blank line(emptyRow)\n      if (!isObject(insert) && (!attributes || (!attributes[blotName.tableCellInner] && !attributes[blotName.tableCaption]))) {\n        delta.ops.splice(i, 1);\n        i -= 1;\n        continue;\n      }\n      // remove quill origin table format and tableCell format\n      const { table, [blotName.tableCell]: tableCell, ...attrs } = attributes || {};\n      const hasCol = isObject(insert) && insert[blotName.tableCol];\n      if (hasCol) {\n        cols.push({ insert });\n      }\n      else {\n        ops.push({ attributes: attrs, insert });\n      }\n      // record col insert index\n      if (\n        !attrs?.[blotName.tableCellInner]\n        && !attrs?.[blotName.tableCaption]\n        && !hasCol\n        && isString(insert)\n        && insert.trim().length > 0\n      ) {\n        bodyStartIndex = i;\n      }\n    }\n\n    const colWidths = calculateCols(node as HTMLElement, this.colIds.length);\n    const newCols = colWidths.reduce((colOps, width, i) => {\n      if (!cols[i]) {\n        colOps.push({\n          insert: {\n            [blotName.tableCol]: {\n              tableId: this.tableId,\n              colId: this.colIds[i],\n              width,\n              full: false,\n            },\n          },\n        });\n      }\n      else {\n        colOps.push(cols[i]);\n      }\n      return colOps;\n    }, [] as Record<string, any>[]);\n    ops.splice(bodyStartIndex + 1, 0, ...newCols);\n\n    const resultDelta = new Delta(ops);\n    this.getStyleBackgroundColor(node, resultDelta);\n    // reset variable to avoid conflict with other table\n    this.tableId = randomId();\n    this.colIds = [];\n    this.rowspanCount = [];\n    this.cellCount = 0;\n    this.colCount = 0;\n    return resultDelta;\n  }\n\n  matchTbody(node: Node, delta: TypeDelta) {\n    this.getStyleBackgroundColor(node, delta);\n    // add `emptyRow`\n    let emptyRows = [];\n    for (let i = delta.ops.length - 1; i >= 0; i--) {\n      const op = delta.ops[i];\n      if (!op.attributes?.[blotName.tableCellInner]) {\n        emptyRows = [];\n        const lineCount = op.insert\n          ? isString(op.insert)\n            ? op.insert.split('\\n').length - 1\n            : 1\n          : 0;\n        for (let i = 0; i < lineCount; i++) {\n          emptyRows.push(randomId());\n        }\n      }\n      else if (op.attributes) {\n        const cellValue = op.attributes[blotName.tableCellInner] as TableCellValue;\n        if (cellValue.rowspan === 1) {\n          emptyRows = [];\n        }\n        else if (emptyRows.length > 0) {\n          if (!cellValue.emptyRow) {\n            cellValue.emptyRow = [];\n          }\n          if (emptyRows.length > cellValue.emptyRow.length) {\n            cellValue.emptyRow!.push(...emptyRows.slice(cellValue.emptyRow.length - emptyRows.length));\n          }\n        }\n      }\n    }\n    // clear rowspan. thead/tbody/tfoot will not share rowspan\n    this.rowspanCount = [];\n    return delta;\n  }\n\n  matchThead(node: Node, delta: TypeDelta) {\n    const deltaData = this.matchTbody(node, delta);\n    for (const op of deltaData.ops) {\n      if (op.attributes?.[blotName.tableCellInner]) {\n        const tableCellInner = op.attributes[blotName.tableCellInner] as TableCellValue;\n        tableCellInner.wrapTag = 'thead';\n      }\n    }\n    return deltaData;\n  }\n\n  matchTfoot(node: Node, delta: TypeDelta) {\n    const deltaData = this.matchTbody(node, delta);\n    for (const op of deltaData.ops) {\n      if (op.attributes?.[blotName.tableCellInner]) {\n        const tableCellInner = op.attributes[blotName.tableCellInner] as TableCellValue;\n        tableCellInner.wrapTag = 'tfoot';\n      }\n    }\n    return deltaData;\n  }\n\n  matchColgroup(node: Node, delta: TypeDelta) {\n    const ops: Record<string, any>[] = [];\n    for (const op of delta.ops) {\n      if (op && isObject(op.insert) && op.insert[blotName.tableCol]) {\n        ops.push(op);\n      }\n    }\n    return new Delta(ops);\n  }\n\n  matchCol(node: Node, _delta: TypeDelta) {\n    // split col by span\n    let span = Number((node as HTMLElement).getAttribute('span') || 1);\n    if (Number.isNaN(span)) span = 1;\n\n    const colDelta = new Delta();\n    for (let i = 0; i < span; i++) {\n      this.colIds[this.colCount] = randomId();\n      colDelta.insert({\n        [blotName.tableCol]: Object.assign(\n          TableColFormat.value(node as HTMLElement),\n          {\n            tableId: this.tableId,\n            colId: this.colIds[this.colCount],\n          },\n        ),\n      });\n      this.colCount += 1;\n    }\n    return colDelta;\n  }\n\n  matchTr(node: Node, delta: TypeDelta) {\n    this.rowId = randomId();\n    this.cellCount = 0;\n    // minus rowspan\n    for (const [i, span] of this.rowspanCount.entries()) {\n      if (span.rowspan > 0) {\n        span.rowspan -= 1;\n      }\n      if (span.rowspan <= 0) {\n        this.rowspanCount[i] = { rowspan: 0, colspan: 0 };\n      }\n    }\n    this.getStyleBackgroundColor(node, delta);\n    // if delta.ops is empty, return a new line. make sure emptyRow parse correctly in `matchTbody`\n    return delta.ops.length === 0 ? new Delta([{ insert: '\\n' }]) : delta;\n  }\n\n  matchTd(node: Node, delta: TypeDelta) {\n    const cell = node as HTMLElement;\n    const cellFormat = TableCellFormat.formats(cell);\n    if (!this.colIds[this.cellCount] || !this.rowspanCount[this.cellCount]) {\n      for (let i = this.cellCount; i >= 0; i--) {\n        if (!this.colIds[i]) {\n          this.colIds[i] = randomId();\n        }\n        if (!this.rowspanCount[i]) {\n          this.rowspanCount[i] = { rowspan: 0, colspan: 0 };\n        }\n      }\n    }\n    // skip the colspan of the cell in the previous row\n    for (let i = this.cellCount; i < this.rowspanCount.length; i++) {\n      const { rowspan, colspan } = this.rowspanCount[i];\n      if (rowspan === 0) break;\n      this.cellCount += colspan;\n    }\n    // add current cell rowspan in `rowspanCount` to calculate next row cell\n    if (cellFormat.rowspan > 1) {\n      this.rowspanCount[this.cellCount] = { rowspan: cellFormat.rowspan, colspan: cellFormat.colspan };\n    }\n    const colId = this.colIds[this.cellCount];\n    this.cellCount += cellFormat.colspan;\n\n    // add each insert tableCellInner format\n    const value = Object.assign(\n      cellFormat,\n      {\n        tableId: this.tableId,\n        rowId: this.rowId,\n        colId,\n      },\n    );\n    // make sure <!--[if !supportMisalignedColumns]--> display border\n    if (cell.style.border === 'none') {\n      value.style = value.style.replaceAll(/border-(top|right|bottom|left)-style:none;?/g, '');\n    }\n    const ops = [];\n    for (const op of delta.ops) {\n      const { attributes = {}, ...other } = op;\n      const { [blotName.tableCell]: tableCell, ...attrs } = attributes;\n      ops.push({ ...other, attributes: { ...attrs, [blotName.tableCellInner]: value } });\n    }\n    if (ops.length <= 0 || !isString(ops[ops.length - 1].insert) || !(ops[ops.length - 1].insert as string).endsWith('\\n')) {\n      ops.push({ insert: '\\n', attributes: { [blotName.tableCellInner]: value } });\n    }\n    return new Delta(ops);\n  }\n\n  matchTdAttributor(node: Node, delta: TypeDelta) {\n    const el = node as HTMLElement;\n    if (el.tagName.toLocaleLowerCase() === 'td') {\n      const ops = [];\n      for (const op of delta.ops) {\n        const { attributes, ...other } = op;\n        const tableCellInner = attributes?.[blotName.tableCellInner] as TableCellValue;\n        if (attributes && tableCellInner?.style) {\n          const { background, ...attrs } = attributes;\n\n          const bgTemp = document.createElement('div');\n          bgTemp.style.background = background as string;\n          const cellTemp = document.createElement('div');\n          cellTemp.style.cssText = tableCellInner.style;\n          if (bgTemp.style.background === cellTemp.style.backgroundColor) {\n            ops.push({ ...other, attributes: { ...attrs } });\n            continue;\n          }\n        }\n\n        ops.push(op);\n      }\n      return new Delta(ops);\n    }\n\n    return delta;\n  }\n\n  convert(\n    { html, text }: { html?: string; text?: string },\n    formats: Record<string, unknown> = {},\n  ): TypeDelta {\n    const delta = super.convert({ html, text }, formats);\n    if (formats[blotName.tableCellInner]) {\n      for (const op of delta.ops) {\n        if (isObject(op.insert) && op.insert[blotName.tableCol]) {\n          op.insert = '';\n          continue;\n        }\n        if (!op.attributes) op.attributes = {};\n        op.attributes[blotName.tableCellInner] = formats[blotName.tableCellInner];\n      }\n    }\n    return delta;\n  }\n\n  matchCaption(node: Node, delta: TypeDelta) {\n    for (const op of delta.ops) {\n      const { attributes } = op;\n      if (attributes?.[blotName.tableCaption]) {\n        (attributes[blotName.tableCaption] as TableCaptionValue).tableId = this.tableId;\n        op.attributes = attributes;\n      }\n    }\n\n    return delta;\n  }\n}\n","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <!-- Icon from Tabler Icons by Pawe Kuna - https://github.com/tabler/tabler-icons/blob/master/LICENSE -->\\n  <path\\n    fill=\\\"none\\\"\\n    stroke=\\\"currentColor\\\"\\n    stroke-linecap=\\\"round\\\"\\n    stroke-linejoin=\\\"round\\\"\\n    stroke-width=\\\"2\\\"\\n    d=\\\"M4 12V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v6m-10 6H3m18 0h-7m-8-3l-3 3l3 3m12-6l3 3l-3 3\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"none\\\"\\n    stroke=\\\"currentColor\\\"\\n    stroke-linecap=\\\"round\\\"\\n    stroke-linejoin=\\\"round\\\"\\n    stroke-width=\\\"2\\\"\\n    d=\\\"m4 8l4-4m6 0L4 14m0 6L20 4m0 6L10 20m10-4l-4 4\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"none\\\"\\n    stroke=\\\"currentColor\\\"\\n    stroke-linecap=\\\"round\\\"\\n    stroke-linejoin=\\\"round\\\"\\n    stroke-width=\\\"1.5\\\"\\n    d=\\\"m12.01 16l-.01.011M12.01 12l-.01.011M12.01 8l-.01.011M8.01 12l-.01.011M16.01 12l-.01.011M21 3.6v16.8a.6.6 0 0 1-.6.6H3.6a.6.6 0 0 1-.6-.6V3.6a.6.6 0 0 1 .6-.6h16.8a.6.6 0 0 1 .6.6\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <!-- Icon from Material Symbols by Google - https://github.com/google/material-design-icons/blob/master/LICENSE -->\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"M11 21V9H3V5q0-.825.588-1.412T5 3h14q.825 0 1.413.588T21 5v14q0 .825-.587 1.413T19 21zm2-2h6v-4h-6zm0-6h6V9h-6zM5 7h14V5H5zM3 22v-2h2.55q-1.2-.575-1.937-1.7t-.738-2.55q0-1.975 1.388-3.363T7.625 11v2q-1.125 0-1.937.8t-.813 1.95q0 .975.6 1.725t1.525.95V16h2v6z\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 256 256\\\">\\n  <g fill=\\\"currentColor\\\">\\n    <path d=\\\"M216 40v128h-48V88H88V40Z\\\" opacity=\\\".2\\\" />\\n    <path\\n      d=\\\"M216 32H88a8 8 0 0 0-8 8v40H40a8 8 0 0 0-8 8v128a8 8 0 0 0 8 8h128a8 8 0 0 0 8-8v-40h40a8 8 0 0 0 8-8V40a8 8 0 0 0-8-8m-56 176H48V96h112Zm48-48h-32V88a8 8 0 0 0-8-8H96V48h112Z\\\"\\n    />\\n  </g>\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 32 32\\\">\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"m19.05 13.733l-1-1.733l-10.122 5.846l-.997-.576a3 3 0 0 0 .667-.769A3 3 0 1 0 3.5 17.599L5.928 19L3.5 20.402a3.034 3.034 0 1 0 3.44.323l.988-.57L14.59 24l1-1.73L9.928 19zM4.034 15.26a1 1 0 1 1 .466.607a1 1 0 0 1-.466-.607M5 22a1 1 0 1 1-.865 1.5A1 1 0 0 1 5 22m12 4h4v2h-4zm-7 0h4v2h-4z\\\"\\n  />\\n  <path fill=\\\"currentColor\\\" d=\\\"M28 28h-4v-2h4V4H7v4H5V4a2 2 0 0 1 2-2h21a2 2 0 0 1 2 2v22a2 2 0 0 1-2 2\\\" />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"M4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4zm11.94 5.5h2v-4h2v4h2l-3 3z\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"M4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4zm14.44 2v2h4v2h-4v2l-3-3z\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"M4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4zm15.44 8v-2h-4v-2h4v-2l3 3z\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"M4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4zm17.94 4.5h-2v4h-2v-4h-2l3-3z\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"M5 10H3V4h8v2H5zm14 8h-6v2h8v-6h-2zM5 18v-4H3v6h8v-2zM21 4h-8v2h6v4h2zM8 13v2l3-3l-3-3v2H3v2zm8-2V9l-3 3l3 3v-2h5v-2z\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"M4 2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2m0 8v4h7v-4zm0 6v4h7v-4zM4 4v4h7V4zm13.59 8L15 9.41L16.41 8L19 10.59L21.59 8L23 9.41L20.41 12L23 14.59L21.59 16L19 13.41L16.41 16L15 14.59z\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"M9.41 13L12 15.59L14.59 13L16 14.41L13.41 17L16 19.59L14.59 21L12 18.41L9.41 21L8 19.59L10.59 17L8 14.41zM22 9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2zM4 9h4V6H4zm6 0h4V6h-4zm6 0h4V6h-4z\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"m15.46 15.88l1.42-1.42L19 16.59l2.12-2.13l1.42 1.42L20.41 18l2.13 2.12l-1.42 1.42L19 19.41l-2.12 2.13l-1.42-1.42L17.59 18zM4 3h14a2 2 0 0 1 2 2v7.08a6 6 0 0 0-4.32.92H12v4h1.08c-.11.68-.11 1.35 0 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2m0 4v4h6V7zm8 0v4h6V7zm-8 6v4h6v-4z\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <path\\n    fill=\\\"currentColor\\\"\\n    d=\\\"M19 14h2v6H3v-6h2v4h14zM3 4v6h2V6h14v4h2V4zm8 7v2H8v2l-3-3l3-3v2zm5 0V9l3 3l-3 3v-2h-3v-2z\\\"\\n  />\\n</svg>\\n\"","\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"1em\\\" height=\\\"1em\\\" viewBox=\\\"0 0 24 24\\\">\\n  <!-- Icon from TDesign Icons by TDesign - https://github.com/Tencent/tdesign-icons/blob/main/LICENSE -->\\n  <path fill=\\\"currentColor\\\" d=\\\"M21 10v12h-2V12H5v10H3V10zm0-8v6H3V2zm-2 2H5v2h14z\\\" />\\n</svg>\\n\"","import type { TableCellInnerFormat, TableMainFormat } from '../../formats';\nimport type { TableUp } from '../../table-up';\nimport type { Tool } from '../../utils';\nimport Quill from 'quill';\nimport AutoFull from '../../svg/auto-full.svg';\nimport Background from '../../svg/background.svg';\nimport Border from '../../svg/border.svg';\nimport ConvertCell from '../../svg/convert-cell.svg';\nimport Copy from '../../svg/copy.svg';\nimport Cut from '../../svg/cut.svg';\nimport InsertBottom from '../../svg/insert-bottom.svg';\nimport InsertLeft from '../../svg/insert-left.svg';\nimport InsertRight from '../../svg/insert-right.svg';\nimport InsertTop from '../../svg/insert-top.svg';\nimport MergeCell from '../../svg/merge-cell.svg';\nimport RemoveColumn from '../../svg/remove-column.svg';\nimport RemoveRow from '../../svg/remove-row.svg';\nimport RemoveTable from '../../svg/remove-table.svg';\nimport SplitCell from '../../svg/split-cell.svg';\nimport TableHead from '../../svg/table-head.svg';\nimport { blotName, createBEM } from '../../utils';\n\nexport const menuColorSelectClassName = 'color-selector';\nexport async function copyCell(tableModule: TableUp, selectedTds: TableCellInnerFormat[], isCut: boolean = false) {\n  const text = tableModule.getTextByCell(selectedTds);\n  const html = tableModule.getHTMLByCell(selectedTds, isCut);\n\n  const clipboardItem = new ClipboardItem({\n    'text/plain': new Blob([text], { type: 'text/plain' }),\n    'text/html': new Blob([html], { type: 'text/html' }),\n  });\n  await navigator.clipboard.write([clipboardItem]);\n}\nexport const tableMenuTools: Record<string, Tool> = {\n  Break: {\n    name: 'break',\n  },\n  CopyCell: {\n    name: 'CopyCell',\n    tip: 'Copy cell',\n    icon: Copy,\n    handle(tableModule, selectedTds) {\n      copyCell.call(this, tableModule, selectedTds, false);\n    },\n  },\n  CutCell: {\n    name: 'CutCell',\n    tip: 'Cut cell',\n    icon: Cut,\n    handle(tableModule, selectedTds) {\n      copyCell.call(this, tableModule, selectedTds, true);\n    },\n  },\n  InsertTop: {\n    name: 'InsertTop',\n    icon: InsertTop,\n    tip: 'Insert row above',\n    handle(tableModule, selectedTds) {\n      tableModule.appendRow(selectedTds, false);\n    },\n  },\n  InsertRight: {\n    name: 'InsertRight',\n    icon: InsertRight,\n    tip: 'Insert column right',\n    handle(tableModule, selectedTds) {\n      tableModule.appendCol(selectedTds, true);\n    },\n  },\n  InsertBottom: {\n    name: 'InsertBottom',\n    icon: InsertBottom,\n    tip: 'Insert row below',\n    handle(tableModule, selectedTds) {\n      tableModule.appendRow(selectedTds, true);\n    },\n  },\n  InsertLeft: {\n    name: 'InsertLeft',\n    icon: InsertLeft,\n    tip: 'Insert column Left',\n    handle(tableModule, selectedTds) {\n      tableModule.appendCol(selectedTds, false);\n    },\n  },\n  MergeCell: {\n    name: 'MergeCell',\n    icon: MergeCell,\n    tip: 'Merge Cell',\n    handle(tableModule, selectedTds) {\n      tableModule.mergeCells(selectedTds);\n    },\n  },\n  SplitCell: {\n    name: 'SplitCell',\n    icon: SplitCell,\n    tip: 'Split Cell',\n    handle(tableModule, selectedTds) {\n      tableModule.splitCell(selectedTds);\n    },\n  },\n  DeleteRow: {\n    name: 'DeleteRow',\n    icon: RemoveRow,\n    tip: 'Delete Row',\n    handle(tableModule, selectedTds) {\n      tableModule.removeRow(selectedTds);\n    },\n  },\n  DeleteColumn: {\n    name: 'DeleteColumn',\n    icon: RemoveColumn,\n    tip: 'Delete Column',\n    handle(tableModule, selectedTds) {\n      tableModule.removeCol(selectedTds);\n    },\n  },\n  DeleteTable: {\n    name: 'DeleteTable',\n    icon: RemoveTable,\n    tip: 'Delete table',\n    handle(tableModule, selectedTds) {\n      tableModule.deleteTable(selectedTds);\n    },\n  },\n  BackgroundColor: {\n    name: 'BackgroundColor',\n    icon: Background,\n    isColorChoose: true,\n    tip: 'Set background color',\n    key: 'background-color',\n    handle(tableModule, selectedTds, color) {\n      tableModule.setCellAttrs(selectedTds, 'background-color', color, true);\n    },\n  },\n  BorderColor: {\n    name: 'BorderColor',\n    icon: Border,\n    isColorChoose: true,\n    tip: 'Set border color',\n    key: 'border-color',\n    handle(tableModule, selectedTds, color) {\n      tableModule.setCellAttrs(selectedTds, 'border-color', color, true);\n    },\n  },\n  SwitchWidth: {\n    name: 'SwitchWidth',\n    icon: AutoFull,\n    tip: 'Switch table width',\n    handle() {\n      if (!this.table) return;\n      const tableMainBlot = Quill.find(this.table) as TableMainFormat;\n      if (!tableMainBlot) return;\n\n      if (tableMainBlot.full) {\n        tableMainBlot.cancelFull();\n      }\n      else {\n        tableMainBlot.setFull();\n      }\n    },\n  },\n  InsertCaption: {\n    name: 'InsertCaption',\n    icon: TableHead,\n    tip: 'Insert table caption',\n    handle() {\n      if (!this.table) return;\n      const tableMainBlot = Quill.find(this.table) as TableMainFormat;\n      if (!tableMainBlot) return;\n\n      const tableCaption = this.quill.scroll.create('text', 'Table Caption').wrap(blotName.tableCaption, {\n        tableId: tableMainBlot.tableId,\n      });\n      tableMainBlot.insertBefore(tableCaption, tableMainBlot.children.head);\n    },\n  },\n  ToggleTdBetweenTh: {\n    name: 'ToggleTdBetweenTh',\n    icon: ConvertCell,\n    tip: 'Toggle td between th',\n    handle(tableModule, selectedTds) {\n      for (const td of selectedTds) {\n        td.convertTableCell();\n      }\n    },\n  },\n  ConvertTothead: {\n    name: 'ConvertTothead',\n    icon: ConvertCell,\n    tip: 'Convert to thead',\n    handle(tableModule, selectedTds) {\n      if (!this.table) return;\n      const tableMainBlot = Quill.find(this.table) as TableMainFormat;\n      if (!tableMainBlot) return;\n\n      tableModule.convertTableBodyByCells(tableMainBlot, selectedTds, 'thead');\n    },\n  },\n  ConvertTotfoot: {\n    name: 'ConvertTotfoot',\n    icon: ConvertCell,\n    tip: 'Convert to tfoot',\n    handle(tableModule, selectedTds) {\n      if (!this.table) return;\n      const tableMainBlot = Quill.find(this.table) as TableMainFormat;\n      if (!tableMainBlot) return;\n\n      tableModule.convertTableBodyByCells(tableMainBlot, selectedTds, 'tfoot');\n    },\n  },\n};\n\nexport const maxSaveColorCount = 10;\nconst bem = createBEM('color-map');\nexport const colorClassName = {\n  selectWrapper: bem.b(),\n  used: bem.bm('used'),\n  item: bem.be('item'),\n  btn: bem.be('btn'),\n  map: bem.be('content'),\n  mapRow: bem.be('content-row'),\n};\n","import type { TableUp } from '../../table-up';\nimport type { TableMenuOptions, ToolOption, TooltipInstance, ToolTipOptions } from '../../utils';\nimport type { TableSelection } from '../table-selection';\nimport Quill from 'quill';\nimport { createBEM, createColorPicker, createTooltip, debounce, defaultColorMap, isArray, isFunction, randomId, tableUpEvent, tableUpInternal } from '../../utils';\nimport { TableDomSelector } from '../table-dom-selector';\nimport { colorClassName, maxSaveColorCount, menuColorSelectClassName, tableMenuTools } from './constants';\n\nexport type TableMenuOptionsInput = Partial<Omit<TableMenuOptions, 'texts'>>;\nexport interface MenuTooltipInstance extends TooltipInstance {\n  isColorPick?: boolean;\n}\nexport class TableMenuCommon extends TableDomSelector {\n  static moduleName = 'table-menu';\n\n  usedColors = new Set<string>();\n  options: TableMenuOptions;\n  menu: HTMLElement | null = null;\n  isMenuDisplay: boolean = false;\n  isColorPicking: boolean = false;\n  tooltipItem: MenuTooltipInstance[] = [];\n  activeTooltip: MenuTooltipInstance | null = null;\n  bem = createBEM('menu');\n  colorItemClass = `color-${randomId()}`;\n  colorChooseTooltipOption: ToolTipOptions = {\n    direction: 'top',\n  };\n\n  constructor(public tableModule: TableUp, public quill: Quill, options: TableMenuOptionsInput) {\n    super(tableModule, quill);\n\n    this.options = this.resolveOptions(options);\n    try {\n      const storageValue = localStorage.getItem(this.options.localstorageKey) || '[]';\n      let colorValue = JSON.parse(storageValue);\n      if (!isArray(colorValue)) {\n        colorValue = [];\n      }\n      colorValue.slice(-1 * maxSaveColorCount).map((c: string) => this.usedColors.add(c));\n    }\n    catch {}\n\n    this.quill.on(Quill.events.EDITOR_CHANGE, this.updateWhenTextChange);\n    this.quill.on(tableUpEvent.TABLE_SELECTION_DRAG_START, this.hideWhenSelectionDragStart);\n  }\n\n  updateUsedColor = debounce((color?: string) => {\n    if (!color) return;\n    this.usedColors.add(color);\n    if (this.usedColors.size > maxSaveColorCount) {\n      const saveColors = Array.from(this.usedColors).slice(-1 * maxSaveColorCount);\n      this.usedColors.clear();\n      saveColors.map(v => this.usedColors.add(v));\n    }\n\n    localStorage.setItem(this.options.localstorageKey, JSON.stringify(Array.from(this.usedColors)));\n    const usedColorWrappers = Array.from(document.querySelectorAll(`.${this.colorItemClass}.${colorClassName.used}`));\n    for (const usedColorWrapper of usedColorWrappers) {\n      const newColorItem = document.createElement('div');\n      newColorItem.classList.add(colorClassName.item);\n      newColorItem.style.backgroundColor = String(color);\n      // if already have same color item. doesn't need insert\n      const sameColorItem = Array.from(usedColorWrapper.querySelectorAll(`.${colorClassName.item}[style*=\"background-color: ${newColorItem.style.backgroundColor}\"]`));\n      if (sameColorItem.length <= 0) {\n        usedColorWrapper.appendChild(newColorItem);\n      }\n\n      const colorItem = Array.from(usedColorWrapper.querySelectorAll(`.${colorClassName.item}`)).slice(0, -1 * maxSaveColorCount);\n      for (const item of colorItem) {\n        item.remove();\n      }\n    }\n  }, 1000);\n\n  hideWhenSelectionDragStart = () => {\n    this.hide();\n  };\n\n  updateWhenTextChange = (eventName: string) => {\n    if (eventName === Quill.events.TEXT_CHANGE && this.isMenuDisplay) {\n      this.update();\n    }\n  };\n\n  resolveOptions(options: TableMenuOptionsInput) {\n    const value = Object.assign({\n      tipText: true,\n      tools: [\n        tableMenuTools.InsertTop,\n        tableMenuTools.InsertRight,\n        tableMenuTools.InsertBottom,\n        tableMenuTools.InsertLeft,\n        tableMenuTools.Break,\n        tableMenuTools.MergeCell,\n        tableMenuTools.SplitCell,\n        tableMenuTools.Break,\n        tableMenuTools.DeleteRow,\n        tableMenuTools.DeleteColumn,\n        tableMenuTools.DeleteTable,\n        tableMenuTools.Break,\n        tableMenuTools.BackgroundColor,\n        tableMenuTools.BorderColor,\n      ],\n      localstorageKey: '__table-bg-used-color',\n      defaultColorMap,\n    }, options);\n    return value as TableMenuOptions;\n  }\n\n  buildTools(): HTMLElement {\n    const toolBox = document.createElement('div');\n    toolBox.classList.add(this.bem.b());\n    Object.assign(toolBox.style, { display: 'flex' });\n    for (const tool of this.options.tools) {\n      const { name, icon, handle, isColorChoose, key: attrKey, tip = '' } = tool as ToolOption;\n      const item = document.createElement('span');\n      item.classList.add(this.bem.be('item'));\n      if (name === 'break') {\n        item.classList.add(this.bem.is('break'));\n      }\n      else {\n        // add icon\n        const iconDom = document.createElement('i');\n        iconDom.classList.add('icon');\n        if (isFunction(icon)) {\n          iconDom.appendChild(icon(this.tableModule));\n        }\n        else {\n          iconDom.innerHTML = icon;\n        }\n        item.appendChild(iconDom);\n\n        if (isColorChoose && attrKey) {\n          const tooltipItem = this.createColorChoose(item, { name, icon, handle, isColorChoose, key: attrKey, tip });\n          this.tooltipItem.push(tooltipItem);\n          item.classList.add(menuColorSelectClassName);\n        }\n        else {\n          isFunction(handle) && item.addEventListener('click', (e) => {\n            this.quill.focus();\n            handle.call(this, this.tableModule, this.getSelectedTds(), e);\n          }, false);\n        }\n\n        // add text\n        const tipText = this.tableModule.options.texts[name] || tip;\n        if (this.options.tipText && tipText && tip) {\n          this.createTipText(item, tipText);\n        }\n      }\n      toolBox.appendChild(item);\n    }\n    return toolBox;\n  }\n\n  createColorChoose(item: HTMLElement, { handle, key }: ToolOption) {\n    const colorSelectWrapper = document.createElement('div');\n    colorSelectWrapper.classList.add(colorClassName.selectWrapper);\n\n    if (this.options.defaultColorMap.length > 0) {\n      const colorMap = document.createElement('div');\n      colorMap.classList.add(colorClassName.map);\n      for (const colors of this.options.defaultColorMap) {\n        const colorMapRow = document.createElement('div');\n        colorMapRow.classList.add(colorClassName.mapRow);\n        for (const color of colors) {\n          const colorItem = document.createElement('div');\n          colorItem.classList.add(colorClassName.item);\n          colorItem.style.backgroundColor = color;\n          colorMapRow.appendChild(colorItem);\n        }\n        colorMap.appendChild(colorMapRow);\n      }\n      colorSelectWrapper.appendChild(colorMap);\n    }\n\n    const colorMapRow = document.createElement('div');\n    colorMapRow.classList.add(colorClassName.mapRow);\n    Object.assign(colorMapRow.style, {\n      marginTop: '4px',\n    });\n    const transparentColor = document.createElement('div');\n    transparentColor.classList.add(colorClassName.btn, 'transparent');\n    transparentColor.textContent = this.tableModule.options.texts.transparent;\n    transparentColor.addEventListener('click', () => {\n      handle.call(this, this.tableModule, this.getSelectedTds(), 'transparent');\n    });\n    const clearColor = document.createElement('div');\n    clearColor.classList.add(colorClassName.btn, 'clear');\n    clearColor.textContent = this.tableModule.options.texts.clear;\n    clearColor.addEventListener('click', () => {\n      handle.call(this, this.tableModule, this.getSelectedTds(), null);\n    });\n    const customColor = document.createElement('div');\n    customColor.classList.add(colorClassName.btn, 'custom');\n    customColor.textContent = this.tableModule.options.texts.custom;\n    const colorPicker = createColorPicker({\n      onChange: (color) => {\n        handle.call(this, this.tableModule, this.getSelectedTds(), color);\n        this.updateUsedColor(color);\n      },\n    });\n    const { hide: hideColorPicker, destroy: destroyColorPicker } = createTooltip(customColor, {\n      direction: 'right',\n      type: 'click',\n      content: colorPicker,\n      container: customColor,\n    })!;\n\n    colorMapRow.appendChild(transparentColor);\n    colorMapRow.appendChild(clearColor);\n    colorMapRow.appendChild(customColor);\n    colorSelectWrapper.appendChild(colorMapRow);\n\n    const usedColorWrap = document.createElement('div');\n    usedColorWrap.classList.add(colorClassName.used, this.colorItemClass);\n    for (const recordColor of this.usedColors) {\n      const colorItem = document.createElement('div');\n      colorItem.classList.add(colorClassName.item);\n      colorItem.style.backgroundColor = recordColor;\n      usedColorWrap.appendChild(colorItem);\n    }\n    colorSelectWrapper.appendChild(usedColorWrap);\n\n    colorSelectWrapper.addEventListener('click', (e) => {\n      e.stopPropagation();\n      hideColorPicker();\n      const item = e.target as HTMLElement;\n      const color = item.style.backgroundColor;\n      const selectedTds = this.getSelectedTds();\n      if (item && color && selectedTds.length > 0) {\n        this.tableModule.setCellAttrs(selectedTds, key!, color, true);\n        if (!item.closest(`.${colorClassName.item}`)) return;\n        this.updateUsedColor(color);\n      }\n    });\n\n    // get tooltip instance. makesure color picker only display one at time\n    const tooltip: MenuTooltipInstance = createTooltip(item, {\n      ...this.colorChooseTooltipOption,\n      type: 'click',\n      content: colorSelectWrapper,\n      container: this.quill.container,\n      onOpen: () => {\n        const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n        if (this.isMenuDisplay && tableSelection) {\n          tableSelection.hideDisplay();\n        }\n        this.setActiveTooltip(tooltip);\n        return false;\n      },\n      onClose: () => {\n        const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n        if (this.isMenuDisplay && tableSelection) {\n          tableSelection.updateWithSelectedTds();\n          tableSelection.showDisplay();\n        }\n        const isChild = colorSelectWrapper.contains(colorPicker);\n        if (isChild) {\n          hideColorPicker();\n        }\n        if (this.activeTooltip === tooltip) {\n          this.activeTooltip = null;\n        }\n        return false;\n      },\n      onDestroy: () => {\n        destroyColorPicker();\n        if (this.activeTooltip === tooltip) {\n          this.activeTooltip = null;\n        }\n      },\n    })!;\n    tooltip.isColorPick = true;\n    return tooltip;\n  }\n\n  setActiveTooltip(tooltip: MenuTooltipInstance | null) {\n    if (this.activeTooltip && this.activeTooltip !== tooltip) {\n      this.activeTooltip.hide(true);\n    }\n    this.activeTooltip = tooltip;\n  }\n\n  getSelectedTds() {\n    const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n    return tableSelection?.selectedTds || [];\n  }\n\n  createTipText(item: HTMLElement, text: string) {\n    const tipTextDom = createTooltip(item, { msg: text, container: this.quill.container });\n    tipTextDom && this.tooltipItem.push(tipTextDom);\n  }\n\n  show() {\n    if (!this.table) return;\n    if (this.menu) {\n      this.hide();\n    }\n    this.menu = this.buildTools();\n  }\n\n  update() {\n    if (this.table && !this.quill.root.contains(this.table)) {\n      this.setSelectionTable(undefined);\n    }\n  }\n\n  hide() {\n    if (this.menu) {\n      this.menu.remove();\n      this.menu = null;\n    }\n    for (const tooltip of this.tooltipItem) {\n      tooltip.hide(true);\n    }\n    this.isMenuDisplay = false;\n  }\n\n  destroy() {\n    this.quill.off(Quill.events.TEXT_CHANGE, this.updateWhenTextChange);\n    this.quill.off(tableUpEvent.TABLE_SELECTION_DRAG_START, this.hideWhenSelectionDragStart);\n    this.activeTooltip = null;\n    for (const tooltip of this.tooltipItem) {\n      tooltip.destroy();\n    }\n    this.tooltipItem = [];\n    this.hide();\n  }\n}\n","import type Quill from 'quill';\nimport type { TableUp } from '../../table-up';\nimport type { InternalTableSelectionModule, Position, TableMenuOptions } from '../../utils';\nimport type { TableSelection } from '../table-selection';\nimport { addScrollEvent, clearScrollEvent, limitDomInViewPort, tableUpEvent, tableUpInternal } from '../../utils';\nimport { menuColorSelectClassName } from './constants';\nimport { TableMenuCommon } from './table-menu-common';\n\ntype TableMenuOptionsInput = Partial<Omit<TableMenuOptions, 'texts'>>;\nexport class TableMenuContextmenu extends TableMenuCommon {\n  static moduleName = 'table-menu-contextmenu';\n\n  scrollHandler: [HTMLElement, (e: Event) => void][] = [];\n\n  constructor(public tableModule: TableUp, public quill: Quill, options: TableMenuOptionsInput) {\n    super(tableModule, quill, options);\n\n    this.quill.root.addEventListener('contextmenu', this.listenContextmenu);\n    this.quill.on(tableUpEvent.TABLE_SELECTION_CHANGE, this.tableSelectioChange);\n    this.quill.on(tableUpEvent.TABLE_SELECTION_DISPLAY_CHANGE, this.tableSelectioChange);\n  }\n\n  tableSelectioChange = (tableSelection: InternalTableSelectionModule) => {\n    if (tableSelection.selectedTds.length <= 0) {\n      this.hide();\n    }\n  };\n\n  listenContextmenu = (e: MouseEvent) => {\n    e.preventDefault();\n\n    const path = e.composedPath() as HTMLElement[];\n    if (!path || path.length <= 0) return;\n\n    const tableNode = path.find(node => node.tagName && node.tagName.toUpperCase() === 'TABLE' && node.classList.contains('ql-table'));\n\n    const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n    if (tableNode && tableSelection?.selectedTds?.length) {\n      if (!this.menu) {\n        this.menu = this.buildTools();\n      }\n      // manual call menu show\n      this.isMenuDisplay = true;\n      this.update({ x: e.clientX, y: e.clientY });\n      const tempHide = () => {\n        this.hide();\n        clearScrollEvent.call(this);\n      };\n      addScrollEvent.call(this, this.quill.root, tempHide);\n      document.addEventListener('click', tempHide, { once: true });\n    }\n    else {\n      this.hide();\n    }\n  };\n\n  buildTools(): HTMLElement {\n    const menu = super.buildTools();\n    menu.classList.add(this.bem.is('contextmenu'));\n    const items = menu.getElementsByClassName(menuColorSelectClassName);\n    for (const item of Array.from(items)) {\n      item.addEventListener('click', e => e.stopPropagation());\n    }\n    this.quill.container.appendChild(menu);\n    return menu;\n  }\n\n  createTipText(item: HTMLElement, text: string): void {\n    const tipTextDom = document.createElement('span');\n    tipTextDom.textContent = text;\n    item.appendChild(tipTextDom);\n  }\n\n  // override show. because TableSelection will call tableMenu.show() after select td\n  show() {}\n\n  update(position?: Position) {\n    super.update();\n    const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n    if (!this.table || !this.isMenuDisplay || !this.menu) {\n      this.hide();\n      return;\n    }\n    if (!position || !tableSelection?.isDisplaySelection) {\n      return;\n    }\n\n    const rootRect = this.quill.container.getBoundingClientRect();\n    Object.assign(this.menu.style, {\n      left: `${position.x - rootRect.x}px`,\n      top: `${position.y - rootRect.y}px`,\n    });\n\n    // limit menu in viewport\n    const menuRect = this.menu.getBoundingClientRect();\n    const { left: limitLeft, top: limitTop } = limitDomInViewPort(menuRect);\n    const diffX = menuRect.left - limitLeft;\n    const diffY = menuRect.top - limitTop;\n    Object.assign(this.menu.style, {\n      left: `${position.x - rootRect.x - diffX}px`,\n      top: `${position.y - rootRect.y - diffY}px`,\n    });\n  }\n\n  destroy() {\n    this.quill.root.removeEventListener('contextmenu', this.listenContextmenu);\n    super.destroy();\n    this.quill.off(tableUpEvent.TABLE_SELECTION_CHANGE, this.tableSelectioChange);\n    this.quill.off(tableUpEvent.TABLE_SELECTION_DISPLAY_CHANGE, this.tableSelectioChange);\n  }\n}\n","import type Quill from 'quill';\nimport type { TableCellInnerFormat } from '../../formats';\nimport type { TableUp } from '../../table-up';\nimport type { InternalTableSelectionModule } from '../../utils';\nimport type { TableSelection } from '../table-selection';\nimport type { TableMenuOptionsInput } from './table-menu-common';\nimport { computePosition, flip, limitShift, offset, shift } from '@floating-ui/dom';\nimport { tableUpEvent, tableUpInternal } from '../../utils';\nimport { TableMenuCommon } from './table-menu-common';\n\nexport class TableMenuSelect extends TableMenuCommon {\n  static moduleName = 'table-menu-select';\n\n  constructor(public tableModule: TableUp, public quill: Quill, options: TableMenuOptionsInput) {\n    super(tableModule, quill, options);\n\n    this.quill.on(tableUpEvent.TABLE_SELECTION_DRAG_START, this.tableSelectionDragStart);\n    this.quill.on(tableUpEvent.TABLE_SELECTION_DRAG_END, this.tableSelectionDragEnd);\n    this.quill.on(tableUpEvent.TABLE_SELECTION_CHANGE, this.tableSelectioChange);\n    this.quill.on(tableUpEvent.TABLE_SELECTION_DISPLAY_CHANGE, this.tableSelectionDisplayChange);\n  }\n\n  tableSelectionDragStart = () => {\n    this.hide();\n  };\n\n  tableSelectionDragEnd = (tableSelection: InternalTableSelectionModule) => {\n    if (tableSelection.selectedTds.length > 0) {\n      this.show();\n    }\n  };\n\n  tableSelectioChange = (tableSelection: InternalTableSelectionModule, selectedTds: TableCellInnerFormat[]) => {\n    if (selectedTds.length <= 0) {\n      this.hide();\n    }\n  };\n\n  tableSelectionDisplayChange = (tableSelection: InternalTableSelectionModule) => {\n    if (!tableSelection.dragging) {\n      this.update();\n    }\n  };\n\n  buildTools(): HTMLElement {\n    const menu = super.buildTools();\n    this.tableModule.addContainer(menu);\n    return menu;\n  }\n\n  show() {\n    super.show();\n    this.update();\n  }\n\n  update() {\n    super.update();\n    if (!this.menu && this.table) {\n      this.show();\n      return;\n    }\n    const selectedTds = this.getSelectedTds();\n    if (!this.menu || !this.table || selectedTds.length === 0) {\n      if (this.menu || !this.table) {\n        this.isMenuDisplay = false;\n        this.menu?.classList.add(this.bem.is('hidden'));\n        this.hide();\n      }\n      return;\n    }\n    this.isMenuDisplay = true;\n    this.menu.classList.remove(this.bem.is('hidden'));\n\n    const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n    if (tableSelection?.isDisplaySelection) {\n      computePosition(tableSelection.cellSelect, this.menu, {\n        placement: 'bottom',\n        middleware: [flip(), shift({ limiter: limitShift() }), offset(20)],\n      }).then(({ x, y }) => {\n        if (this.menu) {\n          Object.assign(this.menu.style, {\n            left: `${x}px`,\n            top: `${y}px`,\n          });\n        }\n      });\n    }\n  }\n\n  destroy(): void {\n    super.destroy();\n\n    this.quill.off(tableUpEvent.TABLE_SELECTION_DRAG_START, this.tableSelectionDragStart);\n    this.quill.off(tableUpEvent.TABLE_SELECTION_DRAG_END, this.tableSelectionDragEnd);\n  }\n}\n","import type { TableCellInnerFormat, TableColFormat, TableMainFormat } from '../../formats';\n\nexport const isTableAlignRight = (tableMainBlot: TableMainFormat) => !tableMainBlot.full && tableMainBlot.align === 'right';\nexport function getColRect(cols: TableColFormat[], columnIndex: number) {\n  // fix browser compatibility, get column rect left/x inaccurate\n  if (columnIndex < 0 || columnIndex >= cols.length) return null;\n\n  // calculate column position\n  let left = cols[0].domNode.getBoundingClientRect().left;\n  for (let i = 0; i < columnIndex; i++) {\n    const colRect = cols[i].domNode.getBoundingClientRect();\n    left += colRect.width;\n  }\n\n  const currentCol = cols[columnIndex];\n  const colWidth = currentCol.domNode.getBoundingClientRect().width;\n\n  return {\n    left,\n    right: left + colWidth,\n    width: colWidth,\n  };\n}\n\nexport function isCellsSpan(isX: boolean, tableBlot: TableMainFormat, cells: TableCellInnerFormat[]) {\n  if (isX) {\n    // if cells have span all rows\n    const cols = tableBlot.getCols();\n    const colIds = cols.map(col => col.colId);\n    const countColIds = new Set<string>();\n    const countRowspan = new Map<string, number>(colIds.map(id => [id, 0]));\n    const cellIndex = new Set<number>();\n    for (const cell of cells) {\n      countColIds.add(cell.colId);\n      const colIndex = colIds.indexOf(cell.colId);\n      if (colIndex === -1) continue;\n      for (let i = colIndex; i < colIndex + cell.colspan && i < colIds.length; i++) {\n        cellIndex.add(i);\n        const id = colIds[i];\n        countRowspan.set(id, (countRowspan.get(id) || 0) + cell.rowspan);\n      }\n      cellIndex.add(Math.min(colIndex + cell.colspan, colIds.length));\n    }\n    const rowCount = tableBlot.getRows()?.length || 0;\n    for (const [id, count] of countRowspan.entries()) {\n      if (count >= rowCount) {\n        countColIds.delete(id);\n      }\n    }\n    return {\n      cellIndex,\n      isSpan: countColIds.size <= 0,\n    };\n  }\n  else {\n    // if cells have span all columns\n    const rows = tableBlot.getRows();\n    const rowIds = rows.map(row => row.rowId);\n    const countRowIds = new Set<string>();\n    const countRowspan = new Map<string, number>(rowIds.map(id => [id, 0]));\n    const cellIndex = new Set<number>();\n    for (const cell of cells) {\n      countRowIds.add(cell.rowId);\n      const rowIndex = rowIds.indexOf(cell.rowId);\n      if (rowIndex === -1) continue;\n      for (let i = rowIndex; i < rowIndex + cell.rowspan && i < rowIds.length; i++) {\n        cellIndex.add(i);\n        const id = rowIds[i];\n        countRowspan.set(id, (countRowspan.get(id) || 0) + cell.colspan);\n      }\n      cellIndex.add(Math.min(rowIndex + cell.rowspan, rowIds.length));\n    }\n    const colCount = tableBlot.getCols()?.length || 0;\n    for (const [id, count] of countRowspan.entries()) {\n      if (count >= colCount) {\n        countRowIds.delete(id);\n      }\n    }\n    return {\n      cellIndex,\n      isSpan: countRowIds.size <= 0,\n    };\n  }\n}\n","import type Quill from 'quill';\nimport type { TableColFormat, TableMainFormat, TableRowFormat } from '../../formats';\nimport type { TableUp } from '../../table-up';\nimport { getTableMainRect } from '../../formats';\nimport { createBEM, createConfirmDialog, tableUpEvent, tableUpSize } from '../../utils';\nimport { TableDomSelector } from '../table-dom-selector';\nimport { getColRect, isTableAlignRight } from './utils';\n\nexport class TableResizeCommonHelper {\n  maxRange: number = Number.POSITIVE_INFINITY;\n  minRange: number = Number.NEGATIVE_INFINITY;\n  startValue: number = 0;\n  dragBreak: HTMLElement | null = null;\n  tableModule: TableUp;\n  isX: boolean = false;\n\n  constructor(tableModule: TableUp, isX: boolean) {\n    this.tableModule = tableModule;\n    this.isX = isX;\n  }\n\n  createBreak() {\n    if (this.dragBreak) this.dragBreak.remove();\n    const dragBEM = createBEM('drag');\n    this.dragBreak = this.tableModule.addContainer(dragBEM.be('line'));\n    this.dragBreak.classList.add(dragBEM.is(this.isX ? 'col' : 'row'));\n  }\n\n  getOffsetFromStart(tableBlot?: TableMainFormat) {\n    let offset = 0;\n    if (!tableBlot) return offset;\n    const { rect: tableRect } = getTableMainRect(tableBlot);\n    if (tableRect) {\n      offset = tableRect[this.isX ? 'x' : 'y'] - this.startValue;\n    }\n    return offset;\n  }\n\n  limitRange(tableBlot: TableMainFormat | undefined, value: number, countScroll: boolean = true) {\n    // position base viewport. offset minus the scroll distance when dragging\n    let offset = 0;\n    if (countScroll) {\n      offset = this.getOffsetFromStart(tableBlot);\n    }\n    return Math.min(this.maxRange + offset, Math.max(value, this.minRange + offset));\n  }\n}\n\nexport class TableResizeCommon extends TableDomSelector {\n  tableBlot?: TableMainFormat;\n  dragging = false;\n  colIndex: number = -1;\n  rowIndex: number = -1;\n  dragXCommon: TableResizeCommonHelper;\n  dragYCommon: TableResizeCommonHelper;\n  constructor(public tableModule: TableUp, public quill: Quill) {\n    super(tableModule, quill);\n\n    this.dragXCommon = new TableResizeCommonHelper(tableModule, true);\n    this.dragYCommon = new TableResizeCommonHelper(tableModule, false);\n  }\n\n  findDragColIndex(_cols: TableColFormat[]) {\n    // implementation is required\n    return -1;\n  }\n\n  calculateColDragRangeByFull() {\n    if (!this.tableBlot) return;\n    const { rect: tableRect } = getTableMainRect(this.tableBlot);\n    if (!tableRect) return;\n    const cols = this.tableBlot.getCols();\n    this.colIndex = this.findDragColIndex(cols);\n    if (this.colIndex === -1) return;\n    const changeColRect = getColRect(cols, this.colIndex)!;\n    // table full not handle align right\n    // max width = current col.width + next col.width - minColLeft\n    const minWidth = (tableUpSize.colMinWidthPre / 100) * tableRect.width;\n    // if current col is last. max width = current col.width\n    let maxRange = tableRect.right;\n    if (cols[this.colIndex + 1]) {\n      maxRange = Math.max(getColRect(cols, this.colIndex + 1)!.right - minWidth, changeColRect.left + minWidth);\n    }\n    const minRange = changeColRect.left + minWidth;\n    this.dragXCommon.minRange = minRange;\n    this.dragXCommon.maxRange = maxRange;\n  }\n\n  calculateColDragRangeByFixed() {\n    if (!this.tableBlot) return;\n    const cols = this.tableBlot.getCols();\n    this.colIndex = this.findDragColIndex(cols);\n    if (this.colIndex === -1) return;\n    const changeColRect = getColRect(cols, this.colIndex)!;\n    // when table align right, mousemove to the left, the col width will be increase\n    this.dragXCommon.minRange = isTableAlignRight(this.tableBlot)\n      ? changeColRect.right - tableUpSize.colMinWidthPx\n      : changeColRect.left + tableUpSize.colMinWidthPx;\n    this.dragXCommon.maxRange = Number.POSITIVE_INFINITY;\n  }\n\n  calculateColDragRange() {\n    if (!this.tableBlot) return;\n    if (this.tableBlot.full) {\n      this.calculateColDragRangeByFull();\n    }\n    else {\n      this.calculateColDragRangeByFixed();\n    }\n  }\n\n  async updateTableCol(left: number) {\n    if (!this.tableBlot || this.colIndex === -1) return;\n    const resultX = this.dragXCommon.limitRange(this.tableBlot, left, true);\n    const cols = this.tableBlot.getCols();\n    const changeColRect = getColRect(cols, this.colIndex)!;\n    let width = resultX - changeColRect.left;\n    if (isTableAlignRight(this.tableBlot)) {\n      width = changeColRect.right - resultX;\n    }\n    let isFull = this.tableBlot.full;\n    let needUpdate = false;\n    const updateInfo: { index: number; width: number }[] = [];\n    if (isFull) {\n      const { rect } = getTableMainRect(this.tableBlot);\n      const tableMainWidth = rect!.width;\n      let pre = (width / tableMainWidth) * 100;\n      const oldWidthPre = cols[this.colIndex].width;\n      if (pre < oldWidthPre) {\n        // minus\n        // if not the last col. add the reduced amount to the next col\n        // if is the last col. add the reduced amount to the pre col\n        pre = Math.max(tableUpSize.colMinWidthPre, pre);\n        if (cols[this.colIndex + 1] || cols[this.colIndex - 1]) {\n          const i = cols[this.colIndex + 1] ? this.colIndex + 1 : this.colIndex - 1;\n          updateInfo.push({ index: i, width: cols[i].width + oldWidthPre - pre });\n        }\n        else {\n          pre = 100;\n        }\n        needUpdate = true;\n        updateInfo.push({ index: this.colIndex, width: pre });\n      }\n      else {\n        // magnify col\n        // the last col can't magnify. control last but one minus to magnify last col\n        if (cols[this.colIndex + 1]) {\n          const totalWidthNextPre = oldWidthPre + cols[this.colIndex + 1].width;\n          pre = Math.min(totalWidthNextPre - tableUpSize.colMinWidthPre, pre);\n\n          const otherColsWidth = cols.reduce((sum, col, idx) =>\n            (idx !== this.colIndex && idx !== this.colIndex + 1) ? sum + col.width : sum, 0\n          );\n          const maxAllowedPre = Math.min(pre, 100 - tableUpSize.colMinWidthPre - otherColsWidth);\n\n          if (maxAllowedPre < pre) {\n            pre = maxAllowedPre;\n          }\n\n          needUpdate = true;\n          updateInfo.push(\n            { index: this.colIndex, width: pre },\n            { index: this.colIndex + 1, width: totalWidthNextPre - pre },\n          );\n        }\n      }\n    }\n    else {\n      this.tableBlot.domNode.style.width = `${\n        Number.parseFloat(this.tableBlot.domNode.style.width)\n        - cols[this.colIndex].domNode.getBoundingClientRect().width\n        + width\n      }px`;\n      needUpdate = true;\n      updateInfo.push({ index: this.colIndex, width });\n    }\n\n    if (needUpdate) {\n      const tableWidth = this.tableBlot.domNode.getBoundingClientRect().width;\n      if (isFull) {\n        // if full table and percentage width is larger than 100%. check if convert to fixed px\n        let resultWidth = 0;\n        const skipColIndex = new Set(updateInfo.map(({ index, width }) => {\n          resultWidth += width;\n          return index;\n        }));\n        for (const [index, col] of cols.entries()) {\n          if (skipColIndex.has(index)) continue;\n          resultWidth += col.width;\n        }\n\n        if (resultWidth > 100) {\n          if (!await createConfirmDialog({\n            message: this.tableModule.options.texts.perWidthInsufficient,\n            confirm: this.tableModule.options.texts.confirmText,\n            cancel: this.tableModule.options.texts.cancelText,\n          })) {\n            return;\n          }\n          this.tableBlot.cancelFull();\n          isFull = false;\n          for (const [i, info] of updateInfo.entries()) {\n            const { width, index } = info;\n            updateInfo[i] = {\n              index,\n              width: width / 100 * tableWidth,\n            };\n          }\n        }\n      }\n\n      for (const { index, width } of updateInfo) {\n        const resultWidth = Number.parseFloat(width.toFixed(3));\n        cols[index].width = `${resultWidth}${isFull ? '%' : 'px'}`;\n      }\n      this.quill.emitter.emit(tableUpEvent.AFTER_TABLE_RESIZE);\n    }\n  }\n\n  findDragRowIndex(_rows: TableRowFormat[]) {\n    // implementation is required\n    return -1;\n  }\n\n  calculateRowDragRange() {\n    // currently full or fixed doesn't effect row drag\n    if (!this.tableBlot) return;\n    const rows = this.tableBlot.getRows();\n    this.rowIndex = this.findDragRowIndex(rows);\n    if (this.rowIndex === -1) return;\n    const rect = rows[this.rowIndex].domNode.getBoundingClientRect();\n    this.dragYCommon.minRange = rect.y + tableUpSize.rowMinHeightPx;\n    this.dragYCommon.maxRange = Number.POSITIVE_INFINITY;\n  }\n\n  updateTableRow(top: number) {\n    if (!this.tableBlot || this.rowIndex === -1) return;\n    const resultY = this.dragYCommon.limitRange(this.tableBlot, top, true);\n    const rows = this.tableBlot.getRows();\n    const changeRowRect = rows[this.rowIndex].domNode.getBoundingClientRect();\n    const height = resultY - changeRowRect.top;\n    rows[this.rowIndex].setHeight(`${height}px`);\n    this.quill.emitter.emit(tableUpEvent.AFTER_TABLE_RESIZE);\n  }\n\n  removeBreak() {\n    if (this.dragXCommon.dragBreak) {\n      this.dragXCommon.dragBreak.remove();\n      this.dragXCommon.dragBreak = null;\n    }\n    if (this.dragYCommon.dragBreak) {\n      this.dragYCommon.dragBreak.remove();\n      this.dragYCommon.dragBreak = null;\n    }\n  }\n}\n","import type { Delta as TypeDelta } from 'quill';\nimport type { TableMainFormat, TableRowFormat } from '../../formats';\nimport type { TableUp } from '../../table-up';\nimport type { DragPosition } from '../../utils';\nimport type { TableSelection } from '../table-selection';\nimport type { TableResizeCommonHelper } from './table-resize-common';\nimport Quill from 'quill';\nimport { getTableMainRect } from '../../formats';\nimport { AutoScroller, isUndefined, tableUpInternal } from '../../utils';\nimport { isCellsSpan } from './utils';\n\nconst Delta = Quill.import('delta');\n\nexport class TableAutoScroller extends AutoScroller {\n  minusY = 0;\n  minusX = 0;\n\n  checkMinY(containerRect: DOMRect) {\n    return this.mouseY + this.minusY < containerRect.top + this.scrollThresholdY;\n  }\n\n  checkMinX(containerRect: DOMRect) {\n    return this.mouseX + this.minusX < containerRect.left + this.scrollThresholdX;\n  }\n}\n\ninterface DragHelperOptions {\n  isDragX: boolean;\n  allowMoveToIndex?: (index: number) => boolean;\n}\nexport class DragTableHelper {\n  startPosition: ({ position: number; size: number; index: number })[] = [];\n  selectedIndex = new Set<number>();\n  moveToIndex = -1;\n  tableModule: TableUp;\n  tableBlot: TableMainFormat;\n  dragCommon: TableResizeCommonHelper;\n  options: DragHelperOptions;\n  get isDragX() {\n    return this.options.isDragX;\n  }\n\n  constructor(tableModule: TableUp, tableBlot: TableMainFormat, dragCommon: TableResizeCommonHelper, options: DragHelperOptions) {\n    this.tableModule = tableModule;\n    this.tableBlot = tableBlot;\n    this.dragCommon = dragCommon;\n    this.options = options;\n  }\n\n  onStart(positionInfo: DragPosition, e: PointerEvent, callback?: (context: this) => void) {\n    const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n    if (!tableSelection?.boundary || !this.tableBlot) return false;\n    const { isSpan, cellIndex } = isCellsSpan(this.isDragX, this.tableBlot, tableSelection.selectedTds);\n    if (!isSpan) return false;\n    const { rect: tableRect } = getTableMainRect(this.tableBlot);\n    if (!tableRect) return false;\n    e.preventDefault();\n    this.dragCommon.startValue = this.isDragX ? tableRect.x : tableRect.y;\n    this.selectedIndex = cellIndex;\n\n    callback?.(this);\n    this.recalculateStartPosition();\n  }\n\n  onMove(positionInfo: DragPosition, e: PointerEvent, callback?: (context: this) => void) {\n    this.moveToIndex = this.findTheMovedToIndex(e);\n    callback?.(this);\n  }\n\n  onEnd(positionInfo: DragPosition, e: PointerEvent, callback?: (context: this) => void) {\n    callback?.(this);\n    this.moveToIndex = -1;\n    this.selectedIndex = new Set();\n  }\n\n  recalculateStartPosition() {\n    if (this.isDragX) {\n      this.startPosition = [];\n      if (!this.tableBlot) return;\n      // calculate column position\n      const cols = this.tableBlot.getCols();\n      let left = cols[0].domNode.getBoundingClientRect().left;\n      for (let index = 0; index < cols.length; index++) {\n        const colRect = cols[index].domNode.getBoundingClientRect();\n        this.startPosition.push({ size: colRect.width, position: left, index });\n        left += colRect.width;\n      }\n    }\n    else {\n      this.startPosition = [];\n      if (!this.tableBlot) return;\n      // calculate row position\n      const rows = this.tableBlot.getRows();\n      this.startPosition = rows.map((row, index) => {\n        const rowRect = row.domNode.getBoundingClientRect();\n        return {\n          size: rowRect.height,\n          position: rowRect.top,\n          index,\n        };\n      });\n    }\n  }\n\n  findTheMovedToIndex(e: PointerEvent) {\n    // find the index moved to\n    const offset = this.dragCommon.getOffsetFromStart(this.tableBlot);\n    const positionInfo = this.startPosition.find(({ position, size }) => {\n      return (this.isDragX ? e.clientX : e.clientY) < position + size / 2 + offset;\n    });\n    let index = positionInfo?.index;\n    if (isUndefined(index) || index < 0) index = this.startPosition.length;\n    index = Math.max(0, Math.min(index, this.startPosition.length));\n    // if index in selectedIndex, not allow to move\n    if (this.selectedIndex.has(index)) return -1;\n    if (this.options.allowMoveToIndex && !this.options.allowMoveToIndex(index)) return -1;\n    return index;\n  }\n\n  updateTableStructure(content: TypeDelta, isMoveMinus: boolean) {\n    let changeDelta = new Delta();\n    if (!this.tableBlot || this.moveToIndex < 0) return changeDelta;\n    const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n    if (!tableSelection) return changeDelta;\n    if (this.isDragX) {\n      const cols = this.tableBlot.getCols();\n      const maxColIndex = cols.length - 1;\n      const isMoveLast = this.moveToIndex > maxColIndex;\n      const selectColId = new Set<string>(tableSelection.selectedTds.map(td => td.colId));\n      const moveCols = cols.filter(col => selectColId.has(col.colId));\n      const moveColsInfo = moveCols.map((col) => {\n        const length = col.length();\n        const offset = col.offset(col.scroll);\n        const delta = content.slice(offset, offset + length);\n        return { offset, delta, length };\n      });\n\n      const moveToIndex = Math.min(maxColIndex, this.moveToIndex);\n      const baseCol = cols[moveToIndex];\n      const colInsertIndex = baseCol.offset(baseCol.scroll) + (isMoveLast ? baseCol.length() : 0);\n      const colInsertDelta = moveColsInfo.reduce((delta, cur) => {\n        delta = delta.concat(cur.delta);\n        return delta;\n      }, new Delta().retain(colInsertIndex));\n      const colDeletaDelta = moveColsInfo.reduce((delta, cur, index) => {\n        const prevColInfo = moveColsInfo[index - 1];\n        const offset = prevColInfo ? prevColInfo.offset + prevColInfo.length : 0;\n        delta = delta.retain(cur.offset - offset).delete(cur.length);\n        return delta;\n      }, new Delta());\n      const colChangeDelta = isMoveMinus\n        ? colDeletaDelta.compose(colInsertDelta)\n        : colInsertDelta.compose(colDeletaDelta);\n\n      const tdInfo = tableSelection.selectedTds.map((td) => {\n        const length = td.length();\n        const offset = td.offset(td.scroll);\n        const delta = content.slice(offset, offset + length);\n        return { offset, delta, length, rowId: td.rowId };\n      });\n      const {\n        delta: tdDeleteDelta,\n        insertDeltaInfo: tdInsertDeltaInfo,\n      } = tdInfo.reduce(({ delta, insertDeltaInfo }, cur, index) => {\n        const prev = tdInfo[index - 1];\n        const offset = prev ? prev.offset + prev.length : 0;\n        let prevLength = 0;\n        if (index !== 0 && !isMoveMinus) {\n          // move to right. delete before insert. retain need count in delete\n          // if prev cell not in the same row, retain need add the `insert` delta length\n          prevLength = prev.rowId !== cur.rowId ? insertDeltaInfo[prev.rowId]?.length() : 0;\n        }\n        delta = delta.retain(cur.offset - offset + prevLength).delete(cur.length);\n\n        if (!insertDeltaInfo[cur.rowId]) insertDeltaInfo[cur.rowId] = new Delta();\n        insertDeltaInfo[cur.rowId] = insertDeltaInfo[cur.rowId].concat(cur.delta);\n        return { delta, insertDeltaInfo };\n      }, { delta: new Delta(), insertDeltaInfo: {} } as { delta: TypeDelta; insertDeltaInfo: Record<string, TypeDelta> });\n\n      const rows = this.tableBlot.getRows();\n      const { delta: tdInsertDelta } = rows.reduce(({ delta, offset }, row, index) => {\n        const info = row.getCellByColumIndex(Math.min(maxColIndex, this.moveToIndex));\n        const td = info[0];\n        if (!td) return { delta, offset };\n        const tdOffset = td.offset(td.scroll) + (isMoveLast ? td.length() : 0);\n        let retain = tdOffset - offset;\n        if (index !== 0 && isMoveMinus) {\n          // move to left. insert before delete. retain need count in insert\n          // minus each previous line `insert` delta length\n          const prevRow = tdInsertDeltaInfo[rows[index - 1].rowId];\n          if (prevRow) {\n            retain -= prevRow.length();\n          }\n        }\n        delta.retain(retain);\n        if (tdInsertDeltaInfo[td.rowId]) {\n          delta = delta.concat(tdInsertDeltaInfo[td.rowId]);\n        }\n        return { delta, offset: tdOffset };\n      }, { delta: new Delta(), offset: 0 });\n      const cellChangeDelta = isMoveMinus\n        ? tdDeleteDelta.compose(tdInsertDelta)\n        : tdInsertDelta.compose(tdDeleteDelta);\n\n      // Delta.compose doesn't calculate retain with `delete` or `insert`, but `updateContent` will\n      changeDelta = colChangeDelta.compose(cellChangeDelta);\n    }\n    else {\n      const rows = this.tableBlot.getRows();\n      const maxRowIndex = rows.length - 1;\n      const isMoveLast = this.moveToIndex > maxRowIndex;\n      const moveToIndex = Math.min(maxRowIndex, this.moveToIndex);\n      const baseRow = rows[moveToIndex];\n      const selectedRows = Array.from(\n        tableSelection.selectedTds.reduce(\n          (rowSet, td) => rowSet.add(td.getTableRow()!),\n          new Set<TableRowFormat>(),\n        ),\n      ).filter(Boolean);\n\n      let lastOffset = 0;\n      const { delta: rowDeleteDelta, start, end } = selectedRows.reduce(({ delta, start, end }, row) => {\n        const offset = row.offset(row.scroll);\n        const length = row.length();\n        delta.retain(offset - lastOffset).delete(length);\n        lastOffset = offset + length;\n        return {\n          delta,\n          start: Math.min(start, offset),\n          end: Math.max(end, offset + length),\n        };\n      }, { delta: new Delta(), start: Number.POSITIVE_INFINITY, end: 0 });\n      const rowInsertIndex = baseRow.offset(baseRow.scroll) + (isMoveLast ? baseRow.length() : 0);\n      const rowInsertDelta = new Delta().retain(rowInsertIndex).concat(content.slice(start, end));\n      changeDelta = isMoveMinus\n        ? rowDeleteDelta.compose(rowInsertDelta)\n        : rowInsertDelta.compose(rowDeleteDelta);\n    }\n    return changeDelta;\n  }\n}\n","import type { TableMainFormat, TableWrapperFormat } from '../../formats';\nimport type { TableUp } from '../../table-up';\nimport type { DragElementOptions, Position, TableResizeBoxOptions } from '../../utils';\nimport type { TableSelection } from '../table-selection';\nimport Quill from 'quill';\nimport { getTableMainRect, TableCaptionFormat, TableCellInnerFormat } from '../../formats';\nimport { addScrollEvent, clearScrollEvent, createBEM, createResizeObserver, dragElement, findChildBlot, removeScrollEvent, tableUpEvent, tableUpInternal } from '../../utils';\nimport { TableResizeCommon } from './table-resize-common';\nimport { DragTableHelper, TableAutoScroller } from './table-resize-drag';\nimport { isCellsSpan, isTableAlignRight } from './utils';\n\nexport class TableResizeBox extends TableResizeCommon {\n  static moduleName = 'table-resize-box';\n\n  options: TableResizeBoxOptions;\n  root: HTMLElement;\n  tableWrapperBlot?: TableWrapperFormat;\n  resizeObserver?: ResizeObserver;\n  rowHeadWrapper: HTMLElement | null = null;\n  colHeadWrapper: HTMLElement | null = null;\n  corner: HTMLElement | null = null;\n  scrollHandler: [HTMLElement, (e: Event) => void][] = [];\n  lastHeaderSelect: { isX: boolean; index: number } | null = null;\n  bem = createBEM('resize-box');\n  draggingColIndex = -1;\n  draggingRowIndex = -1;\n  stopColDrag: (() => void)[] = [];\n  stopRowDrag: (() => void)[] = [];\n  dragWrapper: HTMLElement | null = null;\n  dragPlaceholder: HTMLElement | null = null;\n  markIndicator: HTMLElement | null = null;\n  dragTip: HTMLElement | null = null;\n  stopColMoveDrag: (() => void)[] = [];\n  stopRowMoveDrag: (() => void)[] = [];\n  autoScroller: TableAutoScroller | null = null;\n  updateContentDraggingPosition: () => void;\n  cellSpanIndex: Set<number> = new Set();\n  dragPlaceholderStartPosition = { x: 0, y: 0 };\n\n  constructor(public tableModule: TableUp, public quill: Quill, options: Partial<TableResizeBoxOptions>) {\n    super(tableModule, quill);\n    this.options = this.resolveOptions(options);\n\n    this.updateContentDraggingPosition = () => this.updateContentDraggerPosition(null as any);\n    this.root = this.tableModule.addContainer(this.bem.b());\n    this.quill.on(Quill.events.EDITOR_CHANGE, this.updateWhenTextChange);\n    this.quill.on(tableUpEvent.TABLE_SELECTION_CHANGE, this.updateWrapperHead);\n  }\n\n  resolveOptions(options: Partial<TableResizeBoxOptions>) {\n    return Object.assign({\n      size: 16,\n      draggable: true,\n    }, options);\n  }\n\n  updateWrapperHead = () => {\n    if (!this.options.draggable) return;\n    const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n    if (!tableSelection || !this.tableBlot) return;\n    const { isSpan: isSpanX, cellIndex: cellXIndex } = isCellsSpan(true, this.tableBlot, tableSelection.selectedTds);\n    const { isSpan: isSpanY, cellIndex: cellYIndex } = isCellsSpan(false, this.tableBlot, tableSelection.selectedTds);\n    // add cursor drag style\n    // but if select all table, style will not be added\n    if (isSpanX) {\n      const tableColHeads = Array.from(this.root.getElementsByClassName(this.bem.be('col-header'))) as HTMLElement[];\n      for (const el of tableColHeads) el.classList.remove(this.bem.is('selected'));\n      if (!isSpanY) {\n        for (const i of Array.from(cellXIndex).slice(0, -1)) {\n          tableColHeads[i].classList.add(this.bem.is('selected'));\n        }\n      }\n    }\n    if (isSpanY) {\n      const tableRowHeads = Array.from(this.root.getElementsByClassName(this.bem.be('row-header'))) as HTMLElement[];\n      const tableRowHeadsSorted: HTMLElement[] = [];\n      for (const el of tableRowHeads) {\n        el.classList.remove(this.bem.is('selected'));\n        tableRowHeadsSorted[Number(el.dataset.index)] = el;\n      }\n      if (!isSpanX) {\n        for (const i of Array.from(cellYIndex).slice(0, -1)) {\n          if (tableRowHeadsSorted[i]) {\n            tableRowHeadsSorted[i].classList.add(this.bem.is('selected'));\n          }\n        }\n      }\n    }\n  };\n\n  updateWhenTextChange = (eventName: string) => {\n    if (eventName === Quill.events.TEXT_CHANGE) {\n      if (this.table && !this.quill.root.contains(this.table)) {\n        this.setSelectionTable(undefined);\n      }\n      else {\n        this.update();\n      }\n    }\n  };\n\n  setSelectionTable(table: HTMLTableElement | undefined) {\n    if (this.table === table) return;\n    this.hide();\n    this.table = table;\n    if (this.table) {\n      const newTableBlot = Quill.find(this.table) as TableMainFormat;\n      if (newTableBlot) {\n        this.tableBlot = newTableBlot;\n        this.tableWrapperBlot = this.tableBlot.parent as TableWrapperFormat;\n      }\n      this.show();\n    }\n    this.update();\n  }\n\n  handleResizerHeaderClick(isX: boolean, index: number, e: MouseEvent) {\n    if (!this.table) return;\n    const { clientX, clientY } = e;\n    const tableRect = this.table.getBoundingClientRect();\n    if (!e.shiftKey) {\n      this.lastHeaderSelect = null;\n    }\n    const currentBoundary: [Position, Position] = [\n      { x: isX ? tableRect.left : clientX, y: isX ? clientY : tableRect.top },\n      { x: isX ? tableRect.right : clientX, y: isX ? clientY : tableRect.bottom },\n    ];\n    if (this.lastHeaderSelect) {\n      // find last click head\n      let lastX: number;\n      let lastY: number;\n      if (this.lastHeaderSelect.isX) {\n        const tableRowHeads = Array.from(this.root.getElementsByClassName(this.bem.be('row-header'))) as HTMLElement[];\n        const rect = tableRowHeads[this.lastHeaderSelect.index].getBoundingClientRect();\n        lastX = Math.min(rect.left, tableRect.left);\n        lastY = rect.top + rect.height / 2;\n      }\n      else {\n        const tableColHeads = Array.from(this.root.getElementsByClassName(this.bem.be('col-header'))) as HTMLElement[];\n        const rect = tableColHeads[this.lastHeaderSelect.index].getBoundingClientRect();\n        lastX = rect.left + rect.width / 2;\n        lastY = Math.min(rect.top, tableRect.top);\n      }\n\n      if (this.lastHeaderSelect.isX !== isX) {\n        currentBoundary[1] = {\n          x: Math.max(currentBoundary[0].x, lastX),\n          y: Math.max(currentBoundary[0].y, lastY),\n        };\n        currentBoundary[0] = {\n          x: Math.min(currentBoundary[0].x, lastX),\n          y: Math.min(currentBoundary[0].y, lastY),\n        };\n      }\n      else if (isX) {\n        currentBoundary[0].y = Math.min(currentBoundary[0].y, lastY);\n        currentBoundary[1].y = Math.max(currentBoundary[1].y, lastY);\n      }\n      else {\n        currentBoundary[0].x = Math.min(currentBoundary[0].x, lastX);\n        currentBoundary[1].x = Math.max(currentBoundary[1].x, lastX);\n      }\n    }\n    else {\n      this.lastHeaderSelect = { isX, index };\n    }\n\n    const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n    if (tableSelection) {\n      tableSelection.table = this.table;\n      tableSelection.setSelectedTds(tableSelection.computeSelectedTds(...currentBoundary));\n      tableSelection.show();\n    }\n  }\n\n  findDragColIndex() {\n    return this.draggingColIndex;\n  }\n\n  findDragRowIndex() {\n    return this.draggingRowIndex;\n  }\n\n  updateContentDraggerPosition(dragHelper: DragTableHelper) {\n    if (!dragHelper || !this.dragWrapper || !this.markIndicator || !this.tableBlot || !this.tableWrapperBlot) return;\n    const { rect: tableRect } = getTableMainRect(this.tableBlot);\n    if (!tableRect || dragHelper.moveToIndex < 0) return;\n    const tableWrapperRect = this.tableWrapperBlot.domNode.getBoundingClientRect();\n    const rootRect = this.quill.root.getBoundingClientRect();\n    Object.assign(this.dragWrapper.style, {\n      top: `${Math.max(tableRect.y, tableWrapperRect.y) - rootRect.y}px`,\n      left: `${Math.max(tableRect.x, tableWrapperRect.x) - rootRect.x}px`,\n    });\n\n    const { position } = dragHelper.startPosition[dragHelper.moveToIndex] || {};\n    const offsetX = this.dragXCommon.getOffsetFromStart(this.tableBlot);\n    const offsetY = this.dragYCommon.getOffsetFromStart(this.tableBlot);\n    const markIndicatorStyle = dragHelper.isDragX\n      ? {\n          top: `${Math.max(tableRect.y, tableWrapperRect.y) - rootRect.y}px`,\n          left: `${position - rootRect.left + offsetX}px`,\n        }\n      : {\n          top: `${position - rootRect.top + offsetY}px`,\n          left: `${Math.max(tableRect.x, tableWrapperRect.x) - rootRect.x}px`,\n        };\n    Object.assign(this.markIndicator.style, markIndicatorStyle);\n  }\n\n  createContentDragger(e: PointerEvent, isX: boolean, dragHelper: DragTableHelper) {\n    if (!this.tableBlot) return;\n    const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n    if (!tableSelection || !this.tableWrapperBlot) return;\n    tableSelection.updateWithSelectedTds();\n    const placeholderWidth = tableSelection.boundary!.width;\n    const placeholderHeight = tableSelection.boundary!.height;\n\n    const rootRect = this.quill.root.getBoundingClientRect();\n    const tableWrapperRect = this.tableWrapperBlot.domNode.getBoundingClientRect();\n    const dragBEM = createBEM('drag');\n    this.dragWrapper = this.tableModule.addContainer(dragBEM.b());\n    const wrapLeft = tableWrapperRect.x - rootRect.x;\n    const wrapTop = tableWrapperRect.y - rootRect.y;\n    Object.assign(this.dragWrapper.style, {\n      left: `${wrapLeft}px`,\n      top: `${wrapTop}px`,\n      width: `${tableWrapperRect.width}px`,\n      height: `${tableWrapperRect.height}px`,\n    });\n\n    this.dragPlaceholder = document.createElement('div');\n    this.dragPlaceholder.classList.add(dragBEM.be('placeholder'), dragBEM.is('hidden'));\n    this.dragWrapper.appendChild(this.dragPlaceholder);\n    this.dragPlaceholderStartPosition = {\n      x: isX ? tableSelection.boundary!.x - wrapLeft : 0,\n      y: isX ? 0 : tableSelection.boundary!.y - wrapTop,\n    };\n    Object.assign(this.dragPlaceholder.style, {\n      left: `${this.dragPlaceholderStartPosition.x}px`,\n      top: `${this.dragPlaceholderStartPosition.y}px`,\n      width: `${placeholderWidth}px`,\n      height: `${placeholderHeight}px`,\n    });\n\n    this.markIndicator = this.tableModule.addContainer(dragBEM.be('indicator'));\n    const markIndicatorStyle = isX\n      ? {\n          top: `${wrapTop}px`,\n          height: `${Math.min(tableSelection.boundary!.height, tableWrapperRect.height)}px`,\n        }\n      : {\n          left: `${wrapLeft}px`,\n          width: `${Math.min(tableSelection.boundary!.width, tableWrapperRect.width)}px`,\n        };\n    Object.assign(this.markIndicator.style, markIndicatorStyle);\n    this.updateContentDraggingPosition = () => this.updateContentDraggerPosition(dragHelper);\n    addScrollEvent.call(this, this.quill.root, this.updateContentDraggingPosition);\n    addScrollEvent.call(this, this.tableWrapperBlot.domNode, this.updateContentDraggingPosition);\n\n    this.dragTip = this.tableModule.addContainer(dragBEM.be('tip'));\n    const dragTipContent = document.createElement('div');\n    dragTipContent.classList.add(dragBEM.be('tip-content'));\n    this.dragTip.appendChild(dragTipContent);\n\n    // absolute position. range in tableWrapper viewport\n    if (isX) {\n      this.dragXCommon.minRange = 0;\n      this.dragXCommon.maxRange = tableWrapperRect.width - placeholderWidth;\n    }\n    else {\n      this.dragYCommon.minRange = 0;\n      this.dragYCommon.maxRange = tableWrapperRect.height - placeholderHeight;\n    }\n  }\n\n  bindColEvents() {\n    if (!this.tableWrapperBlot) return;\n    const tableColHeads = Array.from(this.root.getElementsByClassName(this.bem.be('col-header'))) as HTMLElement[];\n    const tableColHeadSeparators = Array.from(this.root.getElementsByClassName(this.bem.be('col-separator'))) as HTMLElement[];\n\n    addScrollEvent.call(this, this.tableWrapperBlot.domNode, () => {\n      this.colHeadWrapper!.scrollLeft = this.tableWrapperBlot!.domNode.scrollLeft;\n    });\n\n    if (this.stopColMoveDrag.length > 0) {\n      for (const stop of this.stopColMoveDrag) stop();\n      this.stopColMoveDrag = [];\n    }\n    const dragHelper = new DragTableHelper(this.tableModule, this.tableBlot!, this.dragXCommon, {\n      isDragX: true,\n      allowMoveToIndex: index => this.allowMoveToIndex(index),\n    });\n    for (const [index, el] of tableColHeads.entries()) {\n      el.addEventListener('click', this.handleResizerHeaderClick.bind(this, false, index));\n      if (this.options.draggable) {\n        const { stop } = dragElement(el, this.dragHeadOptions(true, { index, dragHelper }));\n        this.stopColMoveDrag.push(stop);\n      }\n    }\n\n    if (this.stopColDrag.length > 0) {\n      for (const stop of this.stopColDrag) stop();\n      this.stopColDrag = [];\n    }\n    for (const [i, el] of tableColHeadSeparators.entries()) {\n      const { stop } = dragElement(el, {\n        axis: 'x',\n        onStart: (position, e) => {\n          this.dragging = true;\n\n          this.draggingColIndex = i;\n          this.calculateColDragRange();\n          this.dragXCommon.createBreak();\n          if (!this.tableBlot) return;\n          const tableWrapperRect = this.tableBlot.domNode.parentElement!.getBoundingClientRect();\n          const { rect: tableRect } = getTableMainRect(this.tableBlot);\n          if (!tableRect) return;\n          // record current tablb rect to calculate the offset if have scroll when dragging\n          this.dragXCommon.startValue = tableRect.x;\n          const rootRect = this.quill.root.getBoundingClientRect();\n          Object.assign(this.dragXCommon.dragBreak!.style, {\n            top: `${Math.max(tableWrapperRect.y, tableRect.y) - rootRect.y}px`,\n            left: `${e.clientX - rootRect.x}px`,\n            height: `${Math.min(tableWrapperRect.height, tableRect.height)}px`,\n          });\n        },\n        onMove: ({ position }) => {\n          if (!this.dragXCommon.dragBreak) return;\n          const resultX = this.dragXCommon.limitRange(this.tableBlot, position.x, true);\n          const rootRect = this.quill.root.getBoundingClientRect();\n          this.dragXCommon.dragBreak.style.left = `${resultX - rootRect.x}px`;\n        },\n        onEnd: ({ position }) => {\n          this.dragging = false;\n\n          this.updateTableCol(position.x);\n          this.removeBreak();\n        },\n      });\n      this.stopColDrag.push(stop);\n\n      el.addEventListener('dragstart', e => e.preventDefault());\n    }\n  }\n\n  bindRowEvents() {\n    const tableRowHeads = Array.from(this.root.getElementsByClassName(this.bem.be('row-header'))) as HTMLElement[];\n    const tableRowHeadSeparators = Array.from(this.root.getElementsByClassName(this.bem.be('row-separator'))) as HTMLElement[];\n\n    addScrollEvent.call(this, this.tableWrapperBlot!.domNode, () => {\n      this.rowHeadWrapper!.scrollTop = this.tableWrapperBlot!.domNode.scrollTop;\n    });\n\n    if (this.stopRowMoveDrag.length > 0) {\n      for (const stop of this.stopRowMoveDrag) stop();\n      this.stopRowMoveDrag = [];\n    }\n    const dragHelper = new DragTableHelper(this.tableModule, this.tableBlot!, this.dragYCommon, {\n      isDragX: false,\n      allowMoveToIndex: index => this.allowMoveToIndex(index),\n    });\n    for (const [i, el] of tableRowHeads.entries()) {\n      // emptyRow doesn't generate head. logic need row index, not head inedx\n      const index = Number(el.dataset.index || i);\n      el.addEventListener('click', this.handleResizerHeaderClick.bind(this, true, i));\n      if (this.options.draggable) {\n        const { stop } = dragElement(el, this.dragHeadOptions(false, { index, dragHelper }));\n        this.stopRowMoveDrag.push(stop);\n      }\n    }\n\n    if (this.stopRowDrag.length > 0) {\n      for (const stop of this.stopRowDrag) stop();\n      this.stopRowDrag = [];\n    }\n    for (const [i, el] of tableRowHeadSeparators.entries()) {\n      const { stop } = dragElement(el, {\n        axis: 'y',\n        onStart: (ops, e) => {\n          this.dragging = true;\n\n          this.draggingRowIndex = i;\n          this.calculateRowDragRange();\n          this.dragYCommon.createBreak();\n          if (!this.tableBlot) return;\n          const tableWrapperRect = this.tableBlot.domNode.parentElement!.getBoundingClientRect();\n          const { rect: tableRect } = getTableMainRect(this.tableBlot);\n          if (!tableRect) return;\n          // record current tablb rect to calculate the offset if have scroll when dragging\n          this.dragYCommon.startValue = tableRect.y;\n          const rootRect = this.quill.root.getBoundingClientRect();\n          Object.assign(this.dragYCommon.dragBreak!.style, {\n            top: `${e.clientY - rootRect.y}px`,\n            left: `${Math.max(tableWrapperRect.x, tableRect.x) - rootRect.x}px`,\n            width: `${Math.min(tableWrapperRect.width, tableRect.width)}px`,\n          });\n        },\n        onMove: ({ position }) => {\n          if (!this.dragYCommon.dragBreak || !this.table) return;\n          const resultY = this.dragYCommon.limitRange(this.tableBlot, position.y, true);\n          const rootRect = this.quill.root.getBoundingClientRect();\n          this.dragYCommon.dragBreak.style.top = `${resultY - rootRect.y}px`;\n        },\n        onEnd: ({ position }) => {\n          this.dragging = false;\n\n          this.updateTableRow(position.y);\n          this.removeBreak();\n        },\n      });\n      this.stopRowDrag.push(stop);\n\n      el.addEventListener('dragstart', e => e.preventDefault());\n    }\n  }\n\n  allowMoveToIndex(index: number) {\n    return !this.cellSpanIndex.has(index);\n  }\n\n  recordCellSpan(isX: boolean) {\n    // record colspan or rowspan cell index when dragging content\n    // drag content not allow to insert on these index\n    const cellIndex = new Set<number>();\n    if (!this.tableBlot) return cellIndex;\n    const cells = this.tableBlot.descendants(TableCellInnerFormat);\n    const ids: string[] = isX ? this.tableBlot.getColIds() : this.tableBlot.getRowIds();\n    const spanAttr = isX ? 'colspan' : 'rowspan';\n    for (const cell of cells) {\n      if (cell[spanAttr] <= 1) continue;\n      const index = ids.indexOf(isX ? cell.colId : cell.rowId);\n      if (index === -1) continue;\n      for (let i = index + 1; i < index + cell[spanAttr] && i < ids.length; i++) {\n        cellIndex.add(i);\n      }\n    }\n    return cellIndex;\n  }\n\n  dragHeadOptions(isX: boolean, context: { index: number; dragHelper: DragTableHelper }): Partial<DragElementOptions> {\n    const { dragHelper, index } = context;\n    return {\n      axis: isX ? 'x' : 'y',\n      onStart: (positionInfo, e) => {\n        let prevent = false;\n        dragHelper.onStart(positionInfo, e, () => {\n          if (!this.tableBlot) return;\n          const count = (isX ? this.tableBlot.getCols() : this.tableBlot.getRows()).length;\n          if (dragHelper.selectedIndex.size > count) {\n            prevent = false;\n            return;\n          }\n          const selectedIndex = new Set(Array.from(dragHelper.selectedIndex).slice(0, -1));\n          prevent = selectedIndex.has(index);\n          if (!selectedIndex.has(index)) {\n            prevent = false;\n            return;\n          }\n          this.dragging = true;\n          if (isX) {\n            this.draggingColIndex = index;\n          }\n          else {\n            this.draggingRowIndex = index;\n          }\n          this.createContentDragger(e, isX, dragHelper);\n          this.cellSpanIndex = this.recordCellSpan(isX);\n          if (!this.tableWrapperBlot) return;\n          this.autoScroller = new TableAutoScroller(50, 40);\n          this.autoScroller.minusY = this.options.size;\n          this.autoScroller.minusX = this.options.size;\n          this.autoScroller.updateMousePosition(e.clientX, e.clientY);\n          this.autoScroller.start(this.tableWrapperBlot.domNode);\n        });\n        return prevent;\n      },\n      onMove: (positionInfo, e) => {\n        dragHelper.onMove(positionInfo, e, (helper) => {\n          const { movePosition } = positionInfo;\n          this.autoScroller?.updateMousePosition(e.clientX, e.clientY);\n          if (!this.dragPlaceholder || !this.markIndicator || !this.dragTip || !this.tableWrapperBlot) return;\n\n          this.dragPlaceholder.classList.remove(this.bem.is('hidden'));\n          const resultPosition = helper.dragCommon.limitRange(\n            this.tableBlot,\n            this.dragPlaceholderStartPosition[isX ? 'x' : 'y'] + movePosition[isX ? 'x' : 'y'],\n            false,\n          );\n          this.dragPlaceholder.style[isX ? 'left' : 'top'] = `${resultPosition}px`;\n          Object.assign(this.dragTip.style, {\n            left: `${e.clientX - 10}px`,\n            top: `${e.clientY - 10}px`,\n          });\n          if (helper.moveToIndex < 0) {\n            Object.assign(this.markIndicator.style, {\n              opacity: '0',\n            });\n            return;\n          }\n          const rootRect = this.quill.root.getBoundingClientRect();\n          const isBeyond = helper.moveToIndex >= helper.startPosition.length;\n          const item = helper.startPosition[isBeyond ? helper.moveToIndex - 1 : helper.moveToIndex];\n          const indicatorPosition = item.position + (isBeyond ? item.size : 0);\n          const offset = helper.dragCommon.getOffsetFromStart(this.tableBlot);\n          Object.assign(this.markIndicator.style, {\n            opacity: '1',\n            [isX ? 'left' : 'top']: `${indicatorPosition - (isX ? rootRect.left : rootRect.top) + offset}px`,\n          });\n        });\n      },\n      onEnd: (positionInfo, e) => {\n        dragHelper.onEnd(positionInfo, e, (helper) => {\n          const changeDelta = helper.updateTableStructure(\n            this.quill.getContents(),\n            (isX ? this.draggingColIndex : this.draggingRowIndex) > helper.moveToIndex,\n          );\n          this.quill.updateContents(changeDelta);\n          this.dragging = false;\n          this.cellSpanIndex = new Set();\n          this.autoScroller?.stop();\n          removeScrollEvent.call(this, this.quill.root, this.updateContentDraggingPosition);\n          removeScrollEvent.call(this, this.tableWrapperBlot!.domNode, this.updateContentDraggingPosition);\n          if (this.dragWrapper) {\n            this.dragWrapper.remove();\n            this.dragWrapper = null;\n          }\n          if (this.markIndicator) {\n            this.markIndicator.remove();\n            this.markIndicator = null;\n          }\n          if (this.dragTip) {\n            this.dragTip.remove();\n            this.dragTip = null;\n          }\n        });\n      },\n    };\n  }\n\n  update() {\n    if (!this.tableBlot || !this.tableWrapperBlot) return;\n    const { rect: tableRect } = getTableMainRect(this.tableBlot);\n    if (!tableRect) return;\n\n    this.root.innerHTML = '';\n\n    const tableCols = this.tableBlot.getCols();\n    const tableRows = this.tableBlot.getRows();\n    const tableWrapperRect = this.tableWrapperBlot.domNode.getBoundingClientRect();\n    const rootRect = this.quill.root.getBoundingClientRect();\n    Object.assign(this.root.style, {\n      top: `${Math.max(tableRect.y, tableWrapperRect.y) - rootRect.y}px`,\n      left: `${Math.max(tableRect.x, tableWrapperRect.x) - rootRect.x}px`,\n    });\n\n    if (tableCols.length > 0 && tableRows.length > 0) {\n      this.corner = document.createElement('div');\n      this.corner.classList.add(this.bem.be('corner'));\n      Object.assign(this.corner.style, {\n        width: `${this.options.size}px`,\n        height: `${this.options.size}px`,\n      });\n      this.corner.addEventListener('click', () => {\n        const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n        if (tableSelection && this.tableBlot) {\n          tableSelection.setSelectedTds(this.tableBlot.descendants(TableCellInnerFormat));\n          tableSelection.show();\n          tableSelection.updateWithSelectedTds();\n        }\n      });\n      this.root.appendChild(this.corner);\n    }\n\n    if (tableCols.length > 0) {\n      let colHeadStr = '';\n      for (const col of tableCols) {\n        let width = col.domNode.getBoundingClientRect().width;\n        if (width === 0) {\n          width = Number.parseInt(col.domNode.getAttribute('width')!, 10);\n        }\n        colHeadStr += `<div class=\"${this.bem.be('col-header')}\" style=\"width: ${width}px\">\n          <div class=\"${this.bem.be('col-separator')}\" style=\"height: ${tableRect.height + this.options.size - 3}px\"></div>\n        </div>`;\n      }\n      const colHeadWrapper = document.createElement('div');\n      colHeadWrapper.classList.add(this.bem.be('col'));\n      const colHead = document.createElement('div');\n      colHead.classList.add(this.bem.be('col-wrapper'));\n      Object.assign(colHeadWrapper.style, {\n        transform: `translateY(-${this.options.size}px)`,\n        maxWidth: `${tableWrapperRect.width}px`,\n        height: `${this.options.size}px`,\n      });\n      Object.assign(colHead.style, {\n        width: `${tableRect.width}px`,\n      });\n      colHead.innerHTML = colHeadStr;\n      colHeadWrapper.appendChild(colHead);\n      this.root.appendChild(colHeadWrapper);\n      colHeadWrapper.scrollLeft = this.tableWrapperBlot.domNode.scrollLeft;\n      this.colHeadWrapper = colHeadWrapper;\n      this.bindColEvents();\n    }\n\n    if (tableRows.length > 0) {\n      let rowHeadStr = '';\n      for (let i = 0; i < tableRows.length; i++) {\n        const index = i;\n        const row = tableRows[i];\n        let height = row.domNode.getBoundingClientRect().height;\n        // empty row have different height in chrome and firefox\n        // count total height to set\n        if (row.children.length === 1 && (row.children.head?.emptyRow.length || 0) > 0) {\n          const length = row.children.head!.emptyRow.length;\n          for (let start = i + 1; start < tableRows.length && start <= i + length; start++) {\n            const nextRow = tableRows[start];\n            height += nextRow.domNode.getBoundingClientRect().height;\n          }\n          i += length;\n        }\n        rowHeadStr += `<div class=\"${this.bem.be('row-header')}\" data-index=\"${index}\" style=\"height: ${height}px\">\n          <div class=\"${this.bem.be('row-separator')}\" style=\"width: ${tableRect.width + this.options.size - 3}px\"></div>\n        </div>`;\n      }\n      const rowHeadWrapper = document.createElement('div');\n      rowHeadWrapper.classList.add(this.bem.be('row'));\n      const rowHead = document.createElement('div');\n      rowHead.classList.add(this.bem.be('row-wrapper'));\n      Object.assign(rowHeadWrapper.style, {\n        transform: `translateX(-${this.options.size}px)`,\n        width: `${this.options.size}px`,\n        maxHeight: `${tableWrapperRect.height}px`,\n      });\n      Object.assign(rowHead.style, {\n        height: `${tableRect.height}px`,\n      });\n      rowHead.innerHTML = rowHeadStr;\n      rowHeadWrapper.appendChild(rowHead);\n      this.root.appendChild(rowHeadWrapper);\n      rowHeadWrapper.scrollTop = this.tableWrapperBlot.domNode.scrollTop;\n      this.rowHeadWrapper = rowHeadWrapper;\n      this.bindRowEvents();\n    }\n\n    // computed about `caption`\n    const [tableCaptionBlot] = findChildBlot(this.tableBlot, TableCaptionFormat);\n    const tableCaptionIsTop = !tableCaptionBlot || !(tableCaptionBlot?.side === 'top');\n    if (tableCaptionIsTop) {\n      this.root.classList.remove(this.bem.is('caption-bottom'));\n    }\n    else {\n      this.root.classList.add(this.bem.is('caption-bottom'));\n    }\n    let cornerTranslateX = -1 * this.options.size;\n    let rowHeadWrapperTranslateX = -1 * this.options.size;\n    if (isTableAlignRight(this.tableBlot)) {\n      this.root.classList.add(this.bem.is('align-right'));\n      cornerTranslateX = Math.min(tableWrapperRect.width, tableRect.width);\n      rowHeadWrapperTranslateX = Math.min(tableWrapperRect.width, tableRect.width);\n    }\n    else {\n      this.root.classList.remove(this.bem.is('align-right'));\n    }\n    if (this.corner) {\n      Object.assign(this.corner.style, {\n        transform: `translateY(${-1 * this.options.size}px) translateX(${cornerTranslateX}px)`,\n        top: `${tableCaptionIsTop ? 0 : tableRect.height + this.options.size}px`,\n      });\n    }\n    if (this.rowHeadWrapper) {\n      Object.assign(this.rowHeadWrapper.style, {\n        transform: `translateX(${rowHeadWrapperTranslateX}px)`,\n        maxHeight: `${tableWrapperRect.height}px`,\n      });\n    }\n    if (this.colHeadWrapper) {\n      Object.assign(this.colHeadWrapper.style, {\n        top: `${tableCaptionIsTop ? 0 : tableRect.height + this.options.size}px`,\n        maxWidth: `${tableWrapperRect.width}px`,\n      });\n    }\n  }\n\n  show() {\n    if (!this.table || !this.tableBlot) return;\n\n    this.root.classList.remove(this.bem.is('hidden'));\n    this.resizeObserver = createResizeObserver(() => this.update(), { ignoreFirstBind: true });\n    this.resizeObserver.observe(this.table);\n\n    this.update();\n    addScrollEvent.call(this, this.quill.root, () => {\n      this.update();\n    });\n  }\n\n  hide() {\n    this.root.classList.add(this.bem.is('hidden'));\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = undefined;\n    }\n  }\n\n  destroy() {\n    this.hide();\n    clearScrollEvent.call(this);\n    this.quill.off(Quill.events.EDITOR_CHANGE, this.updateWhenTextChange);\n    for (const [dom, handle] of this.scrollHandler) {\n      dom.removeEventListener('scroll', handle);\n    }\n    this.root.remove();\n  }\n}\n","import type { TableCellFormat, TableColFormat } from '../../formats';\nimport type { TableUp } from '../../table-up';\nimport type { TableSelection } from '../table-selection';\nimport Quill from 'quill';\nimport { getTableMainRect, TableRowFormat } from '../../formats';\nimport { addScrollEvent, blotName, clearScrollEvent, createBEM, dragElement, findParentBlot, tableUpInternal } from '../../utils';\nimport { TableResizeCommon } from './table-resize-common';\nimport { isTableAlignRight } from './utils';\n\nexport class TableResizeLine extends TableResizeCommon {\n  static moduleName = 'table-resize-line';\n\n  colResizer?: HTMLElement;\n  rowResizer?: HTMLElement;\n  currentTableCell?: HTMLElement;\n  tableCellBlot?: TableCellFormat;\n  bem = createBEM('resize-line');\n  stopColDrag?: () => void;\n  stopRowDrag?: () => void;\n  scrollHandler: [HTMLElement, (e: Event) => void][] = [];\n\n  constructor(public tableModule: TableUp, public quill: Quill) {\n    super(tableModule, quill);\n    this.colResizer = this.tableModule.addContainer(this.bem.be('col'));\n    this.rowResizer = this.tableModule.addContainer(this.bem.be('row'));\n\n    this.quill.on(Quill.events.EDITOR_CHANGE, this.updateWhenTextChange);\n  }\n\n  setSelectionTable(table: HTMLTableElement | undefined) {\n    if (this.table === table) return;\n    this.hide();\n    this.table = table;\n    if (this.table) {\n      this.show();\n    }\n  }\n\n  updateWhenTextChange = (eventName: string) => {\n    if (eventName === Quill.events.TEXT_CHANGE) {\n      if (this.table && !this.quill.root.contains(this.table)) {\n        this.setSelectionTable(undefined);\n      }\n      else {\n        this.update();\n      }\n    }\n  };\n\n  findTableCell(e: MouseEvent) {\n    for (const el of e.composedPath()) {\n      if (el instanceof HTMLElement && ['TD', 'TH'].includes(el.tagName)) {\n        return el;\n      }\n      if (el === document.body) {\n        return null;\n      }\n    }\n    return null;\n  }\n\n  pointermoveHandler = (e: MouseEvent) => {\n    if (this.dragging) return;\n    // when pointerdown to select mutiple line. if move on resizer will get wrong selection\n    const tableSelection = this.tableModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n    if (tableSelection?.dragging) return;\n    const tableCell = this.findTableCell(e);\n    if (!tableCell) {\n      return this.hide();\n    }\n    const tableCellBlot = Quill.find(tableCell) as TableCellFormat;\n    if (!tableCellBlot) return;\n    if (this.currentTableCell !== tableCell) {\n      this.show();\n      this.currentTableCell = tableCell;\n      this.tableCellBlot = tableCellBlot;\n      this.tableBlot = findParentBlot(tableCellBlot, blotName.tableMain);\n      if (this.tableBlot.getCols().length > 0) {\n        this.updateColResizer();\n      }\n      this.updateRowResizer();\n      addScrollEvent.call(this, this.quill.root, () => {\n        if (this.dragging) return;\n        this.hideResizer();\n      });\n    }\n  };\n\n  findDragColIndex(cols: TableColFormat[]) {\n    if (!this.tableCellBlot) return -1;\n    return cols.findIndex(col => col.colId === this.tableCellBlot!.colId);\n  }\n\n  updateColResizer() {\n    if (!this.tableBlot || !this.tableCellBlot || !this.colResizer) return;\n    this.colResizer.remove();\n    const { rect: tableRect } = getTableMainRect(this.tableBlot);\n    if (!tableRect) return;\n    this.colResizer = this.tableModule.addContainer(this.bem.be('col'));\n    const tableCellRect = this.tableCellBlot.domNode.getBoundingClientRect();\n    const rootRect = this.quill.root.getBoundingClientRect();\n    let left = tableCellRect.right - rootRect.x;\n    if (isTableAlignRight(this.tableBlot)) {\n      left = tableCellRect.left - rootRect.x;\n    }\n    Object.assign(this.colResizer.style, {\n      top: `${tableRect.y - rootRect.y}px`,\n      left: `${left}px`,\n      height: `${tableRect.height}px`,\n    });\n\n    const { stop } = dragElement(this.colResizer, {\n      axis: 'x',\n      onStart: (position, e) => {\n        this.dragging = true;\n\n        this.calculateColDragRange();\n        this.dragXCommon.createBreak();\n        if (!this.tableBlot) return;\n        const tableWrapperRect = this.tableBlot.domNode.parentElement!.getBoundingClientRect();\n        const { rect: tableRect } = getTableMainRect(this.tableBlot);\n        if (!tableRect) return;\n        // record current tablb rect to calculate the offset if have scroll when dragging\n        this.dragXCommon.startValue = tableRect.x;\n        const rootRect = this.quill.root.getBoundingClientRect();\n        Object.assign(this.dragXCommon.dragBreak!.style, {\n          top: `${Math.max(tableWrapperRect.y, tableRect.y) - rootRect.y}px`,\n          left: `${e.clientX - rootRect.x}px`,\n          height: `${Math.min(tableWrapperRect.height, tableRect.height)}px`,\n        });\n      },\n      onMove: ({ position }) => {\n        if (!this.dragXCommon.dragBreak) return;\n        const resultX = this.dragXCommon.limitRange(this.tableBlot, position.x, true);\n        const rootRect = this.quill.root.getBoundingClientRect();\n        this.dragXCommon.dragBreak.style.left = `${resultX - rootRect.x}px`;\n      },\n      onEnd: ({ position }) => {\n        this.dragging = false;\n\n        this.updateTableCol(position.x);\n        this.removeBreak();\n      },\n    });\n    if (this.stopColDrag) this.stopColDrag();\n    this.stopColDrag = stop;\n\n    this.colResizer.addEventListener('dragstart', e => e.preventDefault());\n  }\n\n  findDragRowIndex(rows: TableRowFormat[]) {\n    if (!this.tableCellBlot) return -1;\n    const currentRow = this.tableCellBlot.parent;\n    if (!(currentRow instanceof TableRowFormat)) return -1;\n    return rows.indexOf(currentRow);\n  }\n\n  updateRowResizer() {\n    if (!this.tableBlot || !this.tableCellBlot || !this.rowResizer) return;\n    const tableCellBlot = this.tableCellBlot;\n    this.rowResizer.remove();\n    const { rect } = getTableMainRect(this.tableBlot);\n    if (!rect) return;\n    this.rowResizer = this.tableModule.addContainer(this.bem.be('row'));\n    const tableCellRect = tableCellBlot.domNode.getBoundingClientRect();\n    const rootRect = this.quill.root.getBoundingClientRect();\n    Object.assign(this.rowResizer.style, {\n      top: `${tableCellRect.bottom - rootRect.y}px`,\n      left: `${rect.x - rootRect.x}px`,\n      width: `${rect.width}px`,\n    });\n\n    const { stop } = dragElement(this.rowResizer, {\n      axis: 'y',\n      onStart: (position, e) => {\n        this.dragging = true;\n\n        this.calculateRowDragRange();\n        this.dragYCommon.createBreak();\n        if (!this.tableBlot) return;\n        const tableWrapperRect = this.tableBlot.domNode.parentElement!.getBoundingClientRect();\n        const { rect: tableRect } = getTableMainRect(this.tableBlot);\n        if (!tableRect) return;\n        // record current tablb rect to calculate the offset if have scroll when dragging\n        this.dragYCommon.startValue = tableRect.y;\n        const rootRect = this.quill.root.getBoundingClientRect();\n        Object.assign(this.dragYCommon.dragBreak!.style, {\n          top: `${e.clientY - rootRect.y}px`,\n          left: `${Math.max(tableWrapperRect.x, tableRect.x) - rootRect.x}px`,\n          width: `${Math.min(tableWrapperRect.width, tableRect.width)}px`,\n        });\n      },\n      onMove: ({ position }) => {\n        if (!this.dragYCommon.dragBreak || !this.table) return;\n        const resultY = this.dragYCommon.limitRange(this.tableBlot, position.y, true);\n        const rootRect = this.quill.root.getBoundingClientRect();\n        this.dragYCommon.dragBreak.style.top = `${resultY - rootRect.y}px`;\n      },\n      onEnd: ({ position }) => {\n        this.dragging = false;\n\n        this.updateTableRow(position.y);\n        this.removeBreak();\n      },\n    });\n    if (this.stopRowDrag) this.stopRowDrag();\n    this.stopRowDrag = stop;\n\n    this.rowResizer.addEventListener('dragstart', e => e.preventDefault());\n  }\n\n  show() {\n    if (!this.table || !this.rowResizer || !this.colResizer) return;\n    this.rowResizer.classList.remove(this.bem.is('hidden'));\n    this.colResizer.classList.remove(this.bem.is('hidden'));\n    this.table.addEventListener('pointermove', this.pointermoveHandler);\n  }\n\n  hideResizer() {\n    if (!this.rowResizer || !this.colResizer) return;\n    this.rowResizer.classList.add(this.bem.is('hidden'));\n    this.colResizer.classList.add(this.bem.is('hidden'));\n  }\n\n  hide() {\n    this.currentTableCell = undefined;\n    clearScrollEvent.call(this);\n    this.hideResizer();\n    if (!this.table) return;\n    this.table.removeEventListener('pointermove', this.pointermoveHandler);\n  }\n\n  destroy(): void {\n    if (this.colResizer) {\n      this.colResizer.remove();\n      this.colResizer = undefined;\n    }\n    if (this.rowResizer) {\n      this.rowResizer.remove();\n      this.rowResizer = undefined;\n    }\n    this.quill.off(Quill.events.EDITOR_CHANGE, this.updateWhenTextChange);\n  }\n}\n","import type { TableColFormat, TableMainFormat, TableRowFormat, TableWrapperFormat } from '../../formats';\nimport type { TableUp } from '../../table-up';\nimport type { TableResizeScaleOptions } from '../../utils';\nimport Quill from 'quill';\nimport { getTableMainRect } from '../../formats';\nimport { addScrollEvent, clearScrollEvent, createBEM, tableUpSize } from '../../utils';\nimport { TableDomSelector } from '../table-dom-selector';\nimport { isTableAlignRight } from './utils';\n\nexport class TableResizeScale extends TableDomSelector {\n  static moduleName = 'table-resize-scale';\n\n  scrollHandler: [HTMLElement, (e: Event) => void][] = [];\n  tableMainBlot?: TableMainFormat;\n  tableWrapperBlot?: TableWrapperFormat;\n  bem = createBEM('scale');\n  startX: number = 0;\n  startY: number = 0;\n  offset: number = 6;\n  options: TableResizeScaleOptions;\n  root?: HTMLElement;\n  block?: HTMLElement;\n  resizeobserver: ResizeObserver = new ResizeObserver(() => this.update());\n  constructor(public tableModule: TableUp, public quill: Quill, options: Partial<TableResizeScaleOptions>) {\n    super(tableModule, quill);\n    this.options = this.resolveOptions(options);\n\n    this.quill.on(Quill.events.EDITOR_CHANGE, this.updateWhenTextChange);\n  }\n\n  updateWhenTextChange = (eventName: string) => {\n    if (eventName === Quill.events.TEXT_CHANGE) {\n      if (this.table && !this.quill.root.contains(this.table)) {\n        this.setSelectionTable(undefined);\n      }\n      else {\n        this.update();\n      }\n    }\n  };\n\n  resolveOptions(options: Partial<TableResizeScaleOptions>) {\n    return Object.assign({\n      blockSize: 12,\n    }, options);\n  }\n\n  buildResizer() {\n    if (!this.tableMainBlot || !this.tableWrapperBlot) return;\n    this.root = this.tableModule.addContainer(this.bem.b());\n    this.block = document.createElement('div');\n    this.block.classList.add(this.bem.be('block'));\n    Object.assign(this.block.style, {\n      width: `${this.options.blockSize}px`,\n      height: `${this.options.blockSize}px`,\n    });\n    this.root.appendChild(this.block);\n\n    let originColWidth: { blot: TableColFormat; width: number }[] = [];\n    let originRowHeight: { blot: TableRowFormat; height: number }[] = [];\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!this.tableMainBlot) return;\n      // divide equally by col count/row count\n      const isRight = isTableAlignRight(this.tableMainBlot) ? -1 : 1;\n      const diffX = (e.clientX - this.startX) * isRight;\n      const diffY = e.clientY - this.startY;\n      const itemWidth = Math.floor(diffX / originColWidth.length);\n      const itemHeight = Math.floor(diffY / originRowHeight.length);\n\n      for (const { blot, width } of originColWidth) {\n        blot.width = Math.max(width + itemWidth, tableUpSize.colMinWidthPx);\n      }\n      for (const { blot, height } of originRowHeight) {\n        blot.setHeight(`${Math.max(height + itemHeight, tableUpSize.rowMinHeightPx)}px`);\n      }\n    };\n    const handleMouseUp = () => {\n      originColWidth = [];\n      originRowHeight = [];\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n    this.block.addEventListener('mousedown', (e) => {\n      if (!this.tableMainBlot || this.isTableOutofEditor()) return;\n      this.startX = e.clientX;\n      this.startY = e.clientY;\n      // save the origin width and height to calculate result width and height\n      originColWidth = this.tableMainBlot.getCols().map(col => ({ blot: col, width: Math.floor(col.width) }));\n      originRowHeight = this.tableMainBlot.getRows().map(row => ({ blot: row, height: Math.floor(row.domNode.getBoundingClientRect().height) }));\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    });\n    this.block.addEventListener('dragstart', e => e.preventDefault());\n  }\n\n  isTableOutofEditor(): boolean {\n    if (!this.tableMainBlot || !this.tableWrapperBlot || this.tableMainBlot.full) return false;\n    // if tableMain width larger than tableWrapper. reset tableMain width equal editor width\n    const tableRect = this.tableMainBlot.domNode.getBoundingClientRect();\n    const tableWrapperRect = this.tableWrapperBlot.domNode.getBoundingClientRect();\n    // equal scale\n    if (tableRect.width > tableWrapperRect.width) {\n      for (const col of this.tableMainBlot.getCols()) {\n        col.width = Math.floor((col.width / tableRect.width) * tableWrapperRect.width);\n      }\n      this.tableMainBlot.colWidthFillTable();\n      return true;\n    }\n    return false;\n  }\n\n  update() {\n    if (!this.block || !this.root || !this.tableMainBlot || !this.tableWrapperBlot) return;\n    if (this.tableMainBlot.full) {\n      this.hide();\n      return;\n    }\n    const { rect: tableRect } = getTableMainRect(this.tableMainBlot);\n    if (!tableRect) return;\n    const tableWrapperRect = this.tableWrapperBlot.domNode.getBoundingClientRect();\n    const editorRect = this.quill.root.getBoundingClientRect();\n    const { scrollTop, scrollLeft } = this.tableWrapperBlot.domNode;\n    const blockSize = this.options.blockSize * 2 + this.offset;\n    const rootWidth = Math.min(tableRect.width, tableWrapperRect.width) + blockSize;\n    const rootHeight = Math.min(tableRect.height, tableWrapperRect.height) + blockSize;\n    Object.assign(this.root.style, {\n      width: `${rootWidth}px`,\n      height: `${rootHeight}px`,\n      left: `${Math.max(tableRect.x, tableWrapperRect.x) - editorRect.x - this.options.blockSize}px`,\n      top: `${Math.max(tableRect.y, tableWrapperRect.y) - editorRect.y - this.options.blockSize}px`,\n    });\n    const blockStyle = {\n      left: `${tableRect.width + blockSize - scrollLeft}px`,\n      top: `${rootHeight - scrollTop}px`,\n    };\n    if (isTableAlignRight(this.tableMainBlot)) {\n      this.root.classList.add(this.bem.is('align-right'));\n      blockStyle.left = `${this.options.blockSize + -1 * scrollLeft}px`;\n    }\n    else {\n      this.root.classList.remove(this.bem.is('align-right'));\n    }\n    Object.assign(this.block.style, blockStyle);\n  }\n\n  show() {\n    if (!this.table) return;\n    this.tableMainBlot = Quill.find(this.table) as TableMainFormat;\n    if (this.tableMainBlot && !this.tableMainBlot.full) {\n      this.tableWrapperBlot = this.tableMainBlot.parent as TableWrapperFormat;\n\n      this.resizeobserver.observe(this.tableMainBlot.domNode);\n      addScrollEvent.call(this, this.quill.root, () => this.update());\n    }\n    this.buildResizer();\n  }\n\n  hide() {\n    this.tableMainBlot = undefined;\n    this.tableWrapperBlot = undefined;\n    if (this.root) {\n      this.root.remove();\n      this.root = undefined;\n      this.block = undefined;\n    }\n  }\n\n  destroy() {\n    this.hide();\n    this.quill.off(Quill.events.TEXT_CHANGE, this.updateWhenTextChange);\n    this.resizeobserver.disconnect();\n    clearScrollEvent.call(this);\n  }\n}\n","import type { TableMainFormat } from '../formats';\nimport type { TableUp } from '../table-up';\nimport Quill from 'quill';\nimport { getTableMainRect } from '../formats';\nimport { addScrollEvent, clearScrollEvent, createBEM, debounce } from '../utils';\nimport { TableDomSelector } from './table-dom-selector';\n\nexport class Scrollbar {\n  minSize: number = 20;\n  gap: number = 4;\n  move: number = 0;\n  cursorDown: boolean = false;\n  cursorLeave: boolean = false;\n  ratioY: number = 1;\n  ratioX: number = 1;\n  sizeWidth: string = '';\n  sizeHeight: string = '';\n  size: string = '';\n  thumbState: {\n    X: number;\n    Y: number;\n  } = {\n    X: 0,\n    Y: 0,\n  };\n\n  ob: ResizeObserver;\n  container: HTMLElement;\n  scrollbar: HTMLElement;\n  thumb: HTMLElement = document.createElement('div');\n  scrollHandler: [HTMLElement, (e: Event) => void][] = [];\n  propertyMap: { readonly size: 'height'; readonly offset: 'offsetHeight'; readonly scrollDirection: 'scrollTop'; readonly scrollSize: 'scrollHeight'; readonly axis: 'Y'; readonly direction: 'top'; readonly client: 'clientY' } | { readonly size: 'width'; readonly offset: 'offsetWidth'; readonly scrollDirection: 'scrollLeft'; readonly scrollSize: 'scrollWidth'; readonly axis: 'X'; readonly direction: 'left'; readonly client: 'clientX' };\n  bem = createBEM('scrollbar');\n  tableMainBlot: TableMainFormat;\n\n  get isVertical() {\n    return this.options.isVertical;\n  }\n\n  constructor(public quill: Quill, public table: HTMLElement, public options: { isVertical: boolean }) {\n    this.tableMainBlot = Quill.find(this.table) as TableMainFormat;\n    this.container = table.parentElement!;\n    this.propertyMap = this.isVertical\n      ? {\n          size: 'height',\n          offset: 'offsetHeight',\n          scrollDirection: 'scrollTop',\n          scrollSize: 'scrollHeight',\n          axis: 'Y',\n          direction: 'top',\n          client: 'clientY',\n        } as const\n      : {\n          size: 'width',\n          offset: 'offsetWidth',\n          scrollDirection: 'scrollLeft',\n          scrollSize: 'scrollWidth',\n          axis: 'X',\n          direction: 'left',\n          client: 'clientX',\n        } as const;\n    this.calculateSize();\n    this.ob = new ResizeObserver(() => this.update());\n    this.ob.observe(table);\n    this.scrollbar = this.createScrollbar();\n    this.setScrollbarPosition();\n    addScrollEvent.call(this, this.quill.root, () => this.setScrollbarPosition());\n    this.showScrollbar();\n  }\n\n  update() {\n    this.calculateSize();\n    this.setScrollbarPosition();\n  }\n\n  setScrollbarPosition() {\n    const { rect: tableRect, head: tableHeadBlot, body: tableBodyBlot, foot: tableFootBlot } = getTableMainRect(this.tableMainBlot);\n    const tableMainContentBlot = tableHeadBlot || tableBodyBlot || tableFootBlot;\n    if (!tableMainContentBlot || !tableRect) return;\n    const { scrollLeft: editorScrollX, scrollTop: editorScrollY, offsetLeft: rootOffsetLeft, offsetTop: rootOffsetTop } = this.quill.root;\n    const { offsetLeft: containerOffsetLeft, offsetTop: containerOffsetTop } = this.container;\n    const { offsetLeft: tableOffsetLeft, offsetTop: tableOffsetTop } = tableMainContentBlot.domNode;\n    const { width: containerWidth, height: containerHeight } = this.container.getBoundingClientRect();\n\n    let x = containerOffsetLeft + tableOffsetLeft - rootOffsetLeft;\n    let y = containerOffsetTop + tableOffsetTop - rootOffsetTop;\n    if (this.isVertical) {\n      x += Math.min(containerWidth, tableRect.width);\n    }\n    else {\n      y += Math.min(containerHeight, tableRect.height);\n    }\n\n    // table align right effect\n    if (this.tableMainBlot && this.tableMainBlot.align !== 'left') {\n      x += this.table.offsetLeft - containerOffsetLeft;\n    }\n\n    Object.assign(this.scrollbar.style, {\n      [this.propertyMap.size]: `${this.isVertical ? Math.min(containerHeight, tableRect.height) : containerWidth}px`,\n      transform: `translate(${x - editorScrollX}px, ${y - editorScrollY}px)`,\n    });\n    this.containerScrollHandler(this.container);\n  }\n\n  calculateSize() {\n    const offsetHeight = this.container.offsetHeight - this.gap;\n    const offsetWidth = this.container.offsetWidth - this.gap;\n    const originalHeight = offsetHeight ** 2 / this.container.scrollHeight;\n    const originalWidth = offsetWidth ** 2 / this.container.scrollWidth;\n    const height = Math.max(originalHeight, this.minSize);\n    const width = Math.max(originalWidth, this.minSize);\n    this.ratioY = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));\n    this.ratioX = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));\n\n    this.sizeWidth = width + this.gap < offsetWidth ? `${width}px` : '';\n    this.sizeHeight = height + this.gap < offsetHeight ? `${height}px` : '';\n    this.size = this.isVertical ? this.sizeHeight : this.sizeWidth;\n  }\n\n  createScrollbar() {\n    const scrollbar = document.createElement('div');\n    scrollbar.classList.add(this.bem.b(), this.isVertical ? this.bem.is('vertical') : this.bem.is('horizontal'), this.bem.is('transparent'));\n    Object.assign(scrollbar.style, {\n      display: 'none',\n    });\n    this.thumb.classList.add(this.bem.be('thumb'));\n    let originDocSelect: typeof document.onselectstart = null;\n    const mouseMoveDocumentHandler = (e: MouseEvent) => {\n      if (this.cursorDown === false) return;\n      const prevPage = this.thumbState[this.propertyMap.axis];\n      if (!prevPage) return;\n\n      const offsetRatio = this.scrollbar[this.propertyMap.offset] ** 2\n        / this.container[this.propertyMap.scrollSize] / (this.isVertical ? this.ratioY : this.ratioX)\n        / this.thumb[this.propertyMap.offset];\n      const offset = (this.scrollbar.getBoundingClientRect()[this.propertyMap.direction] - e[this.propertyMap.client]) * -1;\n      const thumbClickPosition = this.thumb[this.propertyMap.offset] - prevPage;\n      const thumbPositionPercentage = ((offset - thumbClickPosition) * 100 * offsetRatio) / this.scrollbar[this.propertyMap.offset];\n      this.container[this.propertyMap.scrollDirection] = (thumbPositionPercentage * this.container[this.propertyMap.scrollSize]) / 100;\n    };\n    const mouseUpDocumentHandler = () => {\n      this.thumbState[this.propertyMap.axis] = 0;\n      this.cursorDown = false;\n      document.removeEventListener('mousemove', mouseMoveDocumentHandler);\n      document.removeEventListener('mouseup', mouseUpDocumentHandler);\n      if (this.cursorLeave) {\n        this.hideScrollbar();\n      }\n      // eslint-disable-next-line unicorn/prefer-add-event-listener\n      document.onselectstart = originDocSelect;\n    };\n    const startDrag = (e: MouseEvent) => {\n      e.stopImmediatePropagation();\n      this.cursorDown = true;\n      document.addEventListener('mousemove', mouseMoveDocumentHandler);\n      document.addEventListener('mouseup', mouseUpDocumentHandler);\n      originDocSelect = document.onselectstart;\n      // eslint-disable-next-line unicorn/prefer-add-event-listener\n      document.onselectstart = () => false;\n    };\n    this.thumb.addEventListener('mousedown', (e: MouseEvent) => {\n      e.stopPropagation();\n      if (e.ctrlKey || [1, 2].includes(e.button)) return;\n\n      window.getSelection()?.removeAllRanges();\n      startDrag(e);\n\n      const el = e.currentTarget as HTMLElement;\n      if (!el) return;\n      this.thumbState[this.propertyMap.axis] = el[this.propertyMap.offset] - (e[this.propertyMap.client] - el.getBoundingClientRect()[this.propertyMap.direction]);\n    });\n    const displayListener = [this.table, scrollbar];\n    for (const el of displayListener) {\n      el.addEventListener('mouseenter', this.showScrollbar);\n      el.addEventListener('mouseleave', this.hideScrollbar);\n    }\n\n    addScrollEvent.call(this, this.container, () => {\n      this.containerScrollHandler(this.container);\n    });\n\n    scrollbar.appendChild(this.thumb);\n    return scrollbar;\n  }\n\n  containerScrollHandler(wrap: HTMLElement) {\n    const offset = wrap[this.propertyMap.offset] - this.gap;\n    this.move = wrap[this.propertyMap.scrollDirection] * 100 / offset * (this.isVertical ? this.ratioY : this.ratioX);\n    Object.assign(this.thumb.style, {\n      [this.propertyMap.size]: this.size,\n      transform: `translate${this.propertyMap.axis}(${this.move}%)`,\n    });\n  }\n\n  showScrollbar = debounce(() => {\n    this.cursorLeave = false;\n    this.scrollbar.removeEventListener('transitionend', this.hideScrollbarTransitionend);\n    this.scrollbar.style.display = this.size ? 'block' : 'none';\n    requestAnimationFrame(() => {\n      this.scrollbar.classList.remove(this.bem.is('transparent'));\n    });\n  }, 200);\n\n  hideScrollbar = debounce(() => {\n    this.cursorLeave = true;\n    if (this.cursorDown) return;\n    this.scrollbar.removeEventListener('transitionend', this.hideScrollbarTransitionend);\n    this.scrollbar.addEventListener('transitionend', this.hideScrollbarTransitionend, { once: true });\n    this.scrollbar.classList.add(this.bem.is('transparent'));\n  }, 200);\n\n  hideScrollbarTransitionend = () => {\n    this.scrollbar.style.display = (this.cursorDown && this.size) ? 'block' : 'none';\n  };\n\n  destroy() {\n    this.ob.disconnect();\n    clearScrollEvent.call(this);\n    this.table.removeEventListener('mouseenter', this.showScrollbar);\n    this.table.removeEventListener('mouseleave', this.hideScrollbar);\n  }\n}\n\nexport class TableVirtualScrollbar extends TableDomSelector {\n  static moduleName: string = 'table-scrollbar';\n\n  scrollbarContainer: HTMLElement;\n  scrollbar: Scrollbar[] = [];\n  bem = createBEM('scrollbar');\n  constructor(public tableModule: TableUp, public quill: Quill, _options: any) {\n    super(tableModule, quill);\n\n    const scrollbarBEM = createBEM('scrollbar');\n    this.quill.container.classList.add(scrollbarBEM.bm('virtual'));\n\n    this.scrollbarContainer = this.tableModule.addContainer(this.bem.be('container'));\n    this.quill.on(Quill.events.EDITOR_CHANGE, this.updateWhenTextChange);\n  }\n\n  updateWhenTextChange = (eventName: string) => {\n    if (eventName === Quill.events.TEXT_CHANGE) {\n      if (this.table && !this.quill.root.contains(this.table)) {\n        this.setSelectionTable(undefined);\n      }\n      else {\n        this.update();\n      }\n    }\n  };\n\n  hide() {\n    for (const scrollbar of this.scrollbar) {\n      scrollbar.destroy();\n    }\n    this.scrollbar = [];\n    this.scrollbarContainer.innerHTML = '';\n  }\n\n  show() {\n    if (!this.table) return;\n    this.scrollbar = [\n      new Scrollbar(this.quill, this.table, { isVertical: true }),\n      new Scrollbar(this.quill, this.table, { isVertical: false }),\n    ];\n    for (const item of this.scrollbar) {\n      this.scrollbarContainer.appendChild(item.scrollbar);\n      item.showScrollbar();\n    }\n  }\n\n  update() {\n    if (this.table) {\n      if (this.scrollbar.length <= 0) {\n        this.show();\n      }\n      for (const scrollbar of this.scrollbar) {\n        scrollbar.calculateSize();\n        scrollbar.setScrollbarPosition();\n      }\n    }\n    else if (this.scrollbar.length > 0) {\n      this.hide();\n    }\n  }\n\n  destroy() {\n    this.hide();\n    this.scrollbarContainer.remove();\n    this.quill.off(Quill.events.TEXT_CHANGE, this.updateWhenTextChange);\n  }\n}\n","import type { EmitterSource, Parchment as TypeParchment, Range as TypeRange } from 'quill';\nimport type { TableMainFormat, TableWrapperFormat } from '../formats';\nimport type { TableUp } from '../table-up';\nimport type { Position, RelactiveRect, TableSelectionOptions } from '../utils';\nimport Quill from 'quill';\nimport { getTableMainRect, TableCellFormat, TableCellInnerFormat } from '../formats';\nimport { addScrollEvent, AutoScroller, blotName, clearScrollEvent, createBEM, createResizeObserver, findAllParentBlot, findParentBlot, getElementScrollPosition, getRelativeRect, isRectanglesIntersect, tableUpEvent, tableUpInternal } from '../utils';\nimport { pasteCells } from './table-clipboard';\nimport { TableDomSelector } from './table-dom-selector';\nimport { copyCell } from './table-menu/constants';\n\nconst ERROR_LIMIT = 0;\n\nexport interface SelectionData {\n  anchorNode: Node | null;\n  anchorOffset: number;\n  focusNode: Node | null;\n  focusOffset: number;\n}\n\nexport class TableSelection extends TableDomSelector {\n  static moduleName: string = tableUpInternal.tableSelectionName;\n\n  options: TableSelectionOptions;\n  boundary: RelactiveRect | null = null;\n  scrollRecordEls: HTMLElement[] = [];\n  startScrollRecordPosition: Position[] = [];\n  selectedTableScrollX: number = 0;\n  selectedTableScrollY: number = 0;\n  selectedEditorScrollX: number = 0;\n  selectedEditorScrollY: number = 0;\n  selectedTds: TableCellInnerFormat[] = [];\n  cellSelectWrap: HTMLElement;\n  cellSelect: HTMLElement;\n  scrollHandler: [HTMLElement, (...args: any[]) => void][] = [];\n  resizeObserver: ResizeObserver;\n  isDisplaySelection = false;\n  bem = createBEM('selection');\n  autoScroller: AutoScroller;\n  lastSelection: SelectionData = {\n    anchorNode: null,\n    anchorOffset: 0,\n    focusNode: null,\n    focusOffset: 0,\n  };\n\n  _dragging: boolean = false;\n  set dragging(val: boolean) {\n    if (this._dragging === val) return;\n    this._dragging = val;\n    this.quill.emitter.emit(val ? tableUpEvent.TABLE_SELECTION_DRAG_START : tableUpEvent.TABLE_SELECTION_DRAG_END, this);\n  }\n\n  get dragging() {\n    return this._dragging;\n  }\n\n  constructor(public tableModule: TableUp, public quill: Quill, options: Partial<TableSelectionOptions> = {}) {\n    super(tableModule, quill);\n    this.options = this.resolveOptions(options);\n    this.scrollRecordEls = [this.quill.root, document.documentElement];\n\n    this.cellSelectWrap = tableModule.addContainer(this.bem.b());\n    this.cellSelect = this.helpLinesInitial();\n\n    this.resizeObserver = createResizeObserver(this.updateAfterEvent, { ignoreFirstBind: true });\n    this.resizeObserver.observe(this.quill.root);\n\n    document.addEventListener('paste', this.handlePaste);\n    this.quill.emitter.listenDOM('selectionchange', document, this.selectionChangeHandler.bind(this));\n    this.quill.on(tableUpEvent.AFTER_TABLE_RESIZE, this.updateAfterEvent);\n    this.quill.on(Quill.events.SELECTION_CHANGE, this.quillSelectionChangeHandler);\n    this.quill.on(Quill.events.EDITOR_CHANGE, this.updateWhenTextChange);\n\n    this.autoScroller = new AutoScroller(50, 40);\n    this.hide();\n  }\n\n  handlePaste = (event: ClipboardEvent) => {\n    const activeElement = document.activeElement && this.quill.root.contains(document.activeElement);\n    if (!activeElement || this.quill.getSelection()) return;\n\n    const clipboardData = event.clipboardData;\n    if (!clipboardData) return;\n    event.preventDefault();\n\n    const currentSelectedTds = this.selectedTds;\n    if (currentSelectedTds.length <= 0) return;\n\n    const html = clipboardData.getData('text/html');\n    const delta = this.quill.clipboard.convert({ html }).ops.filter(op => op.attributes?.[blotName.tableCellInner]);\n\n    if (delta.length === 0) return;\n\n    pasteCells(\n      { quill: this.quill, talbeModule: this.tableModule },\n      currentSelectedTds,\n      delta,\n    );\n  };\n\n  keyboardHandler = async (e: KeyboardEvent) => {\n    if (e.ctrlKey) {\n      switch (e.key) {\n        case 'c':\n        case 'x': {\n          await copyCell(this.tableModule, this.selectedTds, e.key === 'x');\n          break;\n        }\n      }\n    }\n    else if (e.key === 'Backspace' || e.key === 'Delete') {\n      this.removeCellBySelectedTds();\n    }\n  };\n\n  updateWhenTextChange = (eventName: string) => {\n    if (eventName === Quill.events.TEXT_CHANGE) {\n      if (this.table && !this.quill.root.contains(this.table)) {\n        this.setSelectionTable(undefined);\n      }\n      else {\n        this.updateAfterEvent();\n      }\n    }\n  };\n\n  updateAfterEvent = () => {\n    // if any cell doesn't exist, selection will be cleared\n    for (const td of this.selectedTds) {\n      if (!td.domNode.isConnected) {\n        this.selectedTds = [];\n        break;\n      }\n    }\n    this.updateWithSelectedTds();\n  };\n\n  removeCellBySelectedTds() {\n    const range = this.quill.getSelection();\n    const activeElement = document.activeElement;\n    if (range || !this.quill.root.contains(activeElement)) return;\n\n    if (this.table) {\n      const tableMain = Quill.find(this.table) as TableMainFormat;\n      const cells = tableMain.descendants(TableCellInnerFormat);\n      if (this.selectedTds.length === cells.length) {\n        tableMain.remove();\n        return;\n      }\n    }\n    for (const td of this.selectedTds) {\n      const clearTd = td.clone() as TypeParchment.Parent;\n      clearTd.appendChild(td.scroll.create('block'));\n      td.parent.insertBefore(clearTd, td);\n      td.remove();\n    }\n  }\n\n  setSelectedTds(tds: TableCellInnerFormat[]) {\n    const currentSelectedTds = new Set(this.selectedTds);\n    const isSame = this.selectedTds.length === tds.length && tds.every(td => currentSelectedTds.has(td));\n\n    this.selectedTds = tds;\n    if (!isSame) {\n      this.quill.emitter.emit(tableUpEvent.TABLE_SELECTION_CHANGE, this, this.selectedTds);\n    }\n  }\n\n  quillSelectionChangeHandler = (range: TypeRange | null, _oldRange: TypeRange | null, source: EmitterSource) => {\n    if (source === Quill.sources.API) return;\n    if (range && !this.quill.composition.isComposing && this.selectedTds.length > 0) {\n      const formats = this.quill.getFormat(range);\n      const [line] = this.quill.getLine(range.index);\n      const isInCell = !!formats[blotName.tableCellInner] && !!line;\n      // if the selection is in the cell inner, should not update\n      const containsLine = line && this.selectedTds.some(td => td.domNode.contains(line.domNode));\n\n      if (isInCell && !containsLine) {\n        try {\n          const cellInner = findParentBlot(line!, blotName.tableCellInner) as TableCellInnerFormat;\n          this.setSelectedTds([cellInner]);\n          this.updateWithSelectedTds();\n        }\n        catch {\n          // do nothing. should not into here\n        }\n      }\n      else if (!(isInCell && containsLine)) {\n        this.hide();\n      }\n    }\n  };\n\n  setSelectionData(selection: Selection, selectionData: SelectionData) {\n    const { anchorNode, anchorOffset, focusNode, focusOffset } = selectionData;\n    if (!anchorNode || !focusNode) return;\n    const range = document.createRange();\n    const isUpFromDown = this.selectionDirectionUp(selectionData);\n    if (isUpFromDown) {\n      range.setStart(anchorNode, anchorOffset);\n      range.setEnd(anchorNode, anchorOffset);\n    }\n    else {\n      range.setStart(anchorNode, anchorOffset);\n      range.setEnd(focusNode, focusOffset);\n    }\n    selection.removeAllRanges();\n    selection.addRange(range);\n    if (isUpFromDown) {\n      selection.extend(focusNode, focusOffset);\n    }\n  }\n\n  selectionDirectionUp(selection: SelectionData) {\n    const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n    if (!anchorNode || !focusNode) return false;\n\n    if (anchorNode === focusNode) {\n      return anchorOffset > focusOffset;\n    }\n\n    const nodePosition = anchorNode.compareDocumentPosition(focusNode);\n    // focus contains anchor\n    if (nodePosition & Node.DOCUMENT_POSITION_CONTAINS) {\n      // is anchor before focus\n      return (nodePosition & Node.DOCUMENT_POSITION_FOLLOWING) !== 0;\n    }\n\n    // anchor contains focus\n    if (nodePosition & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      // is focus before anchor\n      return (nodePosition & Node.DOCUMENT_POSITION_FOLLOWING) !== 0;\n    }\n\n    // compare position\n    return (nodePosition & Node.DOCUMENT_POSITION_PRECEDING) !== 0;\n  }\n\n  resolveOptions(options: Partial<TableSelectionOptions>): TableSelectionOptions {\n    return Object.assign({\n      selectColor: '#0589f340',\n    } as TableSelectionOptions, options);\n  }\n\n  selectionChangeHandler() {\n    const selection = window.getSelection();\n    if (!selection) return;\n    const { anchorNode, focusNode, anchorOffset, focusOffset } = selection;\n    if (!anchorNode || !focusNode) return;\n\n    const anchorBlot = Quill.find(anchorNode) as TypeParchment.Blot;\n    const focusBlot = Quill.find(focusNode) as TypeParchment.Blot;\n    if (!anchorBlot || !focusBlot || anchorBlot.scroll !== this.quill.scroll || focusBlot.scroll !== this.quill.scroll) return;\n\n    const anchorNames = findAllParentBlot(anchorBlot);\n    const focusNames = findAllParentBlot(focusBlot);\n\n    // if cursor into colgourp should into table or out table by lastSelection\n    const isAnchorInColgroup = anchorNames.has(blotName.tableColgroup);\n    const isFocusInColgroup = focusNames.has(blotName.tableColgroup);\n    if (isAnchorInColgroup || isFocusInColgroup) {\n      let newAnchorNode = anchorNode;\n      let newAnchorOffset = anchorOffset;\n      let newFocusNode = focusNode;\n      let newFocusOffset = focusOffset;\n      // default move cursor to first cell\n      if (isAnchorInColgroup) {\n        const tableWrapperBlot = anchorNames.get(blotName.tableWrapper) as TableWrapperFormat;\n        const cellInner = tableWrapperBlot.descendants(TableCellInnerFormat);\n        if (cellInner.length > 0) {\n          newAnchorNode = cellInner[0].domNode;\n          newAnchorOffset = 0;\n        }\n      }\n      if (isFocusInColgroup) {\n        const tableWrapperBlot = focusNames.get(blotName.tableWrapper) as TableWrapperFormat;\n        const cellInner = tableWrapperBlot.descendants(TableCellInnerFormat);\n        if (cellInner.length > 0) {\n          newFocusNode = cellInner[0].domNode;\n          newFocusOffset = 0;\n        }\n      }\n      this.setSelectionData(selection, {\n        anchorNode: newAnchorNode,\n        anchorOffset: newAnchorOffset,\n        focusNode: newFocusNode,\n        focusOffset: newFocusOffset,\n      });\n      return;\n    }\n\n    // if the selection in the table partial\n    const isAnchorInCellInner = anchorNames.has(blotName.tableCellInner);\n    const isFocusInCellInner = focusNames.has(blotName.tableCellInner);\n    let isNotSameCellInner = isAnchorInCellInner && isFocusInCellInner;\n    if (isNotSameCellInner) {\n      const anchorCellBlot = anchorNames.get(blotName.tableCellInner) as TableCellInnerFormat;\n      const focusCellBlot = focusNames.get(blotName.tableCellInner) as TableCellInnerFormat;\n      isNotSameCellInner &&= (anchorCellBlot !== focusCellBlot);\n    }\n    if (\n      (isAnchorInCellInner && isFocusInCellInner && isNotSameCellInner)\n      || (!isAnchorInCellInner && isFocusInCellInner)\n      || (!isFocusInCellInner && isAnchorInCellInner)\n    ) {\n      this.setSelectionData(selection, this.lastSelection);\n      if (this.selectedTds.length > 0) {\n        this.hide();\n      }\n      return;\n    }\n\n    this.lastSelection = {\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset,\n    };\n  }\n\n  helpLinesInitial() {\n    this.cellSelectWrap.style.setProperty('--select-color', this.options.selectColor);\n    const cellSelect = document.createElement('div');\n    cellSelect.classList.add(this.bem.be('line'));\n    this.cellSelectWrap.appendChild(cellSelect);\n    return cellSelect;\n  }\n\n  computeSelectedTds(startPoint: Position, endPoint: Position) {\n    if (!this.table) return [];\n    type TempSortedTableCellFormat = TableCellFormat & { index?: number; __rect?: DOMRect };\n\n    const tableMainBlot = Quill.find(this.table) as TableMainFormat;\n    if (!tableMainBlot) return [];\n    // Use TableCell to calculation selected range, because TableCellInner is scrollable, the width will effect calculate\n    const tableCells = new Set(\n      // reverse cell. search from bottom.\n      // when mouse click on the cell border. the selection will be in the lower cell.\n      // but `isRectanglesIntersect` judge intersect include border. the upper cell bottom border will intersect with boundary\n      // so need to search the cell from bottom\n      (tableMainBlot.descendants(TableCellFormat) as TempSortedTableCellFormat[]).map((cell, i) => {\n        cell.index = i;\n        return cell;\n      }),\n    );\n\n    const scrollDiff = this.getScrollPositionDiff();\n    // set boundary to initially mouse move rectangle\n    const { rect: tableRect } = getTableMainRect(tableMainBlot);\n    if (!tableRect) return [];\n    const startPointX = startPoint.x + scrollDiff.x;\n    const startPointY = startPoint.y + scrollDiff.y;\n    let boundary = {\n      x: Math.max(tableRect.left, Math.min(endPoint.x, startPointX)),\n      y: Math.max(tableRect.top, Math.min(endPoint.y, startPointY)),\n      x1: Math.min(tableRect.right, Math.max(endPoint.x, startPointX)),\n      y1: Math.min(tableRect.bottom, Math.max(endPoint.y, startPointY)),\n    };\n\n    const selectedCells = new Set<TempSortedTableCellFormat>();\n    let findEnd = true;\n    // loop all cells to find correct boundary\n    while (findEnd) {\n      findEnd = false;\n      for (const cell of tableCells) {\n        if (!cell.__rect) {\n          cell.__rect = cell.domNode.getBoundingClientRect();\n        }\n        // Determine whether the cell intersects with the current boundary\n        const { x, y, right, bottom } = cell.__rect;\n        // bowser MouseEvent clientY\\clientX is floored. judge data need floored too\n        if (\n          isRectanglesIntersect(\n            { x: Math.floor(boundary.x), y: Math.floor(boundary.y), x1: Math.floor(boundary.x1), y1: Math.floor(boundary.y1) },\n            { x: Math.floor(x), y: Math.floor(y), x1: Math.floor(right), y1: Math.floor(bottom) },\n            ERROR_LIMIT,\n            selectedCells.size === 0,\n          )\n        ) {\n          // add cell to selected\n          selectedCells.add(cell);\n          tableCells.delete(cell);\n          // update boundary\n          boundary = {\n            x: Math.min(boundary.x, x),\n            y: Math.min(boundary.y, y),\n            x1: Math.max(boundary.x1, right),\n            y1: Math.max(boundary.y1, bottom),\n          };\n          // recalculate boundary last cells\n          findEnd = true;\n          break;\n        }\n      }\n    }\n    for (const cell of [...selectedCells, ...tableCells]) {\n      delete cell.__rect;\n    }\n    // save result boundary relative to the editor\n    this.boundary = getRelativeRect({\n      ...boundary,\n      width: boundary.x1 - boundary.x,\n      height: boundary.y1 - boundary.y,\n    }, this.quill.root);\n    return Array.from(selectedCells).toSorted((a, b) => a.index! - b.index!).map((cell) => {\n      delete cell.index;\n      return cell.getCellInner();\n    });\n  }\n\n  getScrollPositionDiff() {\n    const { x: tableScrollX, y: tableScrollY } = this.getTableViewScroll();\n    const { x: editorScrollX, y: editorScrollY } = getElementScrollPosition(this.quill.root);\n    this.selectedTableScrollX = tableScrollX;\n    this.selectedTableScrollY = tableScrollY;\n    this.selectedEditorScrollX = editorScrollX;\n    this.selectedEditorScrollY = editorScrollY;\n\n    return this.startScrollRecordPosition.reduce((pre, { x, y }, i) => {\n      const { x: currentX, y: currentY } = getElementScrollPosition(this.scrollRecordEls[i]);\n      pre.x += x - currentX;\n      pre.y += y - currentY;\n      return pre;\n    }, { x: 0, y: 0 });\n  }\n\n  recordScrollPosition() {\n    this.clearRecordScrollPosition();\n    for (const el of this.scrollRecordEls) {\n      this.startScrollRecordPosition.push(getElementScrollPosition(el));\n    }\n  }\n\n  clearRecordScrollPosition() {\n    this.startScrollRecordPosition = [];\n  }\n\n  tableSelectHandler(mousedownEvent: MouseEvent) {\n    const { button, target, clientX, clientY } = mousedownEvent;\n    const closestTable = (target as HTMLElement).closest<HTMLTableElement>('table');\n    const closestTableCaption = (target as HTMLElement).closest('caption');\n    if (button !== 0 || !closestTable || closestTableCaption) return;\n\n    this.setSelectionTable(closestTable);\n    const startTableId = closestTable.dataset.tableId;\n    const startPoint = { x: clientX, y: clientY };\n\n    this.recordScrollPosition();\n    this.setSelectedTds(this.computeSelectedTds(startPoint, startPoint));\n    this.show();\n\n    const mouseMoveHandler = (mousemoveEvent: MouseEvent) => {\n      this.dragging = true;\n      const { button, target, clientX, clientY } = mousemoveEvent;\n      const closestTable = (target as HTMLElement).closest<HTMLTableElement>('.ql-table');\n      const closestTableCaption = (target as HTMLElement).closest('caption');\n      if (\n        button !== 0\n        || closestTableCaption\n        || !closestTable || closestTable.dataset.tableId !== startTableId\n      ) {\n        return;\n      }\n\n      const movePoint = { x: clientX, y: clientY };\n      this.setSelectedTds(this.computeSelectedTds(startPoint, movePoint));\n      if (this.selectedTds.length > 1) {\n        this.quill.blur();\n      }\n      this.update();\n      this.autoScroller.updateMousePosition(clientX, clientY);\n    };\n    const mouseUpHandler = () => {\n      document.body.removeEventListener('mousemove', mouseMoveHandler, false);\n      document.body.removeEventListener('mouseup', mouseUpHandler, false);\n      this.autoScroller.stop();\n      this.dragging = false;\n      this.clearRecordScrollPosition();\n    };\n\n    document.body.addEventListener('mousemove', mouseMoveHandler, false);\n    document.body.addEventListener('mouseup', mouseUpHandler, false);\n    const tableMain = Quill.find(closestTable) as TableMainFormat;\n    if (!tableMain) return;\n    const tableWrapper = tableMain.parent!.domNode as HTMLElement;\n    this.autoScroller.updateMousePosition(clientX, clientY);\n    this.autoScroller.start(tableWrapper);\n  }\n\n  updateWithSelectedTds() {\n    if (this.selectedTds.length <= 0) {\n      this.hide();\n      return;\n    }\n    const startPoint = { x: Infinity, y: Infinity };\n    const endPoint = { x: -Infinity, y: -Infinity };\n    for (const td of this.selectedTds) {\n      const rect = td.domNode.getBoundingClientRect();\n      startPoint.x = Math.min(startPoint.x, rect.left);\n      startPoint.y = Math.min(startPoint.y, rect.top);\n      endPoint.x = Math.max(endPoint.x, rect.right);\n      endPoint.y = Math.max(endPoint.y, rect.bottom);\n    }\n    this.setSelectedTds(this.computeSelectedTds(startPoint, endPoint));\n    if (this.selectedTds.length > 0) {\n      this.update();\n    }\n    else {\n      this.hide();\n    }\n  }\n\n  update() {\n    if (!this.table) {\n      this.hide();\n      return;\n    }\n    if (this.selectedTds.length === 0 || !this.boundary) return;\n    const { x: editorScrollX, y: editorScrollY } = getElementScrollPosition(this.quill.root);\n    const { x: tableScrollX, y: tableScrollY } = this.getTableViewScroll();\n    const tableWrapperRect = this.table.parentElement!.getBoundingClientRect();\n    const rootRect = this.quill.root.getBoundingClientRect();\n    const wrapLeft = tableWrapperRect.x - rootRect.x;\n    const wrapTop = tableWrapperRect.y - rootRect.y;\n\n    Object.assign(this.cellSelect.style, {\n      left: `${this.selectedEditorScrollX * 2 - editorScrollX + this.boundary.x + this.selectedTableScrollX - tableScrollX - wrapLeft}px`,\n      top: `${this.selectedEditorScrollY * 2 - editorScrollY + this.boundary.y + this.selectedTableScrollY - tableScrollY - wrapTop}px`,\n      width: `${this.boundary.width}px`,\n      height: `${this.boundary.height}px`,\n    });\n    Object.assign(this.cellSelectWrap.style, {\n      left: `${wrapLeft}px`,\n      top: `${wrapTop}px`,\n      width: `${tableWrapperRect.width}px`,\n      height: `${tableWrapperRect.height}px`,\n    });\n    this.quill.emitter.emit(tableUpEvent.TABLE_SELECTION_DISPLAY_CHANGE, this);\n  }\n\n  getTableViewScroll() {\n    if (!this.table) {\n      return {\n        x: 0,\n        y: 0,\n      };\n    }\n    return getElementScrollPosition(this.table.parentElement!);\n  }\n\n  setSelectionTable(table: HTMLTableElement | undefined) {\n    if (this.table === table) return;\n    this.table = table;\n    if (this.table) {\n      this.scrollRecordEls.push(this.table.parentElement!);\n    }\n    else {\n      this.scrollRecordEls.pop();\n    }\n  }\n\n  showDisplay() {\n    Object.assign(this.cellSelectWrap.style, { display: 'block' });\n    this.isDisplaySelection = true;\n    if (!this.table) return;\n    this.resizeObserver.observe(this.table);\n  }\n\n  show() {\n    if (!this.table) return;\n    clearScrollEvent.call(this);\n\n    this.showDisplay();\n    this.update();\n    this.quill.root.addEventListener('keydown', this.keyboardHandler);\n    addScrollEvent.call(this, this.quill.root, () => {\n      this.update();\n    });\n    addScrollEvent.call(this, this.table.parentElement!, () => {\n      this.update();\n    });\n  }\n\n  hideDisplay() {\n    Object.assign(this.cellSelectWrap.style, { display: 'none' });\n    this.isDisplaySelection = false;\n    if (!this.table) return;\n    this.resizeObserver.unobserve(this.table);\n  }\n\n  hide() {\n    clearScrollEvent.call(this);\n    this.quill.root.removeEventListener('keydown', this.keyboardHandler);\n    this.hideDisplay();\n    this.boundary = null;\n    this.setSelectedTds([]);\n    this.setSelectionTable(undefined);\n  }\n\n  destroy() {\n    this.resizeObserver.disconnect();\n\n    this.hide();\n    this.cellSelectWrap.remove();\n    clearScrollEvent.call(this);\n\n    document.removeEventListener('paste', this.handlePaste);\n    this.quill.off(tableUpEvent.AFTER_TABLE_RESIZE, this.updateAfterEvent);\n    this.quill.off(Quill.events.EDITOR_CHANGE, this.updateWhenTextChange);\n    this.quill.off(Quill.events.SELECTION_CHANGE, this.quillSelectionChangeHandler);\n  }\n}\n","import type { EmitterSource, Op, Parchment as TypeParchment, Range as TypeRange } from 'quill';\nimport type { BlockEmbed as TypeBlockEmbed } from 'quill/blots/block';\nimport type TypeBlock from 'quill/blots/block';\nimport type { Context } from 'quill/modules/keyboard';\nimport type TypeKeyboard from 'quill/modules/keyboard';\nimport type TypeToolbar from 'quill/modules/toolbar';\nimport type { TableSelection } from './modules';\nimport type { Constructor, QuillTheme, QuillThemePicker, TableBodyTag, TableCellValue, TableConstantsData, TableTextOptions, TableUpOptions } from './utils';\nimport Quill from 'quill';\nimport { BlockEmbedOverride, BlockOverride, ContainerFormat, ScrollOverride, TableBodyFormat, TableCaptionFormat, TableCellFormat, TableCellInnerFormat, TableColFormat, TableColgroupFormat, TableFootFormat, TableHeadFormat, TableMainFormat, TableRowFormat, TableWrapperFormat } from './formats';\nimport { TableClipboard } from './modules';\nimport { blotName, createBEM, createSelectBox, cssTextToObject, debounce, findParentBlot, findParentBlots, getScrollBarWidth, isForbidInTable, isFunction, isNumber, isString, isSubclassOf, isUndefined, limitDomInViewPort, mixinClass, objectToCssText, randomId, tableCantInsert, tableUpEvent, tableUpInternal, tableUpSize, toCamelCase } from './utils';\n\nconst Parchment = Quill.import('parchment');\nconst Delta = Quill.import('delta');\nconst icons = Quill.import('ui/icons') as Record<string, any>;\nconst Break = Quill.import('blots/break') as TypeParchment.BlotConstructor;\nconst Block = Quill.import('blots/block') as typeof TypeBlock;\nconst BlockEmbed = Quill.import('blots/block/embed') as typeof TypeBlockEmbed;\n\nfunction createCell(scroll: TypeParchment.ScrollBlot, { tableId, rowId, colId }: { tableId: string; rowId: string; colId: string }) {\n  const value = {\n    tableId,\n    rowId,\n    colId,\n    colspan: 1,\n    rowspan: 1,\n  };\n  const tableCell = scroll.create(blotName.tableCell, value) as TypeParchment.ParentBlot;\n  const tableCellInner = scroll.create(blotName.tableCellInner, value) as TypeParchment.ParentBlot;\n  const block = scroll.create('block') as TypeParchment.ParentBlot;\n  block.appendChild(scroll.create('break'));\n  tableCellInner.appendChild(block);\n  tableCell.appendChild(tableCellInner);\n  return tableCell;\n}\nexport function updateTableConstants(data: Partial<TableConstantsData>) {\n  tableCantInsert.delete(blotName.tableCellInner);\n\n  Object.assign(blotName, data.blotName || {});\n  Object.assign(tableUpSize, data.tableUpSize || {});\n  Object.assign(tableUpEvent, data.tableUpEvent || {});\n  Object.assign(tableUpInternal, data.tableUpInternal || {});\n\n  TableUp.moduleName = tableUpInternal.moduleName;\n\n  TableUp.toolName = blotName.tableWrapper;\n  ContainerFormat.blotName = blotName.container;\n  TableCaptionFormat.blotName = blotName.tableCaption;\n  TableWrapperFormat.blotName = blotName.tableWrapper;\n  TableMainFormat.blotName = blotName.tableMain;\n  TableColgroupFormat.blotName = blotName.tableColgroup;\n  TableColFormat.blotName = blotName.tableCol;\n  TableHeadFormat.blotName = blotName.tableHead;\n  TableBodyFormat.blotName = blotName.tableBody;\n  TableFootFormat.blotName = blotName.tableFoot;\n  TableRowFormat.blotName = blotName.tableRow;\n  TableCellFormat.blotName = blotName.tableCell;\n  TableCellInnerFormat.blotName = blotName.tableCellInner;\n\n  tableCantInsert.add(blotName.tableCellInner);\n}\nexport function defaultCustomSelect(tableModule: TableUp, picker: QuillThemePicker) {\n  return createSelectBox({\n    onSelect: (row: number, col: number) => {\n      tableModule.insertTable(row, col, Quill.sources.USER);\n      if (picker) {\n        picker.close();\n      }\n    },\n    customBtn: tableModule.options.customBtn,\n    texts: tableModule.options.texts,\n  });\n}\n\nfunction generateTableArrowHandler(up: boolean) {\n  return {\n    bindInHead: false,\n    key: up ? 'ArrowUp' : 'ArrowDown',\n    collapsed: true,\n    format: [blotName.tableCellInner],\n    handler(this: { quill: Quill }, range: TypeRange, context: Context) {\n      const direction = up ? 'prev' : 'next';\n      const childDirection = up ? 'tail' : 'head';\n      if (context.line[direction]) return true;\n\n      // TODO: if there have a very long text in cell, the line will auto wrap\n      // there is no good way to find the correct index of the last `line`\n      const cursorRect = this.quill.selection.getBounds(range.index);\n      const lineRect = context.line.domNode.getBoundingClientRect();\n      if (!cursorRect || !lineRect) return true;\n      if (up) {\n        if (cursorRect.top - lineRect.top > 3) {\n          return true;\n        }\n      }\n      else {\n        if (lineRect.bottom - cursorRect.bottom > 3) {\n          return true;\n        }\n      }\n\n      let tableBlot: TableWrapperFormat;\n      let tableMain: TableMainFormat;\n      let tableRow: TableRowFormat;\n      let tableCell: TableCellFormat;\n      try {\n        [tableBlot, tableMain, tableRow, tableCell] = findParentBlots(context.line, [blotName.tableWrapper, blotName.tableMain, blotName.tableRow, blotName.tableCell] as const);\n      }\n      catch {\n        return true;\n      }\n\n      const colIds = tableMain.getColIds();\n      const tableCaption = tableBlot.descendants(TableCaptionFormat, 0)[0];\n\n      let aroundLine;\n      if (tableCaption) {\n        const captionSide = window.getComputedStyle(tableCaption.domNode);\n        if (direction === 'next' && captionSide.captionSide === 'bottom') {\n          aroundLine = tableCaption;\n        }\n        else if (direction === 'next') {\n          aroundLine = tableBlot.next;\n        }\n        else {\n          aroundLine = tableCaption;\n        }\n      }\n      else {\n        aroundLine = tableBlot[direction];\n      }\n      if (context.line[direction] || !aroundLine) return true;\n\n      const targetRow = tableRow[direction] as TableRowFormat;\n      if (targetRow) {\n        const cellIndex = colIds.indexOf(tableCell.colId);\n        const targetCell = targetRow.getCellByColId(colIds[cellIndex], direction);\n        if (!targetCell) return true;\n        let targetChild = targetCell.children[childDirection] as TypeParchment.ParentBlot;\n        if (targetChild.children) {\n          targetChild = targetChild.children[childDirection] as TypeParchment.ParentBlot;\n        }\n        const index = targetChild.offset(this.quill.scroll) + Math.min(context.offset, targetChild.length() - 1);\n        this.quill.setSelection(index, 0, Quill.sources.USER);\n      }\n      else {\n        const index = aroundLine.offset(this.quill.scroll) + (up ? aroundLine.length() - 1 : 0);\n        this.quill.setSelection(index, 0, Quill.sources.USER);\n      }\n      return false;\n    },\n  };\n}\n\nexport class TableUp {\n  static moduleName: string = tableUpInternal.moduleName;\n  static toolName: string = blotName.tableWrapper;\n  // TODO: add custom property `bindInHead`, but Quill doesn't export `BindingObject`\n  static keyboradHandler = {\n    'forbid remove table by backspace': {\n      bindInHead: true,\n      key: 'Backspace',\n      collapsed: true,\n      offset: 0,\n      handler(this: { quill: Quill }, range: TypeRange, context: Context) {\n        const line = this.quill.getLine(range.index);\n        const blot = line[0] as TypeParchment.BlockBlot;\n        if (blot.prev instanceof TableWrapperFormat) {\n          blot.prev.remove();\n          return false;\n        }\n\n        if (context.format[blotName.tableCellInner]) {\n          const offset = blot.offset(findParentBlot(blot, blotName.tableCellInner));\n          if (offset === 0) {\n            return false;\n          }\n        }\n\n        return true;\n      },\n    },\n    'forbid remove table by delete': {\n      bindInHead: true,\n      key: 'Delete',\n      collapsed: true,\n      handler(this: { quill: Quill }, range: TypeRange, context: Context) {\n        const line = this.quill.getLine(range.index);\n        const blot = line[0] as TypeParchment.BlockBlot;\n        const offsetInline = line[1];\n        if ((blot.next instanceof TableWrapperFormat || blot.next instanceof TableColFormat) && offsetInline === blot.length() - 1) return false;\n\n        if (context.format[blotName.tableCellInner]) {\n          const tableInnerBlot = findParentBlot(blot, blotName.tableCellInner);\n          if (blot === tableInnerBlot.children.tail && offsetInline === blot.length() - 1) {\n            return false;\n          }\n        }\n        return true;\n      },\n    },\n    'table up': generateTableArrowHandler(true),\n    'table down': generateTableArrowHandler(false),\n    'table caption break': {\n      bindInHead: true,\n      key: 'Enter',\n      shiftKey: null,\n      format: [blotName.tableCaption],\n      handler(this: { quill: Quill }, _range: TypeRange, _context: Context) {\n        return false;\n      },\n    },\n  };\n\n  static register() {\n    TableWrapperFormat.allowedChildren = [TableMainFormat];\n\n    TableMainFormat.allowedChildren = [TableColgroupFormat, TableCaptionFormat, TableHeadFormat, TableBodyFormat, TableFootFormat];\n    TableMainFormat.requiredContainer = TableWrapperFormat;\n\n    TableCaptionFormat.requiredContainer = TableMainFormat;\n\n    TableColgroupFormat.allowedChildren = [TableColFormat];\n    TableColgroupFormat.requiredContainer = TableMainFormat;\n\n    TableHeadFormat.allowedChildren = [TableRowFormat];\n    TableHeadFormat.requiredContainer = TableMainFormat;\n    TableBodyFormat.allowedChildren = [TableRowFormat];\n    TableBodyFormat.requiredContainer = TableMainFormat;\n    TableFootFormat.allowedChildren = [TableRowFormat];\n    TableFootFormat.requiredContainer = TableMainFormat;\n\n    TableRowFormat.allowedChildren = [TableCellFormat];\n\n    TableCellFormat.allowedChildren = [TableCellInnerFormat, Break];\n    TableCellFormat.requiredContainer = TableRowFormat;\n\n    TableCellInnerFormat.requiredContainer = TableCellFormat;\n\n    // override Block and BlockEmbed\n    const excludeFormat = new Set(['table']);\n    const overrideFormats = Object.entries(Quill.imports as Record<string, Constructor>).filter(([name, blot]) => {\n      const blotName = name.split('formats/')[1];\n      return name.startsWith('formats/')\n        && !excludeFormat.has(blotName)\n        && (isSubclassOf(blot, Block) || isSubclassOf(blot, BlockEmbed));\n    });\n    const overrides = overrideFormats.reduce((pre, [name, blot]) => {\n      const extendsClass = isSubclassOf(blot, BlockEmbed) ? BlockEmbedOverride : BlockOverride;\n      pre[name] = class extends mixinClass(blot, [extendsClass]) {\n        static register() {}\n      };\n      return pre;\n    }, {} as Record<string, Constructor>);\n\n    Quill.register({\n      'blots/scroll': ScrollOverride,\n      'blots/block': BlockOverride,\n      'blots/block/embed': BlockEmbedOverride,\n      ...overrides,\n      [`blots/${blotName.container}`]: ContainerFormat,\n      [`formats/${blotName.tableCell}`]: TableCellFormat,\n      [`formats/${blotName.tableCellInner}`]: TableCellInnerFormat,\n      [`formats/${blotName.tableRow}`]: TableRowFormat,\n      [`formats/${blotName.tableHead}`]: TableHeadFormat,\n      [`formats/${blotName.tableBody}`]: TableBodyFormat,\n      [`formats/${blotName.tableFoot}`]: TableFootFormat,\n      [`formats/${blotName.tableCol}`]: TableColFormat,\n      [`formats/${blotName.tableColgroup}`]: TableColgroupFormat,\n      [`formats/${blotName.tableCaption}`]: TableCaptionFormat,\n      [`formats/${blotName.tableMain}`]: TableMainFormat,\n      [`formats/${blotName.tableWrapper}`]: TableWrapperFormat,\n      'modules/clipboard': TableClipboard,\n    }, true);\n  }\n\n  quill: Quill;\n  options: TableUpOptions;\n  toolBox: HTMLDivElement;\n  fixTableByLisenter = debounce(this.balanceTables, 100);\n  selector?: HTMLElement;\n  resizeOb!: ResizeObserver;\n  modules: Record<string, Constructor> = {};\n\n  get statics(): any {\n    return this.constructor;\n  }\n\n  constructor(quill: Quill, options: Partial<TableUpOptions>) {\n    this.quill = quill;\n    this.options = this.resolveOptions(options || {});\n    this.toolBox = this.initialContainer();\n\n    const toolbar = this.quill.getModule('toolbar') as TypeToolbar;\n    if (toolbar && (this.quill.theme as QuillTheme).pickers) {\n      const [, select] = (toolbar.controls as [string, HTMLElement][] || []).find(([name]) => name === this.statics.toolName) || [];\n      if (select && select.tagName.toLocaleLowerCase() === 'select') {\n        const picker = (this.quill.theme as QuillTheme).pickers.find(picker => picker.select === select);\n        if (picker) {\n          picker.label.innerHTML = this.options.icon;\n          this.buildCustomSelect(this.options.customSelect, picker);\n          picker.label.addEventListener('mousedown', () => {\n            if (!this.selector || !picker) return;\n            const selectRect = this.selector.getBoundingClientRect();\n            const { leftLimited } = limitDomInViewPort(selectRect);\n            if (leftLimited) {\n              const labelRect = picker.label.getBoundingClientRect();\n              Object.assign(picker.options.style, { transform: `translateX(calc(-100% + ${labelRect.width}px))` });\n            }\n            else {\n              Object.assign(picker.options.style, { transform: undefined });\n            }\n          });\n        }\n      }\n    }\n\n    const keyboard = this.quill.getModule('keyboard') as TypeKeyboard;\n    for (const handle of Object.values(TableUp.keyboradHandler)) {\n      // insert before default key handler\n      if (handle.bindInHead) {\n        keyboard.bindings[handle.key].unshift(handle);\n      }\n      else {\n        keyboard.addBinding(handle.key, handle);\n      }\n    }\n\n    this.initModules();\n    this.quillHack();\n    this.listenBalanceCells();\n  }\n\n  initialContainer() {\n    const toolboxBEM = createBEM('toolbox');\n    const container = this.quill.addContainer(toolboxBEM.b());\n    const updateContainerStyle = () => {\n      const quillRootRect = this.quill.root.getBoundingClientRect();\n      const { offsetLeft, offsetTop } = this.quill.root;\n      Object.assign(container.style, {\n        top: `${offsetTop}px`,\n        left: `${offsetLeft}px`,\n        width: `${quillRootRect.width}px`,\n        height: `${quillRootRect.height}px`,\n      });\n    };\n    this.resizeOb = new ResizeObserver(updateContainerStyle);\n    this.resizeOb.observe(this.quill.root);\n    return container;\n  }\n\n  addContainer(classes: string | HTMLElement) {\n    if (isString(classes)) {\n      const el = document.createElement('div');\n      for (const classname of classes.split(' ')) {\n        el.classList.add(classname);\n      }\n      this.toolBox.appendChild(el);\n      return el;\n    }\n    else {\n      this.toolBox.appendChild(classes);\n      return classes;\n    }\n  }\n\n  resolveOptions(options: Partial<TableUpOptions>): TableUpOptions {\n    return Object.assign({\n      customBtn: false,\n      texts: this.resolveTexts(options.texts || {}),\n      full: false,\n      fullSwitch: true,\n      icon: icons.table,\n      autoMergeCell: true,\n      modules: [],\n    } as TableUpOptions, options);\n  }\n\n  resolveTexts(options: Partial<TableTextOptions>) {\n    return Object.assign({\n      fullCheckboxText: 'Insert full width table',\n      customBtnText: 'Custom',\n      confirmText: 'Confirm',\n      cancelText: 'Cancel',\n      rowText: 'Row',\n      colText: 'Column',\n      notPositiveNumberError: 'Please enter a positive integer',\n      custom: 'Custom',\n      clear: 'Clear',\n      transparent: 'Transparent',\n      perWidthInsufficient: 'The percentage width is insufficient. To complete the operation, the table needs to be converted to a fixed width. Do you want to continue?',\n      CopyCell: 'Copy cell',\n      CutCell: 'Cut cell',\n      InsertTop: 'Insert row above',\n      InsertRight: 'Insert column right',\n      InsertBottom: 'Insert row below',\n      InsertLeft: 'Insert column Left',\n      MergeCell: 'Merge Cell',\n      SplitCell: 'Split Cell',\n      DeleteRow: 'Delete Row',\n      DeleteColumn: 'Delete Column',\n      DeleteTable: 'Delete table',\n      BackgroundColor: 'Set background color',\n      BorderColor: 'Set border color',\n    }, options);\n  }\n\n  initModules() {\n    for (const item of this.options.modules) {\n      this.modules[item.module.moduleName] = new item.module(this, this.quill, item.options);\n    }\n  }\n\n  getModule<T>(name: string) {\n    return this.modules[name] as T | undefined;\n  }\n\n  quillHack() {\n    const originGetSemanticHTML = this.quill.getSemanticHTML;\n    this.quill.getSemanticHTML = ((index: number = 0, length?: number) => {\n      const html = originGetSemanticHTML.call(this.quill, index, length);\n\n      const tableWrapperFormat = Quill.import(`formats/${blotName.tableWrapper}`) as typeof TableWrapperFormat;\n      const parser = new DOMParser();\n      const doc = parser.parseFromString(html, 'text/html');\n      for (const node of Array.from(doc.querySelectorAll(`.${tableWrapperFormat.className} caption[contenteditable], .${tableWrapperFormat.className} .${TableCellFormat.className} > [contenteditable]`))) {\n        node.removeAttribute('contenteditable');\n      }\n\n      return doc.body.innerHTML;\n    }) as typeof originGetSemanticHTML;\n\n    // make sure toolbar item can format selected cells\n    const originFormat = this.quill.format;\n    this.quill.format = function (name: string, value: unknown, source: EmitterSource = Quill.sources.API) {\n      const blot = this.scroll.query(name);\n      // filter embed blot\n      if (!((blot as TypeParchment.BlotConstructor).prototype instanceof Parchment.EmbedBlot)) {\n        const tableUpModule = this.getModule(tableUpInternal.moduleName) as TableUp;\n        const range = this.getSelection(true);\n        const formats = this.getFormat(range);\n        // only when selection in cell and selectedTds > 1 can format all cells\n        const tableSelection = tableUpModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n        if (!formats[blotName.tableCellInner] || range.length > 0 || (tableUpModule && tableSelection && tableSelection.selectedTds.length <= 1)) {\n          return originFormat.call(this, name, value, source);\n        }\n        // format in selected cells\n        if (tableUpModule && tableSelection && tableSelection.selectedTds.length > 0) {\n          const selectedTds = tableSelection.selectedTds;\n          // calculate the format value. the format should be canceled when this value exists in all selected cells\n          let setOrigin = false;\n          const tdRanges = [];\n          for (const innerTd of selectedTds) {\n            const index = innerTd.offset(this.scroll);\n            const length = innerTd.length();\n            tdRanges.push({ index, length });\n            const format = this.getFormat(index, length);\n            if (format[name] !== value) {\n              setOrigin = true;\n            }\n          }\n          const resultValue = setOrigin ? value : false;\n\n          const delta = new Delta();\n          for (const [i, { index, length }] of tdRanges.entries()) {\n            const lastIndex = i === 0 ? 0 : tdRanges[i - 1].index + tdRanges[i - 1].length;\n            delta.retain(index - lastIndex).retain(length, { [name]: resultValue });\n          }\n\n          const updateDelta = this.updateContents(delta, source);\n          this.blur();\n          return updateDelta;\n        }\n      }\n\n      return originFormat.call(this, name, value, source);\n    };\n\n    // handle clean\n    const toolbar = this.quill.theme.modules.toolbar;\n    if (toolbar) {\n      const cleanHandler = toolbar.handlers?.clean;\n      if (cleanHandler) {\n        const cleanFormatExcludeTable = (index: number, length: number, changeCellStyle: false | ((styleStr: string | undefined) => string) = () => '') => {\n          // base on `removeFormat`. but not remove tableCellInner\n          const text = this.quill.getText(index, length);\n          const [line, offset] = this.quill.getLine(index + length);\n          let suffixLength = 0;\n          let suffix = new Delta();\n          if (line != null) {\n            suffixLength = line.length() - offset;\n            suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\\n');\n          }\n          const contents = this.quill.getContents(index, length + suffixLength);\n          const diff = contents.diff(new Delta().insert(text).concat(suffix));\n\n          let deltaIndex = 0;\n          const ops = diff.ops.map((op: Op) => {\n            const { attributes, ...other } = op;\n            if (op.insert) {\n              deltaIndex -= isString(op.insert) ? op.insert.length : 1;\n            }\n            else if (op.retain) {\n              deltaIndex += isNumber(op.retain) ? op.retain : 1;\n            }\n            else if (op.delete) {\n              deltaIndex += op.delete;\n            }\n\n            if (attributes) {\n              const { [blotName.tableCellInner]: nullValue, ...attrs } = attributes;\n              if (changeCellStyle) {\n                const tableCellInner = contents.slice(deltaIndex - 1, deltaIndex).ops[0];\n                if (tableCellInner?.attributes?.[blotName.tableCellInner]) {\n                  const tableCellInnerValue = tableCellInner.attributes[blotName.tableCellInner] as TableCellValue;\n                  const { style, ...value } = tableCellInnerValue;\n                  const newStyle = changeCellStyle(style);\n                  if (newStyle) {\n                    return { ...other, attributes: { ...attrs, [blotName.tableCellInner]: { style: newStyle, ...value } } };\n                  }\n                  return { ...other, attributes: { ...attrs, [blotName.tableCellInner]: value } };\n                }\n              }\n              return { ...other, attributes: { ...attrs } };\n            }\n            return op;\n          });\n          return new Delta(ops);\n        };\n        toolbar.handlers!.clean = function (this: TypeToolbar, value: unknown): void {\n          const tableUpModule = this.quill.getModule(tableUpInternal.moduleName) as TableUp;\n          const range = this.quill.getSelection();\n          if (range && range.length > 0) {\n            const formats = this.quill.getFormat(range);\n            if (formats[blotName.tableCellInner]) {\n              const diff = cleanFormatExcludeTable(range.index, range.length, false);\n              const delta = new Delta().retain(range.index).concat(diff);\n              this.quill.updateContents(delta, Quill.sources.USER);\n              return;\n            }\n          }\n          // if selection range is not in table, but use the TableSelection selected cells\n          // clean all other formats in cell\n          const tableSelection = tableUpModule.getModule<TableSelection>(tableUpInternal.tableSelectionName);\n          if (tableUpModule && tableSelection && tableSelection.selectedTds.length > 0 && tableSelection.table) {\n            const tableMain = Quill.find(tableSelection.table) as TableMainFormat;\n            if (!tableMain) {\n              console.warn('TableMainFormat not found');\n              return;\n            }\n            const selectedTds = tableSelection.selectedTds;\n\n            // get all need clean style cells. include border-right/border-bottom effect cells\n            const editTds = new Set<TableCellFormat>();\n            const tds: { td: TableCellFormat; cleanBorder: 'bottom' | 'right' | true }[] = [];\n            for (const innerTd of selectedTds) {\n              if (innerTd.parent instanceof TableCellFormat) {\n                for (const td of innerTd.parent.getNearByCell('top')) {\n                  if (editTds.has(td)) continue;\n                  editTds.add(td);\n                  tds.push({ td, cleanBorder: 'bottom' });\n                }\n                for (const td of innerTd.parent.getNearByCell('left')) {\n                  if (editTds.has(td)) continue;\n                  editTds.add(td);\n                  tds.push({ td, cleanBorder: 'right' });\n                }\n\n                editTds.add(innerTd.parent);\n                tds.push({ td: innerTd.parent, cleanBorder: true });\n              }\n            }\n            // sort cells makesure index correct\n            const allCells = tableMain.descendants(TableCellFormat);\n            const cellIndexMap = new Map(allCells.map((cell, index) => [cell, index]));\n            tds.sort((a, b) => cellIndexMap.get(a.td)! - cellIndexMap.get(b.td)!);\n\n            // compute delta\n            let delta = new Delta();\n            let lastIndex = 0;\n            for (const { td, cleanBorder } of tds) {\n              const index = td.getCellInner().offset(this.quill.scroll);\n              const length = td.getCellInner().length();\n              // `line` length will include a break(\\n) at the end. minus 1 to remove break\n              const diff = cleanFormatExcludeTable(\n                index,\n                length - 1,\n                (styleStr: string | undefined) => {\n                  if (!styleStr || cleanBorder === true) return '';\n                  // only clean border-right/border-bottom style\n                  const css = cssTextToObject(styleStr);\n                  const filterStyle = Object.keys(css).filter(key => !key.startsWith(toCamelCase(`border-${cleanBorder}`))).reduce((acc: Record<string, string>, key: string) => {\n                    acc[key] = css[key];\n                    return acc;\n                  }, {});\n                  return objectToCssText(filterStyle);\n                },\n              );\n              const cellDiff = new Delta().retain(index - lastIndex).concat(diff);\n              delta = delta.concat(cellDiff);\n              lastIndex = index + length;\n            }\n            this.quill.updateContents(delta, Quill.sources.USER);\n            if (selectedTds.length > 1) this.quill.blur();\n            return;\n          }\n          return cleanHandler.call(this, value);\n        };\n      }\n    }\n  }\n\n  async buildCustomSelect(customSelect: ((module: TableUp, picker: QuillThemePicker) => HTMLElement | Promise<HTMLElement>) | undefined, picker: QuillThemePicker) {\n    if (!customSelect || !isFunction(customSelect)) return;\n    const dom = document.createElement('div');\n    dom.classList.add('ql-custom-select');\n    this.selector = await customSelect(this, picker);\n    dom.appendChild(this.selector);\n    if (this.options.fullSwitch) {\n      const bem = createBEM('creator');\n      const isFulllLabel = document.createElement('label');\n      isFulllLabel.classList.add(bem.be('checkbox'));\n      const isFullCheckbox = document.createElement('input');\n      isFullCheckbox.type = 'checkbox';\n      isFullCheckbox.checked = this.options.full;\n      isFullCheckbox.addEventListener('change', () => {\n        this.options.full = isFullCheckbox.checked;\n      });\n      const isFullCheckboxText = document.createElement('span');\n      isFullCheckboxText.textContent = this.options.texts.fullCheckboxText;\n      isFulllLabel.appendChild(isFullCheckbox);\n      isFulllLabel.appendChild(isFullCheckboxText);\n      dom.appendChild(isFulllLabel);\n    }\n    picker.options.innerHTML = '';\n    picker.options.appendChild(dom);\n  }\n\n  setCellAttrs(selectedTds: TableCellInnerFormat[], attr: string, value?: any, isStyle: boolean = false) {\n    if (selectedTds.length === 0) return;\n    for (const td of selectedTds) {\n      td.setFormatValue(attr, value, isStyle);\n    }\n  }\n\n  getTextByCell(tds: TableCellInnerFormat[]) {\n    let text = '';\n    for (const td of tds) {\n      const index = td.offset(this.quill.scroll);\n      const length = td.length();\n      for (const op of this.quill.getContents(index, length).ops) {\n        if (isString(op.insert)) {\n          text += op.insert;\n        }\n      }\n    }\n    return text;\n  }\n\n  getHTMLByCell(tds: TableCellInnerFormat[], isCut = false) {\n    if (tds.length === 0) return '';\n    let tableMain: TableMainFormat | null = null;\n    try {\n      for (const td of tds) {\n        const tdParentMain = findParentBlot(td, blotName.tableMain);\n        if (!tableMain) {\n          tableMain = tdParentMain;\n        }\n        if (tdParentMain !== tableMain) {\n          console.error('tableMain is not same');\n          return '';\n        }\n      }\n    }\n    catch {\n      console.error('tds must be in same tableMain');\n      return '';\n    }\n\n    if (!tableMain) return '';\n    const tableIndex = this.quill.getIndex(tableMain);\n    const tableLength = tableMain.length();\n    const tableHTML = this.quill.getSemanticHTML(tableIndex, tableLength);\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(tableHTML, 'text/html');\n\n    const cols = Array.from(doc.querySelectorAll('col'));\n    const colIds = cols.map(col => col.dataset.colId!);\n    const cellColWidth: string[] = [];\n    const cellColIds = new Set<string>();\n    const cellIds = new Set<string>();\n    for (const td of tds) {\n      cellColIds.add(td.colId);\n      const currentColId = td.colId;\n      const colIndex = colIds.indexOf(currentColId);\n      for (let i = 0; i < td.colspan; i++) {\n        cellColIds.add(colIds[colIndex + i]);\n      }\n      cellIds.add(`${td.rowId}-${td.colId}`);\n    }\n    // filter col\n    for (let index = 0; index < cols.length; index++) {\n      const col = cols[index];\n      if (!cellColIds.has(col.dataset.colId!)) {\n        col.remove();\n        cols.splice(index--, 1);\n      }\n      else {\n        cellColWidth.push(col.getAttribute('width')!);\n      }\n    }\n    // filter td\n    let rowCount = 0;\n    let lastRowId: string | null = null;\n    for (const td of Array.from(doc.querySelectorAll('td, th')) as HTMLElement[]) {\n      if (!cellIds.has(`${td.dataset.rowId}-${td.dataset.colId}`)) {\n        const parent = td.parentElement;\n        td.remove();\n        if (parent && parent.children.length <= 0) {\n          parent.remove();\n        }\n      }\n      else {\n        if (lastRowId !== td.dataset.rowId) {\n          rowCount += 1;\n          lastRowId = td.dataset.rowId!;\n        }\n      }\n    }\n    // calculate width\n    const colsValue = cols.map(col => TableColFormat.value(col));\n    if (tableMain.full) {\n      const totalWidth = colsValue.reduce((total, col) => col.width + total, 0);\n      for (const [i, col] of colsValue.entries()) {\n        col.width = Math.round((col.width / totalWidth) * 100);\n        cols[i].setAttribute('width', `${col.width}%`);\n      }\n    }\n    else {\n      let width = 0;\n      for (const col of colsValue) {\n        width += col.width;\n      }\n      const tableMainDom = doc.querySelector('table')!;\n      tableMainDom.style.width = `${width}px`;\n    }\n\n    if (isCut) {\n      const trs = tableMain.getRows();\n      if (rowCount === trs.length) {\n        this.removeCol(tds);\n      }\n      else {\n        for (const td of tds) {\n          td.domNode.innerHTML = '<p><br></p>';\n        }\n      }\n    }\n    return doc.body.innerHTML;\n  }\n\n  insertTable(rows: number, columns: number, source: EmitterSource = Quill.sources.API) {\n    if (rows >= 30 || columns >= 30) {\n      throw new Error('Both rows and columns must be less than 30.');\n    }\n\n    this.quill.focus();\n    const range = this.quill.getSelection();\n    if (range == null) return;\n    const [currentBlot] = this.quill.getLeaf(range.index);\n    if (!currentBlot) return;\n    if (isForbidInTable(currentBlot)) {\n      throw new Error(`Not supported ${currentBlot.statics.blotName} insert into table.`);\n    }\n\n    const tableId = randomId();\n    const colIds = new Array(columns).fill(0).map(() => randomId());\n\n    const borderWidth = this.calculateTableCellBorderWidth();\n    const rootStyle = getComputedStyle(this.quill.root);\n    const paddingLeft = Number.parseInt(rootStyle.paddingLeft);\n    const paddingRight = Number.parseInt(rootStyle.paddingRight);\n    const scrollBarWidth = this.quill.root.scrollHeight > this.quill.root.clientHeight ? getScrollBarWidth({ target: this.quill.root }) : 0;\n    const width = Number.parseInt(rootStyle.width) - paddingLeft - paddingRight - borderWidth - scrollBarWidth;\n\n    // insert delta data to create table\n    const colWidth = !this.options.full ? `${Math.max(Math.floor(width / columns), tableUpSize.colMinWidthPx)}px` : `${Math.max((1 / columns) * 100, tableUpSize.colMinWidthPre)}%`;\n    const delta: Record<string, any>[] = [{ retain: range.index }];\n    const aroundContent = this.quill.getContents(range.index, 1);\n    const [, offset] = this.quill.getLine(range.index);\n    if (aroundContent.ops[0].insert !== '\\n' && offset !== 0) delta.push({ insert: '\\n' });\n\n    for (let i = 0; i < columns; i++) {\n      delta.push({\n        insert: {\n          [blotName.tableCol]: {\n            width: colWidth,\n            tableId,\n            colId: colIds[i],\n            full: this.options.full,\n          },\n        },\n      });\n    }\n    for (let j = 0; j < rows; j++) {\n      const rowId = randomId();\n      for (let i = 0; i < columns; i++) {\n        delta.push({\n          insert: '\\n',\n          attributes: {\n            [blotName.tableCellInner]: {\n              tableId,\n              rowId,\n              colId: colIds[i],\n              rowspan: 1,\n              colspan: 1,\n            },\n          },\n        });\n      }\n    }\n\n    this.quill.updateContents(new Delta(delta), source);\n    this.quill.setSelection(range.index + columns, Quill.sources.SILENT);\n    this.quill.focus();\n  }\n\n  calculateTableCellBorderWidth() {\n    const tableStr = `\n      <table class=\"${TableMainFormat.className}\">\n        <tbody>\n          <tr>\n            <td class=\"${TableCellFormat.className}\"></td>\n          </tr>\n        </tbody>\n      </table>\n    `;\n    const div = document.createElement('div');\n    div.className = TableWrapperFormat.className;\n    div.innerHTML = tableStr;\n    div.style.position = 'absolute';\n    div.style.left = '-9999px';\n    div.style.top = '-9999px';\n    div.style.visibility = 'hidden';\n    this.quill.root.appendChild(div);\n    const tempTableStyle = window.getComputedStyle(div.querySelector('td')!);\n    const borderWidth = Number.parseFloat(tempTableStyle.borderWidth) || 0;\n    this.quill.root.removeChild(div);\n    return borderWidth;\n  }\n\n  // handle unusual delete cell\n  fixUnusuaDeletelTable(tableBlot: TableMainFormat) {\n    const tableColIds = tableBlot.getColIds();\n    if (tableColIds.length === 0) {\n      tableBlot.remove();\n      return;\n    }\n    const bodys = tableBlot.getBodys();\n    const tableId = tableBlot.tableId;\n    for (const body of bodys) {\n    // calculate all cells in body\n      const trBlots = body.getRows();\n      if (trBlots.length === 0) {\n        body.remove();\n        continue;\n      }\n      // append by col\n      const cellSpanMap = new Array(trBlots.length).fill(0).map(() => new Array(tableColIds.length).fill(false));\n      for (const [indexTr, tr] of trBlots.entries()) {\n        let indexTd = 0;\n        let indexCol = 0;\n        const curCellSpan = cellSpanMap[indexTr];\n        const tds = tr.descendants(TableCellFormat);\n        // loop every row and column\n        while (indexCol < tableColIds.length) {\n        // skip when rowspan or colspan\n          if (curCellSpan[indexCol]) {\n            indexCol += 1;\n            continue;\n          }\n          const curTd = tds[indexTd];\n          // if colId does not match. insert a new one\n          if (!curTd || curTd.colId !== tableColIds[indexCol]) {\n            tr.insertBefore(\n              createCell(\n                this.quill.scroll,\n                {\n                  tableId,\n                  colId: tableColIds[indexCol],\n                  rowId: tr.rowId,\n                },\n              ),\n              curTd,\n            );\n          }\n          else {\n            if (indexTr + curTd.rowspan - 1 >= trBlots.length) {\n              curTd.getCellInner().rowspan = trBlots.length - indexTr;\n            }\n\n            const { colspan, rowspan } = curTd;\n            // skip next column cell\n            if (colspan > 1) {\n              for (let c = 1; c < colspan; c++) {\n                curCellSpan[indexCol + c] = true;\n              }\n            }\n            // skip next rowspan cell\n            if (rowspan > 1) {\n              for (let r = indexTr + 1; r < indexTr + rowspan; r++) {\n                for (let c = 0; c < colspan; c++) {\n                  cellSpanMap[r][indexCol + c] = true;\n                }\n              }\n            }\n            indexTd += 1;\n          }\n          indexCol += 1;\n        }\n\n        // if td not match all exist td. Indicates that a cell has been inserted\n        if (indexTd < tds.length) {\n          for (let i = indexTd; i < tds.length; i++) {\n            tds[i].remove();\n          }\n        }\n      }\n    }\n  }\n\n  balanceTables() {\n    for (const tableBlot of this.quill.scroll.descendants(TableMainFormat)) {\n      tableBlot.checkEmptyCol(this.options.autoMergeCell);\n      tableBlot.checkEmptyRow(this.options.autoMergeCell);\n      this.fixUnusuaDeletelTable(tableBlot);\n    }\n  }\n\n  listenBalanceCells() {\n    this.quill.on(\n      Quill.events.SCROLL_OPTIMIZE,\n      (mutations: MutationRecord[]) => {\n        mutations.some((mutation) => {\n          // TODO: if need add ['COL', 'COLGROUP']\n          if (['TD', 'TR', 'TBODY', 'TABLE'].includes((mutation.target as HTMLElement).tagName)) {\n            this.fixTableByLisenter();\n            return true;\n          }\n          return false;\n        });\n        for (const mutation of mutations) {\n          const mutationTarget = mutation.target as HTMLElement;\n          if (mutationTarget.tagName === 'TABLE') {\n            const tableMain = Quill.find(mutationTarget) as TableMainFormat;\n            if (tableMain) {\n              tableMain.sortMergeChildren();\n              break;\n            }\n          }\n        }\n      },\n    );\n  }\n\n  deleteTable(selectedTds: TableCellInnerFormat[]) {\n    if (selectedTds.length === 0) return;\n    const tableBlot = findParentBlot(selectedTds[0], blotName.tableMain);\n    tableBlot?.remove();\n  }\n\n  appendRow(selectedTds: TableCellInnerFormat[], isDown: boolean) {\n    if (selectedTds.length <= 0) return;\n    // find baseTd and baseTr\n    const baseTd = selectedTds[isDown ? selectedTds.length - 1 : 0];\n    const [tableBlot, baseTdParentTr] = findParentBlots(baseTd, [blotName.tableMain, blotName.tableRow] as const);\n    const tableTrs = tableBlot.getRows();\n    const i = tableTrs.indexOf(baseTdParentTr);\n    const insertRowIndex = i + (isDown ? baseTd.rowspan : 0);\n\n    tableBlot.insertRow(insertRowIndex);\n  }\n\n  appendCol(selectedTds: TableCellInnerFormat[], isRight: boolean) {\n    if (selectedTds.length <= 0) return;\n\n    // find insert column index in row\n    const [baseTd] = selectedTds.reduce((pre, cur) => {\n      const columnIndex = cur.getColumnIndex();\n      if (!isRight && columnIndex <= pre[1]) {\n        pre = [cur, columnIndex];\n      }\n      else if (isRight && columnIndex >= pre[1]) {\n        pre = [cur, columnIndex];\n      }\n      return pre;\n    }, [selectedTds[0], selectedTds[0].getColumnIndex()]);\n    const columnIndex = baseTd.getColumnIndex() + (isRight ? baseTd.colspan : 0);\n\n    const tableBlot = findParentBlot(baseTd, blotName.tableMain);\n    const tableId = tableBlot.tableId;\n    const newColId = randomId();\n\n    const [colgroup] = tableBlot.descendants(TableColgroupFormat);\n    if (colgroup) {\n      colgroup.insertColByIndex(columnIndex, {\n        tableId,\n        colId: newColId,\n        width: tableBlot.full ? 6 : 160,\n        full: tableBlot.full,\n      });\n    }\n\n    // loop tr and insert cell at index\n    // if index is inner cell, skip next `rowspan` line\n    // if there are cells both have column span and row span before index cell, minus `colspan` cell for next line\n    const trs = tableBlot.getRows();\n    const spanCols: number[] = [];\n    let skipRowNum = 0;\n    for (const tr of Object.values(trs)) {\n      const spanCol = spanCols.shift() || 0;\n      if (skipRowNum > 0) {\n        skipRowNum -= 1;\n        continue;\n      }\n      const nextSpanCols = tr.insertCell(columnIndex - spanCol, {\n        tableId,\n        rowId: tr.rowId,\n        colId: newColId,\n        rowspan: 1,\n        colspan: 1,\n      });\n      if (nextSpanCols.skipRowNum) {\n        skipRowNum += nextSpanCols.skipRowNum;\n      }\n      for (const [i, n] of nextSpanCols.entries()) {\n        spanCols[i] = (spanCols[i] || 0) + n;\n      }\n    }\n  }\n\n  /**\n   * after insert or remove cell. handle cell colspan and rowspan merge\n   */\n  fixTableByRemove(tableBlot: TableMainFormat) {\n    if (!this.options.autoMergeCell) return;\n    // calculate all cells\n    // maybe will get empty tr\n    const trBlots = tableBlot.getRows();\n    const tableCols = tableBlot.getCols();\n    const colIdMap = tableCols.reduce((idMap, col) => {\n      idMap[col.colId] = 0;\n      return idMap;\n    }, {} as Record<string, number>);\n    // merge rowspan\n    const reverseTrBlots = trBlots.toReversed();\n    const removeTr: number[] = [];\n    for (const [index, tr] of reverseTrBlots.entries()) {\n      const i = trBlots.length - index - 1;\n      if (tr.children.length <= 0) {\n        removeTr.push(i);\n      }\n      else {\n        // if have td rowspan across empty tr. minus rowspan\n        tr.foreachCellInner((td) => {\n          const sum = removeTr.reduce((sum, val) => td.rowspan + i > val ? sum + 1 : sum, 0);\n          td.rowspan -= sum;\n          // count exist col\n          colIdMap[td.colId] += 1;\n        });\n      }\n    }\n    // merge colspan\n    let index = 0;\n    for (const count of Object.values(colIdMap)) {\n      if (count === 0) {\n        const spanCols: number[] = [];\n        let skipRowNum = 0;\n        for (const tr of Object.values(trBlots)) {\n          const spanCol = spanCols.shift() || 0;\n          let nextSpanCols = [];\n          if (skipRowNum > 0) {\n            nextSpanCols = tr.getCellByColumIndex(index - spanCol)[2];\n            skipRowNum -= 1;\n          }\n          else {\n            nextSpanCols = tr.removeCell(index - spanCol);\n            if (nextSpanCols.skipRowNum) {\n              skipRowNum += nextSpanCols.skipRowNum;\n            }\n          }\n          for (const [i, n] of nextSpanCols.entries()) {\n            spanCols[i] = (spanCols[i] || 0) + n;\n          }\n        }\n      }\n      else {\n        index += 1;\n      }\n    }\n    // remove col\n    for (const col of tableCols) {\n      if (colIdMap[col.colId] === 0) {\n        if (col.prev) {\n          (col.prev as TableColFormat).width += col.width;\n        }\n        else if (col.next) {\n          (col.next as TableColFormat).width += col.width;\n        }\n        col.remove();\n      }\n    }\n  }\n\n  removeRow(selectedTds: TableCellInnerFormat[]) {\n    if (selectedTds.length <= 0) return;\n    const baseTd = selectedTds[0];\n    const tableBlot = findParentBlot(baseTd, blotName.tableMain);\n    const trs = tableBlot.getRows();\n    let endTrIndex = trs.length;\n    let nextTrIndex = -1;\n    for (const td of selectedTds) {\n      const tr = findParentBlot(td, blotName.tableRow);\n      const index = trs.indexOf(tr);\n      if (index < endTrIndex) {\n        endTrIndex = index;\n      }\n      if (index + td.rowspan > nextTrIndex) {\n        nextTrIndex = index + td.rowspan;\n      }\n    }\n\n    const patchTds: Record<string, {\n      rowspan: number;\n      colspan: number;\n      colIndex: number;\n    }> = {};\n    for (let i = endTrIndex; i < Math.min(trs.length, nextTrIndex); i++) {\n      const tr = trs[i];\n      tr.foreachCellInner((td) => {\n        // find cells in rowspan that exceed the deletion range\n        if (td.rowspan + i > nextTrIndex) {\n          patchTds[td.colId] = {\n            rowspan: td.rowspan + i - nextTrIndex,\n            colspan: td.colspan,\n            colIndex: td.getColumnIndex(),\n          };\n        }\n        // only remove td. empty tr to calculate colspan and rowspan\n        td.parent.remove();\n      });\n      if (tr.length() === 0) tr.remove();\n    }\n\n    if (trs[nextTrIndex]) {\n      const nextTr = trs[nextTrIndex];\n      const tableId = tableBlot.tableId;\n      // insert cell in nextTr to patch exceed cell\n      for (const [colId, { colIndex, colspan, rowspan }] of Object.entries(patchTds)) {\n        nextTr.insertCell(colIndex, {\n          tableId,\n          rowId: nextTr.rowId,\n          colId,\n          colspan,\n          rowspan,\n        });\n      }\n    }\n\n    this.fixTableByRemove(tableBlot);\n  }\n\n  removeCol(selectedTds: TableCellInnerFormat[]) {\n    if (selectedTds.length <= 0) return;\n    const baseTd = selectedTds[0];\n    const tableBlot = findParentBlot(baseTd, blotName.tableMain);\n    const colspanMap: Record<string, number> = {};\n    for (const td of selectedTds) {\n      if (!colspanMap[td.rowId]) colspanMap[td.rowId] = 0;\n      colspanMap[td.rowId] += td.colspan;\n    }\n    const colspanCount = Math.max(...Object.values(colspanMap));\n    const columnIndex = baseTd.getColumnIndex();\n\n    const trs = tableBlot.descendants(TableRowFormat);\n    for (let i = 0; i < colspanCount; i++) {\n      const spanCols: number[] = [];\n      let skipRowNum = 0;\n      for (const tr of Object.values(trs)) {\n        const spanCol = spanCols.shift() || 0;\n        if (skipRowNum > 0) {\n          skipRowNum -= 1;\n          continue;\n        }\n        const nextSpanCols = tr.removeCell(columnIndex - spanCol);\n        if (nextSpanCols.skipRowNum) {\n          skipRowNum += nextSpanCols.skipRowNum;\n        }\n        for (const [i, n] of nextSpanCols.entries()) {\n          spanCols[i] = (spanCols[i] || 0) + n;\n        }\n      }\n    }\n    // delete col need after remove cell. remove cell need all column id\n    // manual delete col. use fixTableByRemove to delete col will delete extra cells\n    const [colgroup] = tableBlot.descendants(TableColgroupFormat);\n    if (colgroup) {\n      for (let i = 0; i < colspanCount; i++) {\n        colgroup.removeColByIndex(columnIndex);\n      }\n    }\n\n    this.fixTableByRemove(tableBlot);\n  }\n\n  mergeCells(selectedTds: TableCellInnerFormat[]) {\n    if (selectedTds.length <= 1) return;\n    const baseCell = selectedTds[0];\n    // move selected cells in same table body\n    const baseCellBody = baseCell.getTableBody();\n    // insert base row\n    let baseRow = baseCell.getTableRow();\n    if (!baseCellBody || !baseRow) return;\n    for (let i = 1; i < selectedTds.length; i++) {\n      const selectTd = selectedTds[i];\n      const currentTdBody = selectTd.getTableBody();\n      if (currentTdBody && currentTdBody !== baseCellBody) {\n        const currentRow = selectTd.getTableRow();\n        if (currentRow) {\n          baseRow.parent.insertBefore(currentRow, baseRow.next);\n          baseRow = currentRow;\n        }\n      }\n    }\n    baseCellBody.convertBody(baseCell.wrapTag);\n\n    const counts = selectedTds.reduce(\n      (pre, selectTd, index) => {\n        // count column span\n        const colId = selectTd.colId;\n        if (!pre[0][colId]) pre[0][colId] = 0;\n        pre[0][colId] += selectTd.rowspan;\n        // count row span\n        const rowId = selectTd.rowId;\n        if (!pre[1][rowId]) pre[1][rowId] = 0;\n        pre[1][rowId] += selectTd.colspan;\n        // merge select cell\n        if (index !== 0) {\n          // remove empty \\n\n          if (selectTd.length() > 1) {\n            selectTd.moveChildren(pre[2]);\n          }\n          selectTd.parent.remove();\n        }\n        return pre;\n      },\n      [{} as Record<string, number>, {} as Record<string, number>, baseCell] as const,\n    );\n\n    const rowCount = Math.max(...Object.values(counts[0]));\n    const colCount = Math.max(...Object.values(counts[1]));\n    const baseTd = counts[2];\n    baseTd.colspan = colCount;\n    baseTd.rowspan = rowCount;\n\n    // selection will move with cursor. make sure selection is in baseTd\n    const index = this.quill.getIndex(baseTd);\n    this.quill.setSelection({ index, length: 0 }, Quill.sources.SILENT);\n\n    const tableBlot = findParentBlot(baseTd, blotName.tableMain);\n    this.fixTableByRemove(tableBlot);\n  }\n\n  splitCell(selectedTds: TableCellInnerFormat[]) {\n    if (selectedTds.length !== 1) return;\n    const baseCell = selectedTds[0];\n    if (baseCell.colspan === 1 && baseCell.rowspan === 1) return;\n    const [tableBlot, baseTr] = findParentBlots(baseCell, [blotName.tableMain, blotName.tableRow] as const);\n    const rows = tableBlot.getRows();\n    const tableId = tableBlot.tableId;\n    const colIndex = baseCell.getColumnIndex();\n    const colIds = tableBlot.getColIds().slice(colIndex, colIndex + baseCell.colspan).toReversed();\n    const baseCellValue = baseCell.formats()[blotName.tableCellInner] as TableCellValue;\n    const { emptyRow, ...extendsBaseCellValue } = baseCellValue;\n\n    let rowIndex = rows.indexOf(baseTr);\n    if (rowIndex === -1) return;\n    let curTr = rows[rowIndex];\n    let rowspan = baseCell.rowspan;\n    // reset span first. insertCell need colspan to judge insert position\n    baseCell.colspan = 1;\n    baseCell.rowspan = 1;\n    while (curTr && rowspan > 0) {\n      for (const id of colIds) {\n        // keep baseCell. baseTr should insert at baseCell's column index + 1\n        if (curTr === baseTr && id === baseCell.colId) continue;\n        curTr.insertCell(\n          colIndex + (curTr === baseTr ? 1 : 0),\n          {\n            ...extendsBaseCellValue,\n            tableId,\n            rowId: curTr.rowId,\n            colId: id,\n            rowspan: 1,\n            colspan: 1,\n          },\n        );\n      }\n\n      rowspan -= 1;\n      rowIndex += 1;\n      curTr = rows[rowIndex];\n    }\n  }\n\n  convertTableBodyByCells(tableBlot: TableMainFormat, selecteds: TableCellInnerFormat[], tag: TableBodyTag) {\n    let firstRowIndex: number | undefined;\n    let lastRowIndex: number | undefined;\n    const rows = tableBlot.getRows();\n    for (const cell of selecteds) {\n      const row = cell.getTableRow();\n      if (!row) continue;\n      const index = rows.indexOf(row);\n      if (isUndefined(firstRowIndex)) {\n        firstRowIndex = index;\n      }\n      if (isUndefined(lastRowIndex)) {\n        lastRowIndex = index;\n      }\n\n      if (index < firstRowIndex) {\n        lastRowIndex = firstRowIndex;\n        firstRowIndex = index;\n      }\n      else if (index > lastRowIndex) {\n        lastRowIndex = index;\n      }\n    }\n    if (isUndefined(firstRowIndex) || isUndefined(lastRowIndex)) {\n      console.warn('TableRow not found');\n      return;\n    }\n    const firstRow = rows[firstRowIndex];\n    const lastRow = rows[lastRowIndex];\n    tableBlot.split(lastRow.offset(tableBlot) + lastRow.length());\n    const currentTable = tableBlot.split(firstRow.offset(tableBlot)) as TableMainFormat;\n    // selecteds may in different bodys\n    // create a new body, insert to current table, move all rows to new body, then call new body's convertBody\n    const currentTableRows = currentTable.getRows();\n    const [firstBody] = currentTable.getBodys();\n    const newBody = firstBody.clone() as TableBodyFormat;\n    currentTable.appendChild(newBody);\n    for (const row of currentTableRows) {\n      // only move the not empty row. the empty row will regenerate when `optimize`\n      if (row.length() > 0) {\n        newBody.appendChild(row);\n      }\n    }\n    newBody.convertBody(tag);\n    firstBody.remove();\n  }\n}\n","import { TableUp } from './table-up';\n\nexport default TableUp;\nexport * from './formats';\nexport * from './modules';\nexport * from './table-up';\nexport {\n  blotName,\n  createColorPicker,\n  createSelectBox,\n  createTooltip,\n  findParentBlot,\n  findParentBlots,\n  randomId,\n  tableUpEvent,\n  tableUpInternal,\n  tableUpSize,\n} from './utils';\nexport * from './utils/types';\n"],"x_google_ignoreList":[11,12,13,14],"mappings":"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"}